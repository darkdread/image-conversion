!function(g,I){"object"==typeof exports&&"object"==typeof module?module.exports=I():"function"==typeof define&&define.amd?define([],I):"object"==typeof exports?exports.imageConversion=I():g.imageConversion=I()}(this,(function(){return function(g){var I={};function B(n){if(I[n])return I[n].exports;var Q=I[n]={i:n,l:!1,exports:{}};return g[n].call(Q.exports,Q,Q.exports,B),Q.l=!0,Q.exports}return B.m=g,B.c=I,B.d=function(g,I,n){B.o(g,I)||Object.defineProperty(g,I,{enumerable:!0,get:n})},B.r=function(g){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(g,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(g,"__esModule",{value:!0})},B.t=function(g,I){if(1&I&&(g=B(g)),8&I)return g;if(4&I&&"object"==typeof g&&g&&g.__esModule)return g;var n=Object.create(null);if(B.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:g}),2&I&&"string"!=typeof g)for(var Q in g)B.d(n,Q,function(I){return g[I]}.bind(null,Q));return n},B.n=function(g){var I=g&&g.__esModule?function(){return g.default}:function(){return g};return B.d(I,"a",I),I},B.o=function(g,I){return Object.prototype.hasOwnProperty.call(g,I)},B.p="",B(B.s=1)}([function(module,exports,__webpack_require__){"use strict";eval('// (c) Dean McNamee <dean@gmail.com>, 2013.\n//\n// https://github.com/deanm/omggif\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the "Software"), to\n// deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n// sell copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n// IN THE SOFTWARE.\n//\n// omggif is a JavaScript implementation of a GIF 89a encoder and decoder,\n// including animation and compression.  It does not rely on any specific\n// underlying system, so should run in the browser, Node, or Plask.\n\n\n\nfunction GifWriter(buf, width, height, gopts) {\n  var p = 0;\n\n  var gopts = gopts === undefined ? { } : gopts;\n  var loop_count = gopts.loop === undefined ? null : gopts.loop;\n  var global_palette = gopts.palette === undefined ? null : gopts.palette;\n\n  if (width <= 0 || height <= 0 || width > 65535 || height > 65535)\n    throw new Error("Width/Height invalid.");\n\n  function check_palette_and_num_colors(palette) {\n    var num_colors = palette.length;\n    if (num_colors < 2 || num_colors > 256 ||  num_colors & (num_colors-1)) {\n      throw new Error(\n          "Invalid code/color length, must be power of 2 and 2 .. 256.");\n    }\n    return num_colors;\n  }\n\n  // - Header.\n  buf[p++] = 0x47; buf[p++] = 0x49; buf[p++] = 0x46;  // GIF\n  buf[p++] = 0x38; buf[p++] = 0x39; buf[p++] = 0x61;  // 89a\n\n  // Handling of Global Color Table (palette) and background index.\n  var gp_num_colors_pow2 = 0;\n  var background = 0;\n  if (global_palette !== null) {\n    var gp_num_colors = check_palette_and_num_colors(global_palette);\n    while (gp_num_colors >>= 1) ++gp_num_colors_pow2;\n    gp_num_colors = 1 << gp_num_colors_pow2;\n    --gp_num_colors_pow2;\n    if (gopts.background !== undefined) {\n      background = gopts.background;\n      if (background >= gp_num_colors)\n        throw new Error("Background index out of range.");\n      // The GIF spec states that a background index of 0 should be ignored, so\n      // this is probably a mistake and you really want to set it to another\n      // slot in the palette.  But actually in the end most browsers, etc end\n      // up ignoring this almost completely (including for dispose background).\n      if (background === 0)\n        throw new Error("Background index explicitly passed as 0.");\n    }\n  }\n\n  // - Logical Screen Descriptor.\n  // NOTE(deanm): w/h apparently ignored by implementations, but set anyway.\n  buf[p++] = width & 0xff; buf[p++] = width >> 8 & 0xff;\n  buf[p++] = height & 0xff; buf[p++] = height >> 8 & 0xff;\n  // NOTE: Indicates 0-bpp original color resolution (unused?).\n  buf[p++] = (global_palette !== null ? 0x80 : 0) |  // Global Color Table Flag.\n             gp_num_colors_pow2;  // NOTE: No sort flag (unused?).\n  buf[p++] = background;  // Background Color Index.\n  buf[p++] = 0;  // Pixel aspect ratio (unused?).\n\n  // - Global Color Table\n  if (global_palette !== null) {\n    for (var i = 0, il = global_palette.length; i < il; ++i) {\n      var rgb = global_palette[i];\n      buf[p++] = rgb >> 16 & 0xff;\n      buf[p++] = rgb >> 8 & 0xff;\n      buf[p++] = rgb & 0xff;\n    }\n  }\n\n  if (loop_count !== null) {  // Netscape block for looping.\n    if (loop_count < 0 || loop_count > 65535)\n      throw new Error("Loop count invalid.")\n    // Extension code, label, and length.\n    buf[p++] = 0x21; buf[p++] = 0xff; buf[p++] = 0x0b;\n    // NETSCAPE2.0\n    buf[p++] = 0x4e; buf[p++] = 0x45; buf[p++] = 0x54; buf[p++] = 0x53;\n    buf[p++] = 0x43; buf[p++] = 0x41; buf[p++] = 0x50; buf[p++] = 0x45;\n    buf[p++] = 0x32; buf[p++] = 0x2e; buf[p++] = 0x30;\n    // Sub-block\n    buf[p++] = 0x03; buf[p++] = 0x01;\n    buf[p++] = loop_count & 0xff; buf[p++] = loop_count >> 8 & 0xff;\n    buf[p++] = 0x00;  // Terminator.\n  }\n\n\n  var ended = false;\n\n  this.addFrame = function(x, y, w, h, indexed_pixels, opts) {\n    if (ended === true) { --p; ended = false; }  // Un-end.\n\n    opts = opts === undefined ? { } : opts;\n\n    // TODO(deanm): Bounds check x, y.  Do they need to be within the virtual\n    // canvas width/height, I imagine?\n    if (x < 0 || y < 0 || x > 65535 || y > 65535)\n      throw new Error("x/y invalid.")\n\n    if (w <= 0 || h <= 0 || w > 65535 || h > 65535)\n      throw new Error("Width/Height invalid.")\n\n    if (indexed_pixels.length < w * h)\n      throw new Error("Not enough pixels for the frame size.");\n\n    var using_local_palette = true;\n    var palette = opts.palette;\n    if (palette === undefined || palette === null) {\n      using_local_palette = false;\n      palette = global_palette;\n    }\n\n    if (palette === undefined || palette === null)\n      throw new Error("Must supply either a local or global palette.");\n\n    var num_colors = check_palette_and_num_colors(palette);\n\n    // Compute the min_code_size (power of 2), destroying num_colors.\n    var min_code_size = 0;\n    while (num_colors >>= 1) ++min_code_size;\n    num_colors = 1 << min_code_size;  // Now we can easily get it back.\n\n    var delay = opts.delay === undefined ? 0 : opts.delay;\n\n    // From the spec:\n    //     0 -   No disposal specified. The decoder is\n    //           not required to take any action.\n    //     1 -   Do not dispose. The graphic is to be left\n    //           in place.\n    //     2 -   Restore to background color. The area used by the\n    //           graphic must be restored to the background color.\n    //     3 -   Restore to previous. The decoder is required to\n    //           restore the area overwritten by the graphic with\n    //           what was there prior to rendering the graphic.\n    //  4-7 -    To be defined.\n    // NOTE(deanm): Dispose background doesn\'t really work, apparently most\n    // browsers ignore the background palette index and clear to transparency.\n    var disposal = opts.disposal === undefined ? 0 : opts.disposal;\n    if (disposal < 0 || disposal > 3)  // 4-7 is reserved.\n      throw new Error("Disposal out of range.");\n\n    var use_transparency = false;\n    var transparent_index = 0;\n    if (opts.transparent !== undefined && opts.transparent !== null) {\n      use_transparency = true;\n      transparent_index = opts.transparent;\n      if (transparent_index < 0 || transparent_index >= num_colors)\n        throw new Error("Transparent color index.");\n    }\n\n    if (disposal !== 0 || use_transparency || delay !== 0) {\n      // - Graphics Control Extension\n      buf[p++] = 0x21; buf[p++] = 0xf9;  // Extension / Label.\n      buf[p++] = 4;  // Byte size.\n\n      buf[p++] = disposal << 2 | (use_transparency === true ? 1 : 0);\n      buf[p++] = delay & 0xff; buf[p++] = delay >> 8 & 0xff;\n      buf[p++] = transparent_index;  // Transparent color index.\n      buf[p++] = 0;  // Block Terminator.\n    }\n\n    // - Image Descriptor\n    buf[p++] = 0x2c;  // Image Seperator.\n    buf[p++] = x & 0xff; buf[p++] = x >> 8 & 0xff;  // Left.\n    buf[p++] = y & 0xff; buf[p++] = y >> 8 & 0xff;  // Top.\n    buf[p++] = w & 0xff; buf[p++] = w >> 8 & 0xff;\n    buf[p++] = h & 0xff; buf[p++] = h >> 8 & 0xff;\n    // NOTE: No sort flag (unused?).\n    // TODO(deanm): Support interlace.\n    buf[p++] = using_local_palette === true ? (0x80 | (min_code_size-1)) : 0;\n\n    // - Local Color Table\n    if (using_local_palette === true) {\n      for (var i = 0, il = palette.length; i < il; ++i) {\n        var rgb = palette[i];\n        buf[p++] = rgb >> 16 & 0xff;\n        buf[p++] = rgb >> 8 & 0xff;\n        buf[p++] = rgb & 0xff;\n      }\n    }\n\n    p = GifWriterOutputLZWCodeStream(\n            buf, p, min_code_size < 2 ? 2 : min_code_size, indexed_pixels);\n\n    return p;\n  };\n\n  this.end = function() {\n    if (ended === false) {\n      buf[p++] = 0x3b;  // Trailer.\n      ended = true;\n    }\n    return p;\n  };\n\n  this.getOutputBuffer = function() { return buf; };\n  this.setOutputBuffer = function(v) { buf = v; };\n  this.getOutputBufferPosition = function() { return p; };\n  this.setOutputBufferPosition = function(v) { p = v; };\n}\n\n// Main compression routine, palette indexes -> LZW code stream.\n// |index_stream| must have at least one entry.\nfunction GifWriterOutputLZWCodeStream(buf, p, min_code_size, index_stream) {\n  buf[p++] = min_code_size;\n  var cur_subblock = p++;  // Pointing at the length field.\n\n  var clear_code = 1 << min_code_size;\n  var code_mask = clear_code - 1;\n  var eoi_code = clear_code + 1;\n  var next_code = eoi_code + 1;\n\n  var cur_code_size = min_code_size + 1;  // Number of bits per code.\n  var cur_shift = 0;\n  // We have at most 12-bit codes, so we should have to hold a max of 19\n  // bits here (and then we would write out).\n  var cur = 0;\n\n  function emit_bytes_to_buffer(bit_block_size) {\n    while (cur_shift >= bit_block_size) {\n      buf[p++] = cur & 0xff;\n      cur >>= 8; cur_shift -= 8;\n      if (p === cur_subblock + 256) {  // Finished a subblock.\n        buf[cur_subblock] = 255;\n        cur_subblock = p++;\n      }\n    }\n  }\n\n  function emit_code(c) {\n    cur |= c << cur_shift;\n    cur_shift += cur_code_size;\n    emit_bytes_to_buffer(8);\n  }\n\n  // I am not an expert on the topic, and I don\'t want to write a thesis.\n  // However, it is good to outline here the basic algorithm and the few data\n  // structures and optimizations here that make this implementation fast.\n  // The basic idea behind LZW is to build a table of previously seen runs\n  // addressed by a short id (herein called output code).  All data is\n  // referenced by a code, which represents one or more values from the\n  // original input stream.  All input bytes can be referenced as the same\n  // value as an output code.  So if you didn\'t want any compression, you\n  // could more or less just output the original bytes as codes (there are\n  // some details to this, but it is the idea).  In order to achieve\n  // compression, values greater then the input range (codes can be up to\n  // 12-bit while input only 8-bit) represent a sequence of previously seen\n  // inputs.  The decompressor is able to build the same mapping while\n  // decoding, so there is always a shared common knowledge between the\n  // encoding and decoder, which is also important for "timing" aspects like\n  // how to handle variable bit width code encoding.\n  //\n  // One obvious but very important consequence of the table system is there\n  // is always a unique id (at most 12-bits) to map the runs.  \'A\' might be\n  // 4, then \'AA\' might be 10, \'AAA\' 11, \'AAAA\' 12, etc.  This relationship\n  // can be used for an effecient lookup strategy for the code mapping.  We\n  // need to know if a run has been seen before, and be able to map that run\n  // to the output code.  Since we start with known unique ids (input bytes),\n  // and then from those build more unique ids (table entries), we can\n  // continue this chain (almost like a linked list) to always have small\n  // integer values that represent the current byte chains in the encoder.\n  // This means instead of tracking the input bytes (AAAABCD) to know our\n  // current state, we can track the table entry for AAAABC (it is guaranteed\n  // to exist by the nature of the algorithm) and the next character D.\n  // Therefor the tuple of (table_entry, byte) is guaranteed to also be\n  // unique.  This allows us to create a simple lookup key for mapping input\n  // sequences to codes (table indices) without having to store or search\n  // any of the code sequences.  So if \'AAAA\' has a table entry of 12, the\n  // tuple of (\'AAAA\', K) for any input byte K will be unique, and can be our\n  // key.  This leads to a integer value at most 20-bits, which can always\n  // fit in an SMI value and be used as a fast sparse array / object key.\n\n  // Output code for the current contents of the index buffer.\n  var ib_code = index_stream[0] & code_mask;  // Load first input index.\n  var code_table = { };  // Key\'d on our 20-bit "tuple".\n\n  emit_code(clear_code);  // Spec says first code should be a clear code.\n\n  // First index already loaded, process the rest of the stream.\n  for (var i = 1, il = index_stream.length; i < il; ++i) {\n    var k = index_stream[i] & code_mask;\n    var cur_key = ib_code << 8 | k;  // (prev, k) unique tuple.\n    var cur_code = code_table[cur_key];  // buffer + k.\n\n    // Check if we have to create a new code table entry.\n    if (cur_code === undefined) {  // We don\'t have buffer + k.\n      // Emit index buffer (without k).\n      // This is an inline version of emit_code, because this is the core\n      // writing routine of the compressor (and V8 cannot inline emit_code\n      // because it is a closure here in a different context).  Additionally\n      // we can call emit_byte_to_buffer less often, because we can have\n      // 30-bits (from our 31-bit signed SMI), and we know our codes will only\n      // be 12-bits, so can safely have 18-bits there without overflow.\n      // emit_code(ib_code);\n      cur |= ib_code << cur_shift;\n      cur_shift += cur_code_size;\n      while (cur_shift >= 8) {\n        buf[p++] = cur & 0xff;\n        cur >>= 8; cur_shift -= 8;\n        if (p === cur_subblock + 256) {  // Finished a subblock.\n          buf[cur_subblock] = 255;\n          cur_subblock = p++;\n        }\n      }\n\n      if (next_code === 4096) {  // Table full, need a clear.\n        emit_code(clear_code);\n        next_code = eoi_code + 1;\n        cur_code_size = min_code_size + 1;\n        code_table = { };\n      } else {  // Table not full, insert a new entry.\n        // Increase our variable bit code sizes if necessary.  This is a bit\n        // tricky as it is based on "timing" between the encoding and\n        // decoder.  From the encoders perspective this should happen after\n        // we\'ve already emitted the index buffer and are about to create the\n        // first table entry that would overflow our current code bit size.\n        if (next_code >= (1 << cur_code_size)) ++cur_code_size;\n        code_table[cur_key] = next_code++;  // Insert into code table.\n      }\n\n      ib_code = k;  // Index buffer to single input k.\n    } else {\n      ib_code = cur_code;  // Index buffer to sequence in code table.\n    }\n  }\n\n  emit_code(ib_code);  // There will still be something in the index buffer.\n  emit_code(eoi_code);  // End Of Information.\n\n  // Flush / finalize the sub-blocks stream to the buffer.\n  emit_bytes_to_buffer(1);\n\n  // Finish the sub-blocks, writing out any unfinished lengths and\n  // terminating with a sub-block of length 0.  If we have already started\n  // but not yet used a sub-block it can just become the terminator.\n  if (cur_subblock + 1 === p) {  // Started but unused.\n    buf[cur_subblock] = 0;\n  } else {  // Started and used, write length and additional terminator block.\n    buf[cur_subblock] = p - cur_subblock - 1;\n    buf[p++] = 0;\n  }\n  return p;\n}\n\nfunction GifReader(buf) {\n  var p = 0;\n\n  // - Header (GIF87a or GIF89a).\n  if (buf[p++] !== 0x47 ||            buf[p++] !== 0x49 || buf[p++] !== 0x46 ||\n      buf[p++] !== 0x38 || (buf[p++]+1 & 0xfd) !== 0x38 || buf[p++] !== 0x61) {\n    throw new Error("Invalid GIF 87a/89a header.");\n  }\n\n  // - Logical Screen Descriptor.\n  var width = buf[p++] | buf[p++] << 8;\n  var height = buf[p++] | buf[p++] << 8;\n  var pf0 = buf[p++];  // <Packed Fields>.\n  var global_palette_flag = pf0 >> 7;\n  var num_global_colors_pow2 = pf0 & 0x7;\n  var num_global_colors = 1 << (num_global_colors_pow2 + 1);\n  var background = buf[p++];\n  buf[p++];  // Pixel aspect ratio (unused?).\n\n  var global_palette_offset = null;\n  var global_palette_size   = null;\n\n  if (global_palette_flag) {\n    global_palette_offset = p;\n    global_palette_size = num_global_colors;\n    p += num_global_colors * 3;  // Seek past palette.\n  }\n\n  var no_eof = true;\n\n  var frames = [ ];\n\n  var delay = 0;\n  var transparent_index = null;\n  var disposal = 0;  // 0 - No disposal specified.\n  var loop_count = null;\n\n  this.width = width;\n  this.height = height;\n\n  while (no_eof && p < buf.length) {\n    switch (buf[p++]) {\n      case 0x21:  // Graphics Control Extension Block\n        switch (buf[p++]) {\n          case 0xff:  // Application specific block\n            // Try if it\'s a Netscape block (with animation loop counter).\n            if (buf[p   ] !== 0x0b ||  // 21 FF already read, check block size.\n                // NETSCAPE2.0\n                buf[p+1 ] == 0x4e && buf[p+2 ] == 0x45 && buf[p+3 ] == 0x54 &&\n                buf[p+4 ] == 0x53 && buf[p+5 ] == 0x43 && buf[p+6 ] == 0x41 &&\n                buf[p+7 ] == 0x50 && buf[p+8 ] == 0x45 && buf[p+9 ] == 0x32 &&\n                buf[p+10] == 0x2e && buf[p+11] == 0x30 &&\n                // Sub-block\n                buf[p+12] == 0x03 && buf[p+13] == 0x01 && buf[p+16] == 0) {\n              p += 14;\n              loop_count = buf[p++] | buf[p++] << 8;\n              p++;  // Skip terminator.\n            } else {  // We don\'t know what it is, just try to get past it.\n              p += 12;\n              while (true) {  // Seek through subblocks.\n                var block_size = buf[p++];\n                // Bad block size (ex: undefined from an out of bounds read).\n                if (!(block_size >= 0)) throw Error("Invalid block size");\n                if (block_size === 0) break;  // 0 size is terminator\n                p += block_size;\n              }\n            }\n            break;\n\n          case 0xf9:  // Graphics Control Extension\n            if (buf[p++] !== 0x4 || buf[p+4] !== 0)\n              throw new Error("Invalid graphics extension block.");\n            var pf1 = buf[p++];\n            delay = buf[p++] | buf[p++] << 8;\n            transparent_index = buf[p++];\n            if ((pf1 & 1) === 0) transparent_index = null;\n            disposal = pf1 >> 2 & 0x7;\n            p++;  // Skip terminator.\n            break;\n\n          case 0xfe:  // Comment Extension.\n            while (true) {  // Seek through subblocks.\n              var block_size = buf[p++];\n              // Bad block size (ex: undefined from an out of bounds read).\n              if (!(block_size >= 0)) throw Error("Invalid block size");\n              if (block_size === 0) break;  // 0 size is terminator\n              // console.log(buf.slice(p, p+block_size).toString(\'ascii\'));\n              p += block_size;\n            }\n            break;\n\n          default:\n            throw new Error(\n                "Unknown graphic control label: 0x" + buf[p-1].toString(16));\n        }\n        break;\n\n      case 0x2c:  // Image Descriptor.\n        var x = buf[p++] | buf[p++] << 8;\n        var y = buf[p++] | buf[p++] << 8;\n        var w = buf[p++] | buf[p++] << 8;\n        var h = buf[p++] | buf[p++] << 8;\n        var pf2 = buf[p++];\n        var local_palette_flag = pf2 >> 7;\n        var interlace_flag = pf2 >> 6 & 1;\n        var num_local_colors_pow2 = pf2 & 0x7;\n        var num_local_colors = 1 << (num_local_colors_pow2 + 1);\n        var palette_offset = global_palette_offset;\n        var palette_size = global_palette_size;\n        var has_local_palette = false;\n        if (local_palette_flag) {\n          var has_local_palette = true;\n          palette_offset = p;  // Override with local palette.\n          palette_size = num_local_colors;\n          p += num_local_colors * 3;  // Seek past palette.\n        }\n\n        var data_offset = p;\n\n        p++;  // codesize\n        while (true) {\n          var block_size = buf[p++];\n          // Bad block size (ex: undefined from an out of bounds read).\n          if (!(block_size >= 0)) throw Error("Invalid block size");\n          if (block_size === 0) break;  // 0 size is terminator\n          p += block_size;\n        }\n\n        frames.push({x: x, y: y, width: w, height: h,\n                     has_local_palette: has_local_palette,\n                     palette_offset: palette_offset,\n                     palette_size: palette_size,\n                     data_offset: data_offset,\n                     data_length: p - data_offset,\n                     transparent_index: transparent_index,\n                     interlaced: !!interlace_flag,\n                     delay: delay,\n                     disposal: disposal});\n        break;\n\n      case 0x3b:  // Trailer Marker (end of file).\n        no_eof = false;\n        break;\n\n      default:\n        throw new Error("Unknown gif block: 0x" + buf[p-1].toString(16));\n        break;\n    }\n  }\n\n  this.numFrames = function() {\n    return frames.length;\n  };\n\n  this.loopCount = function() {\n    return loop_count;\n  };\n\n  this.frameInfo = function(frame_num) {\n    if (frame_num < 0 || frame_num >= frames.length)\n      throw new Error("Frame index out of range.");\n    return frames[frame_num];\n  }\n\n  this.decodeAndBlitFrameBGRA = function(frame_num, pixels) {\n    var frame = this.frameInfo(frame_num);\n    var num_pixels = frame.width * frame.height;\n    var index_stream = new Uint8Array(num_pixels);  // At most 8-bit indices.\n    GifReaderLZWOutputIndexStream(\n        buf, frame.data_offset, index_stream, num_pixels);\n    var palette_offset = frame.palette_offset;\n\n    // NOTE(deanm): It seems to be much faster to compare index to 256 than\n    // to === null.  Not sure why, but CompareStub_EQ_STRICT shows up high in\n    // the profile, not sure if it\'s related to using a Uint8Array.\n    var trans = frame.transparent_index;\n    if (trans === null) trans = 256;\n\n    // We are possibly just blitting to a portion of the entire frame.\n    // That is a subrect within the framerect, so the additional pixels\n    // must be skipped over after we finished a scanline.\n    var framewidth  = frame.width;\n    var framestride = width - framewidth;\n    var xleft       = framewidth;  // Number of subrect pixels left in scanline.\n\n    // Output indicies of the top left and bottom right corners of the subrect.\n    var opbeg = ((frame.y * width) + frame.x) * 4;\n    var opend = ((frame.y + frame.height) * width + frame.x) * 4;\n    var op    = opbeg;\n\n    var scanstride = framestride * 4;\n\n    // Use scanstride to skip past the rows when interlacing.  This is skipping\n    // 7 rows for the first two passes, then 3 then 1.\n    if (frame.interlaced === true) {\n      scanstride += width * 4 * 7;  // Pass 1.\n    }\n\n    var interlaceskip = 8;  // Tracking the row interval in the current pass.\n\n    for (var i = 0, il = index_stream.length; i < il; ++i) {\n      var index = index_stream[i];\n\n      if (xleft === 0) {  // Beginning of new scan line\n        op += scanstride;\n        xleft = framewidth;\n        if (op >= opend) { // Catch the wrap to switch passes when interlacing.\n          scanstride = framestride * 4 + width * 4 * (interlaceskip-1);\n          // interlaceskip / 2 * 4 is interlaceskip << 1.\n          op = opbeg + (framewidth + framestride) * (interlaceskip << 1);\n          interlaceskip >>= 1;\n        }\n      }\n\n      if (index === trans) {\n        op += 4;\n      } else {\n        var r = buf[palette_offset + index * 3];\n        var g = buf[palette_offset + index * 3 + 1];\n        var b = buf[palette_offset + index * 3 + 2];\n        pixels[op++] = b;\n        pixels[op++] = g;\n        pixels[op++] = r;\n        pixels[op++] = 255;\n      }\n      --xleft;\n    }\n  };\n\n  // I will go to copy and paste hell one day...\n  this.decodeAndBlitFrameRGBA = function(frame_num, pixels) {\n    var frame = this.frameInfo(frame_num);\n    var num_pixels = frame.width * frame.height;\n    var index_stream = new Uint8Array(num_pixels);  // At most 8-bit indices.\n    GifReaderLZWOutputIndexStream(\n        buf, frame.data_offset, index_stream, num_pixels);\n    var palette_offset = frame.palette_offset;\n\n    // NOTE(deanm): It seems to be much faster to compare index to 256 than\n    // to === null.  Not sure why, but CompareStub_EQ_STRICT shows up high in\n    // the profile, not sure if it\'s related to using a Uint8Array.\n    var trans = frame.transparent_index;\n    if (trans === null) trans = 256;\n\n    // We are possibly just blitting to a portion of the entire frame.\n    // That is a subrect within the framerect, so the additional pixels\n    // must be skipped over after we finished a scanline.\n    var framewidth  = frame.width;\n    var framestride = width - framewidth;\n    var xleft       = framewidth;  // Number of subrect pixels left in scanline.\n\n    // Output indicies of the top left and bottom right corners of the subrect.\n    var opbeg = ((frame.y * width) + frame.x) * 4;\n    var opend = ((frame.y + frame.height) * width + frame.x) * 4;\n    var op    = opbeg;\n\n    var scanstride = framestride * 4;\n\n    // Use scanstride to skip past the rows when interlacing.  This is skipping\n    // 7 rows for the first two passes, then 3 then 1.\n    if (frame.interlaced === true) {\n      scanstride += width * 4 * 7;  // Pass 1.\n    }\n\n    var interlaceskip = 8;  // Tracking the row interval in the current pass.\n\n    for (var i = 0, il = index_stream.length; i < il; ++i) {\n      var index = index_stream[i];\n\n      if (xleft === 0) {  // Beginning of new scan line\n        op += scanstride;\n        xleft = framewidth;\n        if (op >= opend) { // Catch the wrap to switch passes when interlacing.\n          scanstride = framestride * 4 + width * 4 * (interlaceskip-1);\n          // interlaceskip / 2 * 4 is interlaceskip << 1.\n          op = opbeg + (framewidth + framestride) * (interlaceskip << 1);\n          interlaceskip >>= 1;\n        }\n      }\n\n      if (index === trans) {\n        op += 4;\n      } else {\n        var r = buf[palette_offset + index * 3];\n        var g = buf[palette_offset + index * 3 + 1];\n        var b = buf[palette_offset + index * 3 + 2];\n        pixels[op++] = r;\n        pixels[op++] = g;\n        pixels[op++] = b;\n        pixels[op++] = 255;\n      }\n      --xleft;\n    }\n  };\n}\n\nfunction GifReaderLZWOutputIndexStream(code_stream, p, output, output_length) {\n  var min_code_size = code_stream[p++];\n\n  var clear_code = 1 << min_code_size;\n  var eoi_code = clear_code + 1;\n  var next_code = eoi_code + 1;\n\n  var cur_code_size = min_code_size + 1;  // Number of bits per code.\n  // NOTE: This shares the same name as the encoder, but has a different\n  // meaning here.  Here this masks each code coming from the code stream.\n  var code_mask = (1 << cur_code_size) - 1;\n  var cur_shift = 0;\n  var cur = 0;\n\n  var op = 0;  // Output pointer.\n\n  var subblock_size = code_stream[p++];\n\n  // TODO(deanm): Would using a TypedArray be any faster?  At least it would\n  // solve the fast mode / backing store uncertainty.\n  // var code_table = Array(4096);\n  var code_table = new Int32Array(4096);  // Can be signed, we only use 20 bits.\n\n  var prev_code = null;  // Track code-1.\n\n  while (true) {\n    // Read up to two bytes, making sure we always 12-bits for max sized code.\n    while (cur_shift < 16) {\n      if (subblock_size === 0) break;  // No more data to be read.\n\n      cur |= code_stream[p++] << cur_shift;\n      cur_shift += 8;\n\n      if (subblock_size === 1) {  // Never let it get to 0 to hold logic above.\n        subblock_size = code_stream[p++];  // Next subblock.\n      } else {\n        --subblock_size;\n      }\n    }\n\n    // TODO(deanm): We should never really get here, we should have received\n    // and EOI.\n    if (cur_shift < cur_code_size)\n      break;\n\n    var code = cur & code_mask;\n    cur >>= cur_code_size;\n    cur_shift -= cur_code_size;\n\n    // TODO(deanm): Maybe should check that the first code was a clear code,\n    // at least this is what you\'re supposed to do.  But actually our encoder\n    // now doesn\'t emit a clear code first anyway.\n    if (code === clear_code) {\n      // We don\'t actually have to clear the table.  This could be a good idea\n      // for greater error checking, but we don\'t really do any anyway.  We\n      // will just track it with next_code and overwrite old entries.\n\n      next_code = eoi_code + 1;\n      cur_code_size = min_code_size + 1;\n      code_mask = (1 << cur_code_size) - 1;\n\n      // Don\'t update prev_code ?\n      prev_code = null;\n      continue;\n    } else if (code === eoi_code) {\n      break;\n    }\n\n    // We have a similar situation as the decoder, where we want to store\n    // variable length entries (code table entries), but we want to do in a\n    // faster manner than an array of arrays.  The code below stores sort of a\n    // linked list within the code table, and then "chases" through it to\n    // construct the dictionary entries.  When a new entry is created, just the\n    // last byte is stored, and the rest (prefix) of the entry is only\n    // referenced by its table entry.  Then the code chases through the\n    // prefixes until it reaches a single byte code.  We have to chase twice,\n    // first to compute the length, and then to actually copy the data to the\n    // output (backwards, since we know the length).  The alternative would be\n    // storing something in an intermediate stack, but that doesn\'t make any\n    // more sense.  I implemented an approach where it also stored the length\n    // in the code table, although it\'s a bit tricky because you run out of\n    // bits (12 + 12 + 8), but I didn\'t measure much improvements (the table\n    // entries are generally not the long).  Even when I created benchmarks for\n    // very long table entries the complexity did not seem worth it.\n    // The code table stores the prefix entry in 12 bits and then the suffix\n    // byte in 8 bits, so each entry is 20 bits.\n\n    var chase_code = code < next_code ? code : prev_code;\n\n    // Chase what we will output, either {CODE} or {CODE-1}.\n    var chase_length = 0;\n    var chase = chase_code;\n    while (chase > clear_code) {\n      chase = code_table[chase] >> 8;\n      ++chase_length;\n    }\n\n    var k = chase;\n\n    var op_end = op + chase_length + (chase_code !== code ? 1 : 0);\n    if (op_end > output_length) {\n      console.log("Warning, gif stream longer than expected.");\n      return;\n    }\n\n    // Already have the first byte from the chase, might as well write it fast.\n    output[op++] = k;\n\n    op += chase_length;\n    var b = op;  // Track pointer, writing backwards.\n\n    if (chase_code !== code)  // The case of emitting {CODE-1} + k.\n      output[op++] = k;\n\n    chase = chase_code;\n    while (chase_length--) {\n      chase = code_table[chase];\n      output[--b] = chase & 0xff;  // Write backwards.\n      chase >>= 8;  // Pull down to the prefix code.\n    }\n\n    if (prev_code !== null && next_code < 4096) {\n      code_table[next_code++] = prev_code << 8 | k;\n      // TODO(deanm): Figure out this clearing vs code growth logic better.  I\n      // have an feeling that it should just happen somewhere else, for now it\n      // is awkward between when we grow past the max and then hit a clear code.\n      // For now just check if we hit the max 12-bits (then a clear code should\n      // follow, also of course encoded in 12-bits).\n      if (next_code >= code_mask+1 && cur_code_size < 12) {\n        ++cur_code_size;\n        code_mask = code_mask << 1 | 1;\n      }\n    }\n\n    prev_code = code;\n  }\n\n  if (op !== output_length) {\n    console.log("Warning, gif stream shorter than expected.");\n  }\n\n  return output;\n}\n\n// CommonJS.\ntry { exports.GifWriter = GifWriter; exports.GifReader = GifReader } catch(e) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbWFnZUNvbnZlcnNpb24vLi9ub2RlX21vZHVsZXMvb21nZ2lmL29tZ2dpZi5qcz84ZjQ0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViO0FBQ0E7O0FBRUEscUNBQXFDLEVBQUU7QUFDdkM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsaUJBQWlCLGlCQUFpQjtBQUNwRCxrQkFBa0IsaUJBQWlCLGlCQUFpQjs7QUFFcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLHdCQUF3QjtBQUN4QixlQUFlOztBQUVmO0FBQ0E7QUFDQSwrQ0FBK0MsUUFBUTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQSxvQkFBb0IsaUJBQWlCLGlCQUFpQjtBQUN0RCxvQkFBb0IsaUJBQWlCLGlCQUFpQjtBQUN0RCxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0Esb0JBQW9CO0FBQ3BCLGlDQUFpQztBQUNqQyxvQkFBb0I7QUFDcEI7OztBQUdBOztBQUVBO0FBQ0EseUJBQXlCLEtBQUssZUFBZSxFQUFFOztBQUUvQyxpQ0FBaUMsRUFBRTs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7O0FB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QUVBO0FBQ0EsZUFBZTs7QUFFZix1REFBdUQsT0FBTztBQUM5RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMsa0JBQWtCO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSywrQkFBK0IsZ0NBQWdDIiwiZmlsZSI6IjAuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyAoYykgRGVhbiBNY05hbWVlIDxkZWFuQGdtYWlsLmNvbT4sIDIwMTMuXG4vL1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL2RlYW5tL29tZ2dpZlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvXG4vLyBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZVxuLy8gcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yXG4vLyBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXG4vLyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTXG4vLyBJTiBUSEUgU09GVFdBUkUuXG4vL1xuLy8gb21nZ2lmIGlzIGEgSmF2YVNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiBhIEdJRiA4OWEgZW5jb2RlciBhbmQgZGVjb2Rlcixcbi8vIGluY2x1ZGluZyBhbmltYXRpb24gYW5kIGNvbXByZXNzaW9uLiAgSXQgZG9lcyBub3QgcmVseSBvbiBhbnkgc3BlY2lmaWNcbi8vIHVuZGVybHlpbmcgc3lzdGVtLCBzbyBzaG91bGQgcnVuIGluIHRoZSBicm93c2VyLCBOb2RlLCBvciBQbGFzay5cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIEdpZldyaXRlcihidWYsIHdpZHRoLCBoZWlnaHQsIGdvcHRzKSB7XG4gIHZhciBwID0gMDtcblxuICB2YXIgZ29wdHMgPSBnb3B0cyA9PT0gdW5kZWZpbmVkID8geyB9IDogZ29wdHM7XG4gIHZhciBsb29wX2NvdW50ID0gZ29wdHMubG9vcCA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGdvcHRzLmxvb3A7XG4gIHZhciBnbG9iYWxfcGFsZXR0ZSA9IGdvcHRzLnBhbGV0dGUgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBnb3B0cy5wYWxldHRlO1xuXG4gIGlmICh3aWR0aCA8PSAwIHx8IGhlaWdodCA8PSAwIHx8IHdpZHRoID4gNjU1MzUgfHwgaGVpZ2h0ID4gNjU1MzUpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiV2lkdGgvSGVpZ2h0IGludmFsaWQuXCIpO1xuXG4gIGZ1bmN0aW9uIGNoZWNrX3BhbGV0dGVfYW5kX251bV9jb2xvcnMocGFsZXR0ZSkge1xuICAgIHZhciBudW1fY29sb3JzID0gcGFsZXR0ZS5sZW5ndGg7XG4gICAgaWYgKG51bV9jb2xvcnMgPCAyIHx8IG51bV9jb2xvcnMgPiAyNTYgfHwgIG51bV9jb2xvcnMgJiAobnVtX2NvbG9ycy0xKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIFwiSW52YWxpZCBjb2RlL2NvbG9yIGxlbmd0aCwgbXVzdCBiZSBwb3dlciBvZiAyIGFuZCAyIC4uIDI1Ni5cIik7XG4gICAgfVxuICAgIHJldHVybiBudW1fY29sb3JzO1xuICB9XG5cbiAgLy8gLSBIZWFkZXIuXG4gIGJ1ZltwKytdID0gMHg0NzsgYnVmW3ArK10gPSAweDQ5OyBidWZbcCsrXSA9IDB4NDY7ICAvLyBHSUZcbiAgYnVmW3ArK10gPSAweDM4OyBidWZbcCsrXSA9IDB4Mzk7IGJ1ZltwKytdID0gMHg2MTsgIC8vIDg5YVxuXG4gIC8vIEhhbmRsaW5nIG9mIEdsb2JhbCBDb2xvciBUYWJsZSAocGFsZXR0ZSkgYW5kIGJhY2tncm91bmQgaW5kZXguXG4gIHZhciBncF9udW1fY29sb3JzX3BvdzIgPSAwO1xuICB2YXIgYmFja2dyb3VuZCA9IDA7XG4gIGlmIChnbG9iYWxfcGFsZXR0ZSAhPT0gbnVsbCkge1xuICAgIHZhciBncF9udW1fY29sb3JzID0gY2hlY2tfcGFsZXR0ZV9hbmRfbnVtX2NvbG9ycyhnbG9iYWxfcGFsZXR0ZSk7XG4gICAgd2hpbGUgKGdwX251bV9jb2xvcnMgPj49IDEpICsrZ3BfbnVtX2NvbG9yc19wb3cyO1xuICAgIGdwX251bV9jb2xvcnMgPSAxIDw8IGdwX251bV9jb2xvcnNfcG93MjtcbiAgICAtLWdwX251bV9jb2xvcnNfcG93MjtcbiAgICBpZiAoZ29wdHMuYmFja2dyb3VuZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBiYWNrZ3JvdW5kID0gZ29wdHMuYmFja2dyb3VuZDtcbiAgICAgIGlmIChiYWNrZ3JvdW5kID49IGdwX251bV9jb2xvcnMpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJhY2tncm91bmQgaW5kZXggb3V0IG9mIHJhbmdlLlwiKTtcbiAgICAgIC8vIFRoZSBHSUYgc3BlYyBzdGF0ZXMgdGhhdCBhIGJhY2tncm91bmQgaW5kZXggb2YgMCBzaG91bGQgYmUgaWdub3JlZCwgc29cbiAgICAgIC8vIHRoaXMgaXMgcHJvYmFibHkgYSBtaXN0YWtlIGFuZCB5b3UgcmVhbGx5IHdhbnQgdG8gc2V0IGl0IHRvIGFub3RoZXJcbiAgICAgIC8vIHNsb3QgaW4gdGhlIHBhbGV0dGUuICBCdXQgYWN0dWFsbHkgaW4gdGhlIGVuZCBtb3N0IGJyb3dzZXJzLCBldGMgZW5kXG4gICAgICAvLyB1cCBpZ25vcmluZyB0aGlzIGFsbW9zdCBjb21wbGV0ZWx5IChpbmNsdWRpbmcgZm9yIGRpc3Bvc2UgYmFja2dyb3VuZCkuXG4gICAgICBpZiAoYmFja2dyb3VuZCA9PT0gMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQmFja2dyb3VuZCBpbmRleCBleHBsaWNpdGx5IHBhc3NlZCBhcyAwLlwiKTtcbiAgICB9XG4gIH1cblxuICAvLyAtIExvZ2ljYWwgU2NyZWVuIERlc2NyaXB0b3IuXG4gIC8vIE5PVEUoZGVhbm0pOiB3L2ggYXBwYXJlbnRseSBpZ25vcmVkIGJ5IGltcGxlbWVudGF0aW9ucywgYnV0IHNldCBhbnl3YXkuXG4gIGJ1ZltwKytdID0gd2lkdGggJiAweGZmOyBidWZbcCsrXSA9IHdpZHRoID4+IDggJiAweGZmO1xuICBidWZbcCsrXSA9IGhlaWdodCAmIDB4ZmY7IGJ1ZltwKytdID0gaGVpZ2h0ID4+IDggJiAweGZmO1xuICAvLyBOT1RFOiBJbmRpY2F0ZXMgMC1icHAgb3JpZ2luYWwgY29sb3IgcmVzb2x1dGlvbiAodW51c2VkPykuXG4gIGJ1ZltwKytdID0gKGdsb2JhbF9wYWxldHRlICE9PSBudWxsID8gMHg4MCA6IDApIHwgIC8vIEdsb2JhbCBDb2xvciBUYWJsZSBGbGFnLlxuICAgICAgICAgICAgIGdwX251bV9jb2xvcnNfcG93MjsgIC8vIE5PVEU6IE5vIHNvcnQgZmxhZyAodW51c2VkPykuXG4gIGJ1ZltwKytdID0gYmFja2dyb3VuZDsgIC8vIEJhY2tncm91bmQgQ29sb3IgSW5kZXguXG4gIGJ1ZltwKytdID0gMDsgIC8vIFBpeGVsIGFzcGVjdCByYXRpbyAodW51c2VkPykuXG5cbiAgLy8gLSBHbG9iYWwgQ29sb3IgVGFibGVcbiAgaWYgKGdsb2JhbF9wYWxldHRlICE9PSBudWxsKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGlsID0gZ2xvYmFsX3BhbGV0dGUubGVuZ3RoOyBpIDwgaWw7ICsraSkge1xuICAgICAgdmFyIHJnYiA9IGdsb2JhbF9wYWxldHRlW2ldO1xuICAgICAgYnVmW3ArK10gPSByZ2IgPj4gMTYgJiAweGZmO1xuICAgICAgYnVmW3ArK10gPSByZ2IgPj4gOCAmIDB4ZmY7XG4gICAgICBidWZbcCsrXSA9IHJnYiAmIDB4ZmY7XG4gICAgfVxuICB9XG5cbiAgaWYgKGxvb3BfY291bnQgIT09IG51bGwpIHsgIC8vIE5ldHNjYXBlIGJsb2NrIGZvciBsb29waW5nLlxuICAgIGlmIChsb29wX2NvdW50IDwgMCB8fCBsb29wX2NvdW50ID4gNjU1MzUpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJMb29wIGNvdW50IGludmFsaWQuXCIpXG4gICAgLy8gRXh0ZW5zaW9uIGNvZGUsIGxhYmVsLCBhbmQgbGVuZ3RoLlxuICAgIGJ1ZltwKytdID0gMHgyMTsgYnVmW3ArK10gPSAweGZmOyBidWZbcCsrXSA9IDB4MGI7XG4gICAgLy8gTkVUU0NBUEUyLjBcbiAgICBidWZbcCsrXSA9IDB4NGU7IGJ1ZltwKytdID0gMHg0NTsgYnVmW3ArK10gPSAweDU0OyBidWZbcCsrXSA9IDB4NTM7XG4gICAgYnVmW3ArK10gPSAweDQzOyBidWZbcCsrXSA9IDB4NDE7IGJ1ZltwKytdID0gMHg1MDsgYnVmW3ArK10gPSAweDQ1O1xuICAgIGJ1ZltwKytdID0gMHgzMjsgYnVmW3ArK10gPSAweDJlOyBidWZbcCsrXSA9IDB4MzA7XG4gICAgLy8gU3ViLWJsb2NrXG4gICAgYnVmW3ArK10gPSAweDAzOyBidWZbcCsrXSA9IDB4MDE7XG4gICAgYnVmW3ArK10gPSBsb29wX2NvdW50ICYgMHhmZjsgYnVmW3ArK10gPSBsb29wX2NvdW50ID4+IDggJiAweGZmO1xuICAgIGJ1ZltwKytdID0gMHgwMDsgIC8vIFRlcm1pbmF0b3IuXG4gIH1cblxuXG4gIHZhciBlbmRlZCA9IGZhbHNlO1xuXG4gIHRoaXMuYWRkRnJhbWUgPSBmdW5jdGlvbih4LCB5LCB3LCBoLCBpbmRleGVkX3BpeGVscywgb3B0cykge1xuICAgIGlmIChlbmRlZCA9PT0gdHJ1ZSkgeyAtLXA7IGVuZGVkID0gZmFsc2U7IH0gIC8vIFVuLWVuZC5cblxuICAgIG9wdHMgPSBvcHRzID09PSB1bmRlZmluZWQgPyB7IH0gOiBvcHRzO1xuXG4gICAgLy8gVE9ETyhkZWFubSk6IEJvdW5kcyBjaGVjayB4LCB5LiAgRG8gdGhleSBuZWVkIHRvIGJlIHdpdGhpbiB0aGUgdmlydHVhbFxuICAgIC8vIGNhbnZhcyB3aWR0aC9oZWlnaHQsIEkgaW1hZ2luZT9cbiAgICBpZiAoeCA8IDAgfHwgeSA8IDAgfHwgeCA+IDY1NTM1IHx8IHkgPiA2NTUzNSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIngveSBpbnZhbGlkLlwiKVxuXG4gICAgaWYgKHcgPD0gMCB8fCBoIDw9IDAgfHwgdyA+IDY1NTM1IHx8IGggPiA2NTUzNSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIldpZHRoL0hlaWdodCBpbnZhbGlkLlwiKVxuXG4gICAgaWYgKGluZGV4ZWRfcGl4ZWxzLmxlbmd0aCA8IHcgKiBoKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGVub3VnaCBwaXhlbHMgZm9yIHRoZSBmcmFtZSBzaXplLlwiKTtcblxuICAgIHZhciB1c2luZ19sb2NhbF9wYWxldHRlID0gdHJ1ZTtcbiAgICB2YXIgcGFsZXR0ZSA9IG9wdHMucGFsZXR0ZTtcbiAgICBpZiAocGFsZXR0ZSA9PT0gdW5kZWZpbmVkIHx8IHBhbGV0dGUgPT09IG51bGwpIHtcbiAgICAgIHVzaW5nX2xvY2FsX3BhbGV0dGUgPSBmYWxzZTtcbiAgICAgIHBhbGV0dGUgPSBnbG9iYWxfcGFsZXR0ZTtcbiAgICB9XG5cbiAgICBpZiAocGFsZXR0ZSA9PT0gdW5kZWZpbmVkIHx8IHBhbGV0dGUgPT09IG51bGwpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHN1cHBseSBlaXRoZXIgYSBsb2NhbCBvciBnbG9iYWwgcGFsZXR0ZS5cIik7XG5cbiAgICB2YXIgbnVtX2NvbG9ycyA9IGNoZWNrX3BhbGV0dGVfYW5kX251bV9jb2xvcnMocGFsZXR0ZSk7XG5cbiAgICAvLyBDb21wdXRlIHRoZSBtaW5fY29kZV9zaXplIChwb3dlciBvZiAyKSwgZGVzdHJveWluZyBudW1fY29sb3JzLlxuICAgIHZhciBtaW5fY29kZV9zaXplID0gMDtcbiAgICB3aGlsZSAobnVtX2NvbG9ycyA+Pj0gMSkgKyttaW5fY29kZV9zaXplO1xuICAgIG51bV9jb2xvcnMgPSAxIDw8IG1pbl9jb2RlX3NpemU7ICAvLyBOb3cgd2UgY2FuIGVhc2lseSBnZXQgaXQgYmFjay5cblxuICAgIHZhciBkZWxheSA9IG9wdHMuZGVsYXkgPT09IHVuZGVmaW5lZCA/IDAgOiBvcHRzLmRlbGF5O1xuXG4gICAgLy8gRnJvbSB0aGUgc3BlYzpcbiAgICAvLyAgICAgMCAtICAgTm8gZGlzcG9zYWwgc3BlY2lmaWVkLiBUaGUgZGVjb2RlciBpc1xuICAgIC8vICAgICAgICAgICBub3QgcmVxdWlyZWQgdG8gdGFrZSBhbnkgYWN0aW9uLlxuICAgIC8vICAgICAxIC0gICBEbyBub3QgZGlzcG9zZS4gVGhlIGdyYXBoaWMgaXMgdG8gYmUgbGVmdFxuICAgIC8vICAgICAgICAgICBpbiBwbGFjZS5cbiAgICAvLyAgICAgMiAtICAgUmVzdG9yZSB0byBiYWNrZ3JvdW5kIGNvbG9yLiBUaGUgYXJlYSB1c2VkIGJ5IHRoZVxuICAgIC8vICAgICAgICAgICBncmFwaGljIG11c3QgYmUgcmVzdG9yZWQgdG8gdGhlIGJhY2tncm91bmQgY29sb3IuXG4gICAgLy8gICAgIDMgLSAgIFJlc3RvcmUgdG8gcHJldmlvdXMuIFRoZSBkZWNvZGVyIGlzIHJlcXVpcmVkIHRvXG4gICAgLy8gICAgICAgICAgIHJlc3RvcmUgdGhlIGFyZWEgb3ZlcndyaXR0ZW4gYnkgdGhlIGdyYXBoaWMgd2l0aFxuICAgIC8vICAgICAgICAgICB3aGF0IHdhcyB0aGVyZSBwcmlvciB0byByZW5kZXJpbmcgdGhlIGdyYXBoaWMuXG4gICAgLy8gIDQtNyAtICAgIFRvIGJlIGRlZmluZWQuXG4gICAgLy8gTk9URShkZWFubSk6IERpc3Bvc2UgYmFja2dyb3VuZCBkb2Vzbid0IHJlYWxseSB3b3JrLCBhcHBhcmVudGx5IG1vc3RcbiAgICAvLyBicm93c2VycyBpZ25vcmUgdGhlIGJhY2tncm91bmQgcGFsZXR0ZSBpbmRleCBhbmQgY2xlYXIgdG8gdHJhbnNwYXJlbmN5LlxuICAgIHZhciBkaXNwb3NhbCA9IG9wdHMuZGlzcG9zYWwgPT09IHVuZGVmaW5lZCA/IDAgOiBvcHRzLmRpc3Bvc2FsO1xuICAgIGlmIChkaXNwb3NhbCA8IDAgfHwgZGlzcG9zYWwgPiAzKSAgLy8gNC03IGlzIHJlc2VydmVkLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGlzcG9zYWwgb3V0IG9mIHJhbmdlLlwiKTtcblxuICAgIHZhciB1c2VfdHJhbnNwYXJlbmN5ID0gZmFsc2U7XG4gICAgdmFyIHRyYW5zcGFyZW50X2luZGV4ID0gMDtcbiAgICBpZiAob3B0cy50cmFuc3BhcmVudCAhPT0gdW5kZWZpbmVkICYmIG9wdHMudHJhbnNwYXJlbnQgIT09IG51bGwpIHtcbiAgICAgIHVzZV90cmFuc3BhcmVuY3kgPSB0cnVlO1xuICAgICAgdHJhbnNwYXJlbnRfaW5kZXggPSBvcHRzLnRyYW5zcGFyZW50O1xuICAgICAgaWYgKHRyYW5zcGFyZW50X2luZGV4IDwgMCB8fCB0cmFuc3BhcmVudF9pbmRleCA+PSBudW1fY29sb3JzKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUcmFuc3BhcmVudCBjb2xvciBpbmRleC5cIik7XG4gICAgfVxuXG4gICAgaWYgKGRpc3Bvc2FsICE9PSAwIHx8IHVzZV90cmFuc3BhcmVuY3kgfHwgZGVsYXkgIT09IDApIHtcbiAgICAgIC8vIC0gR3JhcGhpY3MgQ29udHJvbCBFeHRlbnNpb25cbiAgICAgIGJ1ZltwKytdID0gMHgyMTsgYnVmW3ArK10gPSAweGY5OyAgLy8gRXh0ZW5zaW9uIC8gTGFiZWwuXG4gICAgICBidWZbcCsrXSA9IDQ7ICAvLyBCeXRlIHNpemUuXG5cbiAgICAgIGJ1ZltwKytdID0gZGlzcG9zYWwgPDwgMiB8ICh1c2VfdHJhbnNwYXJlbmN5ID09PSB0cnVlID8gMSA6IDApO1xuICAgICAgYnVmW3ArK10gPSBkZWxheSAmIDB4ZmY7IGJ1ZltwKytdID0gZGVsYXkgPj4gOCAmIDB4ZmY7XG4gICAgICBidWZbcCsrXSA9IHRyYW5zcGFyZW50X2luZGV4OyAgLy8gVHJhbnNwYXJlbnQgY29sb3IgaW5kZXguXG4gICAgICBidWZbcCsrXSA9IDA7ICAvLyBCbG9jayBUZXJtaW5hdG9yLlxuICAgIH1cblxuICAgIC8vIC0gSW1hZ2UgRGVzY3JpcHRvclxuICAgIGJ1ZltwKytdID0gMHgyYzsgIC8vIEltYWdlIFNlcGVyYXRvci5cbiAgICBidWZbcCsrXSA9IHggJiAweGZmOyBidWZbcCsrXSA9IHggPj4gOCAmIDB4ZmY7ICAvLyBMZWZ0LlxuICAgIGJ1ZltwKytdID0geSAmIDB4ZmY7IGJ1ZltwKytdID0geSA+PiA4ICYgMHhmZjsgIC8vIFRvcC5cbiAgICBidWZbcCsrXSA9IHcgJiAweGZmOyBidWZbcCsrXSA9IHcgPj4gOCAmIDB4ZmY7XG4gICAgYnVmW3ArK10gPSBoICYgMHhmZjsgYnVmW3ArK10gPSBoID4+IDggJiAweGZmO1xuICAgIC8vIE5PVEU6IE5vIHNvcnQgZmxhZyAodW51c2VkPykuXG4gICAgLy8gVE9ETyhkZWFubSk6IFN1cHBvcnQgaW50ZXJsYWNlLlxuICAgIGJ1ZltwKytdID0gdXNpbmdfbG9jYWxfcGFsZXR0ZSA9PT0gdHJ1ZSA/ICgweDgwIHwgKG1pbl9jb2RlX3NpemUtMSkpIDogMDtcblxuICAgIC8vIC0gTG9jYWwgQ29sb3IgVGFibGVcbiAgICBpZiAodXNpbmdfbG9jYWxfcGFsZXR0ZSA9PT0gdHJ1ZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGlsID0gcGFsZXR0ZS5sZW5ndGg7IGkgPCBpbDsgKytpKSB7XG4gICAgICAgIHZhciByZ2IgPSBwYWxldHRlW2ldO1xuICAgICAgICBidWZbcCsrXSA9IHJnYiA+PiAxNiAmIDB4ZmY7XG4gICAgICAgIGJ1ZltwKytdID0gcmdiID4+IDggJiAweGZmO1xuICAgICAgICBidWZbcCsrXSA9IHJnYiAmIDB4ZmY7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcCA9IEdpZldyaXRlck91dHB1dExaV0NvZGVTdHJlYW0oXG4gICAgICAgICAgICBidWYsIHAsIG1pbl9jb2RlX3NpemUgPCAyID8gMiA6IG1pbl9jb2RlX3NpemUsIGluZGV4ZWRfcGl4ZWxzKTtcblxuICAgIHJldHVybiBwO1xuICB9O1xuXG4gIHRoaXMuZW5kID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKGVuZGVkID09PSBmYWxzZSkge1xuICAgICAgYnVmW3ArK10gPSAweDNiOyAgLy8gVHJhaWxlci5cbiAgICAgIGVuZGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHA7XG4gIH07XG5cbiAgdGhpcy5nZXRPdXRwdXRCdWZmZXIgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGJ1ZjsgfTtcbiAgdGhpcy5zZXRPdXRwdXRCdWZmZXIgPSBmdW5jdGlvbih2KSB7IGJ1ZiA9IHY7IH07XG4gIHRoaXMuZ2V0T3V0cHV0QnVmZmVyUG9zaXRpb24gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHA7IH07XG4gIHRoaXMuc2V0T3V0cHV0QnVmZmVyUG9zaXRpb24gPSBmdW5jdGlvbih2KSB7IHAgPSB2OyB9O1xufVxuXG4vLyBNYWluIGNvbXByZXNzaW9uIHJvdXRpbmUsIHBhbGV0dGUgaW5kZXhlcyAtPiBMWlcgY29kZSBzdHJlYW0uXG4vLyB8aW5kZXhfc3RyZWFtfCBtdXN0IGhhdmUgYXQgbGVhc3Qgb25lIGVudHJ5LlxuZnVuY3Rpb24gR2lmV3JpdGVyT3V0cHV0TFpXQ29kZVN0cmVhbShidWYsIHAsIG1pbl9jb2RlX3NpemUsIGluZGV4X3N0cmVhbSkge1xuICBidWZbcCsrXSA9IG1pbl9jb2RlX3NpemU7XG4gIHZhciBjdXJfc3ViYmxvY2sgPSBwKys7ICAvLyBQb2ludGluZyBhdCB0aGUgbGVuZ3RoIGZpZWxkLlxuXG4gIHZhciBjbGVhcl9jb2RlID0gMSA8PCBtaW5fY29kZV9zaXplO1xuICB2YXIgY29kZV9tYXNrID0gY2xlYXJfY29kZSAtIDE7XG4gIHZhciBlb2lfY29kZSA9IGNsZWFyX2NvZGUgKyAxO1xuICB2YXIgbmV4dF9jb2RlID0gZW9pX2NvZGUgKyAxO1xuXG4gIHZhciBjdXJfY29kZV9zaXplID0gbWluX2NvZGVfc2l6ZSArIDE7ICAvLyBOdW1iZXIgb2YgYml0cyBwZXIgY29kZS5cbiAgdmFyIGN1cl9zaGlmdCA9IDA7XG4gIC8vIFdlIGhhdmUgYXQgbW9zdCAxMi1iaXQgY29kZXMsIHNvIHdlIHNob3VsZCBoYXZlIHRvIGhvbGQgYSBtYXggb2YgMTlcbiAgLy8gYml0cyBoZXJlIChhbmQgdGhlbiB3ZSB3b3VsZCB3cml0ZSBvdXQpLlxuICB2YXIgY3VyID0gMDtcblxuICBmdW5jdGlvbiBlbWl0X2J5dGVzX3RvX2J1ZmZlcihiaXRfYmxvY2tfc2l6ZSkge1xuICAgIHdoaWxlIChjdXJfc2hpZnQgPj0gYml0X2Jsb2NrX3NpemUpIHtcbiAgICAgIGJ1ZltwKytdID0gY3VyICYgMHhmZjtcbiAgICAgIGN1ciA+Pj0gODsgY3VyX3NoaWZ0IC09IDg7XG4gICAgICBpZiAocCA9PT0gY3VyX3N1YmJsb2NrICsgMjU2KSB7ICAvLyBGaW5pc2hlZCBhIHN1YmJsb2NrLlxuICAgICAgICBidWZbY3VyX3N1YmJsb2NrXSA9IDI1NTtcbiAgICAgICAgY3VyX3N1YmJsb2NrID0gcCsrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGVtaXRfY29kZShjKSB7XG4gICAgY3VyIHw9IGMgPDwgY3VyX3NoaWZ0O1xuICAgIGN1cl9zaGlmdCArPSBjdXJfY29kZV9zaXplO1xuICAgIGVtaXRfYnl0ZXNfdG9fYnVmZmVyKDgpO1xuICB9XG5cbiAgLy8gSSBhbSBub3QgYW4gZXhwZXJ0IG9uIHRoZSB0b3BpYywgYW5kIEkgZG9uJ3Qgd2FudCB0byB3cml0ZSBhIHRoZXNpcy5cbiAgLy8gSG93ZXZlciwgaXQgaXMgZ29vZCB0byBvdXRsaW5lIGhlcmUgdGhlIGJhc2ljIGFsZ29yaXRobSBhbmQgdGhlIGZldyBkYXRhXG4gIC8vIHN0cnVjdHVyZXMgYW5kIG9wdGltaXphdGlvbnMgaGVyZSB0aGF0IG1ha2UgdGhpcyBpbXBsZW1lbnRhdGlvbiBmYXN0LlxuICAvLyBUaGUgYmFzaWMgaWRlYSBiZWhpbmQgTFpXIGlzIHRvIGJ1aWxkIGEgdGFibGUgb2YgcHJldmlvdXNseSBzZWVuIHJ1bnNcbiAgLy8gYWRkcmVzc2VkIGJ5IGEgc2hvcnQgaWQgKGhlcmVpbiBjYWxsZWQgb3V0cHV0IGNvZGUpLiAgQWxsIGRhdGEgaXNcbiAgLy8gcmVmZXJlbmNlZCBieSBhIGNvZGUsIHdoaWNoIHJlcHJlc2VudHMgb25lIG9yIG1vcmUgdmFsdWVzIGZyb20gdGhlXG4gIC8vIG9yaWdpbmFsIGlucHV0IHN0cmVhbS4gIEFsbCBpbnB1dCBieXRlcyBjYW4gYmUgcmVmZXJlbmNlZCBhcyB0aGUgc2FtZVxuICAvLyB2YWx1ZSBhcyBhbiBvdXRwdXQgY29kZS4gIFNvIGlmIHlvdSBkaWRuJ3Qgd2FudCBhbnkgY29tcHJlc3Npb24sIHlvdVxuICAvLyBjb3VsZCBtb3JlIG9yIGxlc3MganVzdCBvdXRwdXQgdGhlIG9yaWdpbmFsIGJ5dGVzIGFzIGNvZGVzICh0aGVyZSBhcmVcbiAgLy8gc29tZSBkZXRhaWxzIHRvIHRoaXMsIGJ1dCBpdCBpcyB0aGUgaWRlYSkuICBJbiBvcmRlciB0byBhY2hpZXZlXG4gIC8vIGNvbXByZXNzaW9uLCB2YWx1ZXMgZ3JlYXRlciB0aGVuIHRoZSBpbnB1dCByYW5nZSAoY29kZXMgY2FuIGJlIHVwIHRvXG4gIC8vIDEyLWJpdCB3aGlsZSBpbnB1dCBvbmx5IDgtYml0KSByZXByZXNlbnQgYSBzZXF1ZW5jZSBvZiBwcmV2aW91c2x5IHNlZW5cbiAgLy8gaW5wdXRzLiAgVGhlIGRlY29tcHJlc3NvciBpcyBhYmxlIHRvIGJ1aWxkIHRoZSBzYW1lIG1hcHBpbmcgd2hpbGVcbiAgLy8gZGVjb2RpbmcsIHNvIHRoZXJlIGlzIGFsd2F5cyBhIHNoYXJlZCBjb21tb24ga25vd2xlZGdlIGJldHdlZW4gdGhlXG4gIC8vIGVuY29kaW5nIGFuZCBkZWNvZGVyLCB3aGljaCBpcyBhbHNvIGltcG9ydGFudCBmb3IgXCJ0aW1pbmdcIiBhc3BlY3RzIGxpa2VcbiAgLy8gaG93IHRvIGhhbmRsZSB2YXJpYWJsZSBiaXQgd2lkdGggY29kZSBlbmNvZGluZy5cbiAgLy9cbiAgLy8gT25lIG9idmlvdXMgYnV0IHZlcnkgaW1wb3J0YW50IGNvbnNlcXVlbmNlIG9mIHRoZSB0YWJsZSBzeXN0ZW0gaXMgdGhlcmVcbiAgLy8gaXMgYWx3YXlzIGEgdW5pcXVlIGlkIChhdCBtb3N0IDEyLWJpdHMpIHRvIG1hcCB0aGUgcnVucy4gICdBJyBtaWdodCBiZVxuICAvLyA0LCB0aGVuICdBQScgbWlnaHQgYmUgMTAsICdBQUEnIDExLCAnQUFBQScgMTIsIGV0Yy4gIFRoaXMgcmVsYXRpb25zaGlwXG4gIC8vIGNhbiBiZSB1c2VkIGZvciBhbiBlZmZlY2llbnQgbG9va3VwIHN0cmF0ZWd5IGZvciB0aGUgY29kZSBtYXBwaW5nLiAgV2VcbiAgLy8gbmVlZCB0byBrbm93IGlmIGEgcnVuIGhhcyBiZWVuIHNlZW4gYmVmb3JlLCBhbmQgYmUgYWJsZSB0byBtYXAgdGhhdCBydW5cbiAgLy8gdG8gdGhlIG91dHB1dCBjb2RlLiAgU2luY2Ugd2Ugc3RhcnQgd2l0aCBrbm93biB1bmlxdWUgaWRzIChpbnB1dCBieXRlcyksXG4gIC8vIGFuZCB0aGVuIGZyb20gdGhvc2UgYnVpbGQgbW9yZSB1bmlxdWUgaWRzICh0YWJsZSBlbnRyaWVzKSwgd2UgY2FuXG4gIC8vIGNvbnRpbnVlIHRoaXMgY2hhaW4gKGFsbW9zdCBsaWtlIGEgbGlua2VkIGxpc3QpIHRvIGFsd2F5cyBoYXZlIHNtYWxsXG4gIC8vIGludGVnZXIgdmFsdWVzIHRoYXQgcmVwcmVzZW50IHRoZSBjdXJyZW50IGJ5dGUgY2hhaW5zIGluIHRoZSBlbmNvZGVyLlxuICAvLyBUaGlzIG1lYW5zIGluc3RlYWQgb2YgdHJhY2tpbmcgdGhlIGlucHV0IGJ5dGVzIChBQUFBQkNEKSB0byBrbm93IG91clxuICAvLyBjdXJyZW50IHN0YXRlLCB3ZSBjYW4gdHJhY2sgdGhlIHRhYmxlIGVudHJ5IGZvciBBQUFBQkMgKGl0IGlzIGd1YXJhbnRlZWRcbiAgLy8gdG8gZXhpc3QgYnkgdGhlIG5hdHVyZSBvZiB0aGUgYWxnb3JpdGhtKSBhbmQgdGhlIG5leHQgY2hhcmFjdGVyIEQuXG4gIC8vIFRoZXJlZm9yIHRoZSB0dXBsZSBvZiAodGFibGVfZW50cnksIGJ5dGUpIGlzIGd1YXJhbnRlZWQgdG8gYWxzbyBiZVxuICAvLyB1bmlxdWUuICBUaGlzIGFsbG93cyB1cyB0byBjcmVhdGUgYSBzaW1wbGUgbG9va3VwIGtleSBmb3IgbWFwcGluZyBpbnB1dFxuICAvLyBzZXF1ZW5jZXMgdG8gY29kZXMgKHRhYmxlIGluZGljZXMpIHdpdGhvdXQgaGF2aW5nIHRvIHN0b3JlIG9yIHNlYXJjaFxuICAvLyBhbnkgb2YgdGhlIGNvZGUgc2VxdWVuY2VzLiAgU28gaWYgJ0FBQUEnIGhhcyBhIHRhYmxlIGVudHJ5IG9mIDEyLCB0aGVcbiAgLy8gdHVwbGUgb2YgKCdBQUFBJywgSykgZm9yIGFueSBpbnB1dCBieXRlIEsgd2lsbCBiZSB1bmlxdWUsIGFuZCBjYW4gYmUgb3VyXG4gIC8vIGtleS4gIFRoaXMgbGVhZHMgdG8gYSBpbnRlZ2VyIHZhbHVlIGF0IG1vc3QgMjAtYml0cywgd2hpY2ggY2FuIGFsd2F5c1xuICAvLyBmaXQgaW4gYW4gU01JIHZhbHVlIGFuZCBiZSB1c2VkIGFzIGEgZmFzdCBzcGFyc2UgYXJyYXkgLyBvYmplY3Qga2V5LlxuXG4gIC8vIE91dHB1dCBjb2RlIGZvciB0aGUgY3VycmVudCBjb250ZW50cyBvZiB0aGUgaW5kZXggYnVmZmVyLlxuICB2YXIgaWJfY29kZSA9IGluZGV4X3N0cmVhbVswXSAmIGNvZGVfbWFzazsgIC8vIExvYWQgZmlyc3QgaW5wdXQgaW5kZXguXG4gIHZhciBjb2RlX3RhYmxlID0geyB9OyAgLy8gS2V5J2Qgb24gb3VyIDIwLWJpdCBcInR1cGxlXCIuXG5cbiAgZW1pdF9jb2RlKGNsZWFyX2NvZGUpOyAgLy8gU3BlYyBzYXlzIGZpcnN0IGNvZGUgc2hvdWxkIGJlIGEgY2xlYXIgY29kZS5cblxuICAvLyBGaXJzdCBpbmRleCBhbHJlYWR5IGxvYWRlZCwgcHJvY2VzcyB0aGUgcmVzdCBvZiB0aGUgc3RyZWFtLlxuICBmb3IgKHZhciBpID0gMSwgaWwgPSBpbmRleF9zdHJlYW0ubGVuZ3RoOyBpIDwgaWw7ICsraSkge1xuICAgIHZhciBrID0gaW5kZXhfc3RyZWFtW2ldICYgY29kZV9tYXNrO1xuICAgIHZhciBjdXJfa2V5ID0gaWJfY29kZSA8PCA4IHwgazsgIC8vIChwcmV2LCBrKSB1bmlxdWUgdHVwbGUuXG4gICAgdmFyIGN1cl9jb2RlID0gY29kZV90YWJsZVtjdXJfa2V5XTsgIC8vIGJ1ZmZlciArIGsuXG5cbiAgICAvLyBDaGVjayBpZiB3ZSBoYXZlIHRvIGNyZWF0ZSBhIG5ldyBjb2RlIHRhYmxlIGVudHJ5LlxuICAgIGlmIChjdXJfY29kZSA9PT0gdW5kZWZpbmVkKSB7ICAvLyBXZSBkb24ndCBoYXZlIGJ1ZmZlciArIGsuXG4gICAgICAvLyBFbWl0IGluZGV4IGJ1ZmZlciAod2l0aG91dCBrKS5cbiAgICAgIC8vIFRoaXMgaXMgYW4gaW5saW5lIHZlcnNpb24gb2YgZW1pdF9jb2RlLCBiZWNhdXNlIHRoaXMgaXMgdGhlIGNvcmVcbiAgICAgIC8vIHdyaXRpbmcgcm91dGluZSBvZiB0aGUgY29tcHJlc3NvciAoYW5kIFY4IGNhbm5vdCBpbmxpbmUgZW1pdF9jb2RlXG4gICAgICAvLyBiZWNhdXNlIGl0IGlzIGEgY2xvc3VyZSBoZXJlIGluIGEgZGlmZmVyZW50IGNvbnRleHQpLiAgQWRkaXRpb25hbGx5XG4gICAgICAvLyB3ZSBjYW4gY2FsbCBlbWl0X2J5dGVfdG9fYnVmZmVyIGxlc3Mgb2Z0ZW4sIGJlY2F1c2Ugd2UgY2FuIGhhdmVcbiAgICAgIC8vIDMwLWJpdHMgKGZyb20gb3VyIDMxLWJpdCBzaWduZWQgU01JKSwgYW5kIHdlIGtub3cgb3VyIGNvZGVzIHdpbGwgb25seVxuICAgICAgLy8gYmUgMTItYml0cywgc28gY2FuIHNhZmVseSBoYXZlIDE4LWJpdHMgdGhlcmUgd2l0aG91dCBvdmVyZmxvdy5cbiAgICAgIC8vIGVtaXRfY29kZShpYl9jb2RlKTtcbiAgICAgIGN1ciB8PSBpYl9jb2RlIDw8IGN1cl9zaGlmdDtcbiAgICAgIGN1cl9zaGlmdCArPSBjdXJfY29kZV9zaXplO1xuICAgICAgd2hpbGUgKGN1cl9zaGlmdCA+PSA4KSB7XG4gICAgICAgIGJ1ZltwKytdID0gY3VyICYgMHhmZjtcbiAgICAgICAgY3VyID4+PSA4OyBjdXJfc2hpZnQgLT0gODtcbiAgICAgICAgaWYgKHAgPT09IGN1cl9zdWJibG9jayArIDI1NikgeyAgLy8gRmluaXNoZWQgYSBzdWJibG9jay5cbiAgICAgICAgICBidWZbY3VyX3N1YmJsb2NrXSA9IDI1NTtcbiAgICAgICAgICBjdXJfc3ViYmxvY2sgPSBwKys7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG5leHRfY29kZSA9PT0gNDA5NikgeyAgLy8gVGFibGUgZnVsbCwgbmVlZCBhIGNsZWFyLlxuICAgICAgICBlbWl0X2NvZGUoY2xlYXJfY29kZSk7XG4gICAgICAgIG5leHRfY29kZSA9IGVvaV9jb2RlICsgMTtcbiAgICAgICAgY3VyX2NvZGVfc2l6ZSA9IG1pbl9jb2RlX3NpemUgKyAxO1xuICAgICAgICBjb2RlX3RhYmxlID0geyB9O1xuICAgICAgfSBlbHNlIHsgIC8vIFRhYmxlIG5vdCBmdWxsLCBpbnNlcnQgYSBuZXcgZW50cnkuXG4gICAgICAgIC8vIEluY3JlYXNlIG91ciB2YXJpYWJsZSBiaXQgY29kZSBzaXplcyBpZiBuZWNlc3NhcnkuICBUaGlzIGlzIGEgYml0XG4gICAgICAgIC8vIHRyaWNreSBhcyBpdCBpcyBiYXNlZCBvbiBcInRpbWluZ1wiIGJldHdlZW4gdGhlIGVuY29kaW5nIGFuZFxuICAgICAgICAvLyBkZWNvZGVyLiAgRnJvbSB0aGUgZW5jb2RlcnMgcGVyc3BlY3RpdmUgdGhpcyBzaG91bGQgaGFwcGVuIGFmdGVyXG4gICAgICAgIC8vIHdlJ3ZlIGFscmVhZHkgZW1pdHRlZCB0aGUgaW5kZXggYnVmZmVyIGFuZCBhcmUgYWJvdXQgdG8gY3JlYXRlIHRoZVxuICAgICAgICAvLyBmaXJzdCB0YWJsZSBlbnRyeSB0aGF0IHdvdWxkIG92ZXJmbG93IG91ciBjdXJyZW50IGNvZGUgYml0IHNpemUuXG4gICAgICAgIGlmIChuZXh0X2NvZGUgPj0gKDEgPDwgY3VyX2NvZGVfc2l6ZSkpICsrY3VyX2NvZGVfc2l6ZTtcbiAgICAgICAgY29kZV90YWJsZVtjdXJfa2V5XSA9IG5leHRfY29kZSsrOyAgLy8gSW5zZXJ0IGludG8gY29kZSB0YWJsZS5cbiAgICAgIH1cblxuICAgICAgaWJfY29kZSA9IGs7ICAvLyBJbmRleCBidWZmZXIgdG8gc2luZ2xlIGlucHV0IGsuXG4gICAgfSBlbHNlIHtcbiAgICAgIGliX2NvZGUgPSBjdXJfY29kZTsgIC8vIEluZGV4IGJ1ZmZlciB0byBzZXF1ZW5jZSBpbiBjb2RlIHRhYmxlLlxuICAgIH1cbiAgfVxuXG4gIGVtaXRfY29kZShpYl9jb2RlKTsgIC8vIFRoZXJlIHdpbGwgc3RpbGwgYmUgc29tZXRoaW5nIGluIHRoZSBpbmRleCBidWZmZXIuXG4gIGVtaXRfY29kZShlb2lfY29kZSk7ICAvLyBFbmQgT2YgSW5mb3JtYXRpb24uXG5cbiAgLy8gRmx1c2ggLyBmaW5hbGl6ZSB0aGUgc3ViLWJsb2NrcyBzdHJlYW0gdG8gdGhlIGJ1ZmZlci5cbiAgZW1pdF9ieXRlc190b19idWZmZXIoMSk7XG5cbiAgLy8gRmluaXNoIHRoZSBzdWItYmxvY2tzLCB3cml0aW5nIG91dCBhbnkgdW5maW5pc2hlZCBsZW5ndGhzIGFuZFxuICAvLyB0ZXJtaW5hdGluZyB3aXRoIGEgc3ViLWJsb2NrIG9mIGxlbmd0aCAwLiAgSWYgd2UgaGF2ZSBhbHJlYWR5IHN0YXJ0ZWRcbiAgLy8gYnV0IG5vdCB5ZXQgdXNlZCBhIHN1Yi1ibG9jayBpdCBjYW4ganVzdCBiZWNvbWUgdGhlIHRlcm1pbmF0b3IuXG4gIGlmIChjdXJfc3ViYmxvY2sgKyAxID09PSBwKSB7ICAvLyBTdGFydGVkIGJ1dCB1bnVzZWQuXG4gICAgYnVmW2N1cl9zdWJibG9ja10gPSAwO1xuICB9IGVsc2UgeyAgLy8gU3RhcnRlZCBhbmQgdXNlZCwgd3JpdGUgbGVuZ3RoIGFuZCBhZGRpdGlvbmFsIHRlcm1pbmF0b3IgYmxvY2suXG4gICAgYnVmW2N1cl9zdWJibG9ja10gPSBwIC0gY3VyX3N1YmJsb2NrIC0gMTtcbiAgICBidWZbcCsrXSA9IDA7XG4gIH1cbiAgcmV0dXJuIHA7XG59XG5cbmZ1bmN0aW9uIEdpZlJlYWRlcihidWYpIHtcbiAgdmFyIHAgPSAwO1xuXG4gIC8vIC0gSGVhZGVyIChHSUY4N2Egb3IgR0lGODlhKS5cbiAgaWYgKGJ1ZltwKytdICE9PSAweDQ3IHx8ICAgICAgICAgICAgYnVmW3ArK10gIT09IDB4NDkgfHwgYnVmW3ArK10gIT09IDB4NDYgfHxcbiAgICAgIGJ1ZltwKytdICE9PSAweDM4IHx8IChidWZbcCsrXSsxICYgMHhmZCkgIT09IDB4MzggfHwgYnVmW3ArK10gIT09IDB4NjEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIEdJRiA4N2EvODlhIGhlYWRlci5cIik7XG4gIH1cblxuICAvLyAtIExvZ2ljYWwgU2NyZWVuIERlc2NyaXB0b3IuXG4gIHZhciB3aWR0aCA9IGJ1ZltwKytdIHwgYnVmW3ArK10gPDwgODtcbiAgdmFyIGhlaWdodCA9IGJ1ZltwKytdIHwgYnVmW3ArK10gPDwgODtcbiAgdmFyIHBmMCA9IGJ1ZltwKytdOyAgLy8gPFBhY2tlZCBGaWVsZHM+LlxuICB2YXIgZ2xvYmFsX3BhbGV0dGVfZmxhZyA9IHBmMCA+PiA3O1xuICB2YXIgbnVtX2dsb2JhbF9jb2xvcnNfcG93MiA9IHBmMCAmIDB4NztcbiAgdmFyIG51bV9nbG9iYWxfY29sb3JzID0gMSA8PCAobnVtX2dsb2JhbF9jb2xvcnNfcG93MiArIDEpO1xuICB2YXIgYmFja2dyb3VuZCA9IGJ1ZltwKytdO1xuICBidWZbcCsrXTsgIC8vIFBpeGVsIGFzcGVjdCByYXRpbyAodW51c2VkPykuXG5cbiAgdmFyIGdsb2JhbF9wYWxldHRlX29mZnNldCA9IG51bGw7XG4gIHZhciBnbG9iYWxfcGFsZXR0ZV9zaXplICAgPSBudWxsO1xuXG4gIGlmIChnbG9iYWxfcGFsZXR0ZV9mbGFnKSB7XG4gICAgZ2xvYmFsX3BhbGV0dGVfb2Zmc2V0ID0gcDtcbiAgICBnbG9iYWxfcGFsZXR0ZV9zaXplID0gbnVtX2dsb2JhbF9jb2xvcnM7XG4gICAgcCArPSBudW1fZ2xvYmFsX2NvbG9ycyAqIDM7ICAvLyBTZWVrIHBhc3QgcGFsZXR0ZS5cbiAgfVxuXG4gIHZhciBub19lb2YgPSB0cnVlO1xuXG4gIHZhciBmcmFtZXMgPSBbIF07XG5cbiAgdmFyIGRlbGF5ID0gMDtcbiAgdmFyIHRyYW5zcGFyZW50X2luZGV4ID0gbnVsbDtcbiAgdmFyIGRpc3Bvc2FsID0gMDsgIC8vIDAgLSBObyBkaXNwb3NhbCBzcGVjaWZpZWQuXG4gIHZhciBsb29wX2NvdW50ID0gbnVsbDtcblxuICB0aGlzLndpZHRoID0gd2lkdGg7XG4gIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gIHdoaWxlIChub19lb2YgJiYgcCA8IGJ1Zi5sZW5ndGgpIHtcbiAgICBzd2l0Y2ggKGJ1ZltwKytdKSB7XG4gICAgICBjYXNlIDB4MjE6ICAvLyBHcmFwaGljcyBDb250cm9sIEV4dGVuc2lvbiBCbG9ja1xuICAgICAgICBzd2l0Y2ggKGJ1ZltwKytdKSB7XG4gICAgICAgICAgY2FzZSAweGZmOiAgLy8gQXBwbGljYXRpb24gc3BlY2lmaWMgYmxvY2tcbiAgICAgICAgICAgIC8vIFRyeSBpZiBpdCdzIGEgTmV0c2NhcGUgYmxvY2sgKHdpdGggYW5pbWF0aW9uIGxvb3AgY291bnRlcikuXG4gICAgICAgICAgICBpZiAoYnVmW3AgICBdICE9PSAweDBiIHx8ICAvLyAyMSBGRiBhbHJlYWR5IHJlYWQsIGNoZWNrIGJsb2NrIHNpemUuXG4gICAgICAgICAgICAgICAgLy8gTkVUU0NBUEUyLjBcbiAgICAgICAgICAgICAgICBidWZbcCsxIF0gPT0gMHg0ZSAmJiBidWZbcCsyIF0gPT0gMHg0NSAmJiBidWZbcCszIF0gPT0gMHg1NCAmJlxuICAgICAgICAgICAgICAgIGJ1ZltwKzQgXSA9PSAweDUzICYmIGJ1ZltwKzUgXSA9PSAweDQzICYmIGJ1ZltwKzYgXSA9PSAweDQxICYmXG4gICAgICAgICAgICAgICAgYnVmW3ArNyBdID09IDB4NTAgJiYgYnVmW3ArOCBdID09IDB4NDUgJiYgYnVmW3ArOSBdID09IDB4MzIgJiZcbiAgICAgICAgICAgICAgICBidWZbcCsxMF0gPT0gMHgyZSAmJiBidWZbcCsxMV0gPT0gMHgzMCAmJlxuICAgICAgICAgICAgICAgIC8vIFN1Yi1ibG9ja1xuICAgICAgICAgICAgICAgIGJ1ZltwKzEyXSA9PSAweDAzICYmIGJ1ZltwKzEzXSA9PSAweDAxICYmIGJ1ZltwKzE2XSA9PSAwKSB7XG4gICAgICAgICAgICAgIHAgKz0gMTQ7XG4gICAgICAgICAgICAgIGxvb3BfY291bnQgPSBidWZbcCsrXSB8IGJ1ZltwKytdIDw8IDg7XG4gICAgICAgICAgICAgIHArKzsgIC8vIFNraXAgdGVybWluYXRvci5cbiAgICAgICAgICAgIH0gZWxzZSB7ICAvLyBXZSBkb24ndCBrbm93IHdoYXQgaXQgaXMsIGp1c3QgdHJ5IHRvIGdldCBwYXN0IGl0LlxuICAgICAgICAgICAgICBwICs9IDEyO1xuICAgICAgICAgICAgICB3aGlsZSAodHJ1ZSkgeyAgLy8gU2VlayB0aHJvdWdoIHN1YmJsb2Nrcy5cbiAgICAgICAgICAgICAgICB2YXIgYmxvY2tfc2l6ZSA9IGJ1ZltwKytdO1xuICAgICAgICAgICAgICAgIC8vIEJhZCBibG9jayBzaXplIChleDogdW5kZWZpbmVkIGZyb20gYW4gb3V0IG9mIGJvdW5kcyByZWFkKS5cbiAgICAgICAgICAgICAgICBpZiAoIShibG9ja19zaXplID49IDApKSB0aHJvdyBFcnJvcihcIkludmFsaWQgYmxvY2sgc2l6ZVwiKTtcbiAgICAgICAgICAgICAgICBpZiAoYmxvY2tfc2l6ZSA9PT0gMCkgYnJlYWs7ICAvLyAwIHNpemUgaXMgdGVybWluYXRvclxuICAgICAgICAgICAgICAgIHAgKz0gYmxvY2tfc2l6ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDB4Zjk6ICAvLyBHcmFwaGljcyBDb250cm9sIEV4dGVuc2lvblxuICAgICAgICAgICAgaWYgKGJ1ZltwKytdICE9PSAweDQgfHwgYnVmW3ArNF0gIT09IDApXG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZ3JhcGhpY3MgZXh0ZW5zaW9uIGJsb2NrLlwiKTtcbiAgICAgICAgICAgIHZhciBwZjEgPSBidWZbcCsrXTtcbiAgICAgICAgICAgIGRlbGF5ID0gYnVmW3ArK10gfCBidWZbcCsrXSA8PCA4O1xuICAgICAgICAgICAgdHJhbnNwYXJlbnRfaW5kZXggPSBidWZbcCsrXTtcbiAgICAgICAgICAgIGlmICgocGYxICYgMSkgPT09IDApIHRyYW5zcGFyZW50X2luZGV4ID0gbnVsbDtcbiAgICAgICAgICAgIGRpc3Bvc2FsID0gcGYxID4+IDIgJiAweDc7XG4gICAgICAgICAgICBwKys7ICAvLyBTa2lwIHRlcm1pbmF0b3IuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMHhmZTogIC8vIENvbW1lbnQgRXh0ZW5zaW9uLlxuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHsgIC8vIFNlZWsgdGhyb3VnaCBzdWJibG9ja3MuXG4gICAgICAgICAgICAgIHZhciBibG9ja19zaXplID0gYnVmW3ArK107XG4gICAgICAgICAgICAgIC8vIEJhZCBibG9jayBzaXplIChleDogdW5kZWZpbmVkIGZyb20gYW4gb3V0IG9mIGJvdW5kcyByZWFkKS5cbiAgICAgICAgICAgICAgaWYgKCEoYmxvY2tfc2l6ZSA+PSAwKSkgdGhyb3cgRXJyb3IoXCJJbnZhbGlkIGJsb2NrIHNpemVcIik7XG4gICAgICAgICAgICAgIGlmIChibG9ja19zaXplID09PSAwKSBicmVhazsgIC8vIDAgc2l6ZSBpcyB0ZXJtaW5hdG9yXG4gICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGJ1Zi5zbGljZShwLCBwK2Jsb2NrX3NpemUpLnRvU3RyaW5nKCdhc2NpaScpKTtcbiAgICAgICAgICAgICAgcCArPSBibG9ja19zaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIFwiVW5rbm93biBncmFwaGljIGNvbnRyb2wgbGFiZWw6IDB4XCIgKyBidWZbcC0xXS50b1N0cmluZygxNikpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDB4MmM6ICAvLyBJbWFnZSBEZXNjcmlwdG9yLlxuICAgICAgICB2YXIgeCA9IGJ1ZltwKytdIHwgYnVmW3ArK10gPDwgODtcbiAgICAgICAgdmFyIHkgPSBidWZbcCsrXSB8IGJ1ZltwKytdIDw8IDg7XG4gICAgICAgIHZhciB3ID0gYnVmW3ArK10gfCBidWZbcCsrXSA8PCA4O1xuICAgICAgICB2YXIgaCA9IGJ1ZltwKytdIHwgYnVmW3ArK10gPDwgODtcbiAgICAgICAgdmFyIHBmMiA9IGJ1ZltwKytdO1xuICAgICAgICB2YXIgbG9jYWxfcGFsZXR0ZV9mbGFnID0gcGYyID4+IDc7XG4gICAgICAgIHZhciBpbnRlcmxhY2VfZmxhZyA9IHBmMiA+PiA2ICYgMTtcbiAgICAgICAgdmFyIG51bV9sb2NhbF9jb2xvcnNfcG93MiA9IHBmMiAmIDB4NztcbiAgICAgICAgdmFyIG51bV9sb2NhbF9jb2xvcnMgPSAxIDw8IChudW1fbG9jYWxfY29sb3JzX3BvdzIgKyAxKTtcbiAgICAgICAgdmFyIHBhbGV0dGVfb2Zmc2V0ID0gZ2xvYmFsX3BhbGV0dGVfb2Zmc2V0O1xuICAgICAgICB2YXIgcGFsZXR0ZV9zaXplID0gZ2xvYmFsX3BhbGV0dGVfc2l6ZTtcbiAgICAgICAgdmFyIGhhc19sb2NhbF9wYWxldHRlID0gZmFsc2U7XG4gICAgICAgIGlmIChsb2NhbF9wYWxldHRlX2ZsYWcpIHtcbiAgICAgICAgICB2YXIgaGFzX2xvY2FsX3BhbGV0dGUgPSB0cnVlO1xuICAgICAgICAgIHBhbGV0dGVfb2Zmc2V0ID0gcDsgIC8vIE92ZXJyaWRlIHdpdGggbG9jYWwgcGFsZXR0ZS5cbiAgICAgICAgICBwYWxldHRlX3NpemUgPSBudW1fbG9jYWxfY29sb3JzO1xuICAgICAgICAgIHAgKz0gbnVtX2xvY2FsX2NvbG9ycyAqIDM7ICAvLyBTZWVrIHBhc3QgcGFsZXR0ZS5cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkYXRhX29mZnNldCA9IHA7XG5cbiAgICAgICAgcCsrOyAgLy8gY29kZXNpemVcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICB2YXIgYmxvY2tfc2l6ZSA9IGJ1ZltwKytdO1xuICAgICAgICAgIC8vIEJhZCBibG9jayBzaXplIChleDogdW5kZWZpbmVkIGZyb20gYW4gb3V0IG9mIGJvdW5kcyByZWFkKS5cbiAgICAgICAgICBpZiAoIShibG9ja19zaXplID49IDApKSB0aHJvdyBFcnJvcihcIkludmFsaWQgYmxvY2sgc2l6ZVwiKTtcbiAgICAgICAgICBpZiAoYmxvY2tfc2l6ZSA9PT0gMCkgYnJlYWs7ICAvLyAwIHNpemUgaXMgdGVybWluYXRvclxuICAgICAgICAgIHAgKz0gYmxvY2tfc2l6ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZyYW1lcy5wdXNoKHt4OiB4LCB5OiB5LCB3aWR0aDogdywgaGVpZ2h0OiBoLFxuICAgICAgICAgICAgICAgICAgICAgaGFzX2xvY2FsX3BhbGV0dGU6IGhhc19sb2NhbF9wYWxldHRlLFxuICAgICAgICAgICAgICAgICAgICAgcGFsZXR0ZV9vZmZzZXQ6IHBhbGV0dGVfb2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgcGFsZXR0ZV9zaXplOiBwYWxldHRlX3NpemUsXG4gICAgICAgICAgICAgICAgICAgICBkYXRhX29mZnNldDogZGF0YV9vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICBkYXRhX2xlbmd0aDogcCAtIGRhdGFfb2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgdHJhbnNwYXJlbnRfaW5kZXg6IHRyYW5zcGFyZW50X2luZGV4LFxuICAgICAgICAgICAgICAgICAgICAgaW50ZXJsYWNlZDogISFpbnRlcmxhY2VfZmxhZyxcbiAgICAgICAgICAgICAgICAgICAgIGRlbGF5OiBkZWxheSxcbiAgICAgICAgICAgICAgICAgICAgIGRpc3Bvc2FsOiBkaXNwb3NhbH0pO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAweDNiOiAgLy8gVHJhaWxlciBNYXJrZXIgKGVuZCBvZiBmaWxlKS5cbiAgICAgICAgbm9fZW9mID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGdpZiBibG9jazogMHhcIiArIGJ1ZltwLTFdLnRvU3RyaW5nKDE2KSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMubnVtRnJhbWVzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGZyYW1lcy5sZW5ndGg7XG4gIH07XG5cbiAgdGhpcy5sb29wQ291bnQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbG9vcF9jb3VudDtcbiAgfTtcblxuICB0aGlzLmZyYW1lSW5mbyA9IGZ1bmN0aW9uKGZyYW1lX251bSkge1xuICAgIGlmIChmcmFtZV9udW0gPCAwIHx8IGZyYW1lX251bSA+PSBmcmFtZXMubGVuZ3RoKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRnJhbWUgaW5kZXggb3V0IG9mIHJhbmdlLlwiKTtcbiAgICByZXR1cm4gZnJhbWVzW2ZyYW1lX251bV07XG4gIH1cblxuICB0aGlzLmRlY29kZUFuZEJsaXRGcmFtZUJHUkEgPSBmdW5jdGlvbihmcmFtZV9udW0sIHBpeGVscykge1xuICAgIHZhciBmcmFtZSA9IHRoaXMuZnJhbWVJbmZvKGZyYW1lX251bSk7XG4gICAgdmFyIG51bV9waXhlbHMgPSBmcmFtZS53aWR0aCAqIGZyYW1lLmhlaWdodDtcbiAgICB2YXIgaW5kZXhfc3RyZWFtID0gbmV3IFVpbnQ4QXJyYXkobnVtX3BpeGVscyk7ICAvLyBBdCBtb3N0IDgtYml0IGluZGljZXMuXG4gICAgR2lmUmVhZGVyTFpXT3V0cHV0SW5kZXhTdHJlYW0oXG4gICAgICAgIGJ1ZiwgZnJhbWUuZGF0YV9vZmZzZXQsIGluZGV4X3N0cmVhbSwgbnVtX3BpeGVscyk7XG4gICAgdmFyIHBhbGV0dGVfb2Zmc2V0ID0gZnJhbWUucGFsZXR0ZV9vZmZzZXQ7XG5cbiAgICAvLyBOT1RFKGRlYW5tKTogSXQgc2VlbXMgdG8gYmUgbXVjaCBmYXN0ZXIgdG8gY29tcGFyZSBpbmRleCB0byAyNTYgdGhhblxuICAgIC8vIHRvID09PSBudWxsLiAgTm90IHN1cmUgd2h5LCBidXQgQ29tcGFyZVN0dWJfRVFfU1RSSUNUIHNob3dzIHVwIGhpZ2ggaW5cbiAgICAvLyB0aGUgcHJvZmlsZSwgbm90IHN1cmUgaWYgaXQncyByZWxhdGVkIHRvIHVzaW5nIGEgVWludDhBcnJheS5cbiAgICB2YXIgdHJhbnMgPSBmcmFtZS50cmFuc3BhcmVudF9pbmRleDtcbiAgICBpZiAodHJhbnMgPT09IG51bGwpIHRyYW5zID0gMjU2O1xuXG4gICAgLy8gV2UgYXJlIHBvc3NpYmx5IGp1c3QgYmxpdHRpbmcgdG8gYSBwb3J0aW9uIG9mIHRoZSBlbnRpcmUgZnJhbWUuXG4gICAgLy8gVGhhdCBpcyBhIHN1YnJlY3Qgd2l0aGluIHRoZSBmcmFtZXJlY3QsIHNvIHRoZSBhZGRpdGlvbmFsIHBpeGVsc1xuICAgIC8vIG11c3QgYmUgc2tpcHBlZCBvdmVyIGFmdGVyIHdlIGZpbmlzaGVkIGEgc2NhbmxpbmUuXG4gICAgdmFyIGZyYW1ld2lkdGggID0gZnJhbWUud2lkdGg7XG4gICAgdmFyIGZyYW1lc3RyaWRlID0gd2lkdGggLSBmcmFtZXdpZHRoO1xuICAgIHZhciB4bGVmdCAgICAgICA9IGZyYW1ld2lkdGg7ICAvLyBOdW1iZXIgb2Ygc3VicmVjdCBwaXhlbHMgbGVmdCBpbiBzY2FubGluZS5cblxuICAgIC8vIE91dHB1dCBpbmRpY2llcyBvZiB0aGUgdG9wIGxlZnQgYW5kIGJvdHRvbSByaWdodCBjb3JuZXJzIG9mIHRoZSBzdWJyZWN0LlxuICAgIHZhciBvcGJlZyA9ICgoZnJhbWUueSAqIHdpZHRoKSArIGZyYW1lLngpICogNDtcbiAgICB2YXIgb3BlbmQgPSAoKGZyYW1lLnkgKyBmcmFtZS5oZWlnaHQpICogd2lkdGggKyBmcmFtZS54KSAqIDQ7XG4gICAgdmFyIG9wICAgID0gb3BiZWc7XG5cbiAgICB2YXIgc2NhbnN0cmlkZSA9IGZyYW1lc3RyaWRlICogNDtcblxuICAgIC8vIFVzZSBzY2Fuc3RyaWRlIHRvIHNraXAgcGFzdCB0aGUgcm93cyB3aGVuIGludGVybGFjaW5nLiAgVGhpcyBpcyBza2lwcGluZ1xuICAgIC8vIDcgcm93cyBmb3IgdGhlIGZpcnN0IHR3byBwYXNzZXMsIHRoZW4gMyB0aGVuIDEuXG4gICAgaWYgKGZyYW1lLmludGVybGFjZWQgPT09IHRydWUpIHtcbiAgICAgIHNjYW5zdHJpZGUgKz0gd2lkdGggKiA0ICogNzsgIC8vIFBhc3MgMS5cbiAgICB9XG5cbiAgICB2YXIgaW50ZXJsYWNlc2tpcCA9IDg7ICAvLyBUcmFja2luZyB0aGUgcm93IGludGVydmFsIGluIHRoZSBjdXJyZW50IHBhc3MuXG5cbiAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBpbmRleF9zdHJlYW0ubGVuZ3RoOyBpIDwgaWw7ICsraSkge1xuICAgICAgdmFyIGluZGV4ID0gaW5kZXhfc3RyZWFtW2ldO1xuXG4gICAgICBpZiAoeGxlZnQgPT09IDApIHsgIC8vIEJlZ2lubmluZyBvZiBuZXcgc2NhbiBsaW5lXG4gICAgICAgIG9wICs9IHNjYW5zdHJpZGU7XG4gICAgICAgIHhsZWZ0ID0gZnJhbWV3aWR0aDtcbiAgICAgICAgaWYgKG9wID49IG9wZW5kKSB7IC8vIENhdGNoIHRoZSB3cmFwIHRvIHN3aXRjaCBwYXNzZXMgd2hlbiBpbnRlcmxhY2luZy5cbiAgICAgICAgICBzY2Fuc3RyaWRlID0gZnJhbWVzdHJpZGUgKiA0ICsgd2lkdGggKiA0ICogKGludGVybGFjZXNraXAtMSk7XG4gICAgICAgICAgLy8gaW50ZXJsYWNlc2tpcCAvIDIgKiA0IGlzIGludGVybGFjZXNraXAgPDwgMS5cbiAgICAgICAgICBvcCA9IG9wYmVnICsgKGZyYW1ld2lkdGggKyBmcmFtZXN0cmlkZSkgKiAoaW50ZXJsYWNlc2tpcCA8PCAxKTtcbiAgICAgICAgICBpbnRlcmxhY2Vza2lwID4+PSAxO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpbmRleCA9PT0gdHJhbnMpIHtcbiAgICAgICAgb3AgKz0gNDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByID0gYnVmW3BhbGV0dGVfb2Zmc2V0ICsgaW5kZXggKiAzXTtcbiAgICAgICAgdmFyIGcgPSBidWZbcGFsZXR0ZV9vZmZzZXQgKyBpbmRleCAqIDMgKyAxXTtcbiAgICAgICAgdmFyIGIgPSBidWZbcGFsZXR0ZV9vZmZzZXQgKyBpbmRleCAqIDMgKyAyXTtcbiAgICAgICAgcGl4ZWxzW29wKytdID0gYjtcbiAgICAgICAgcGl4ZWxzW29wKytdID0gZztcbiAgICAgICAgcGl4ZWxzW29wKytdID0gcjtcbiAgICAgICAgcGl4ZWxzW29wKytdID0gMjU1O1xuICAgICAgfVxuICAgICAgLS14bGVmdDtcbiAgICB9XG4gIH07XG5cbiAgLy8gSSB3aWxsIGdvIHRvIGNvcHkgYW5kIHBhc3RlIGhlbGwgb25lIGRheS4uLlxuICB0aGlzLmRlY29kZUFuZEJsaXRGcmFtZVJHQkEgPSBmdW5jdGlvbihmcmFtZV9udW0sIHBpeGVscykge1xuICAgIHZhciBmcmFtZSA9IHRoaXMuZnJhbWVJbmZvKGZyYW1lX251bSk7XG4gICAgdmFyIG51bV9waXhlbHMgPSBmcmFtZS53aWR0aCAqIGZyYW1lLmhlaWdodDtcbiAgICB2YXIgaW5kZXhfc3RyZWFtID0gbmV3IFVpbnQ4QXJyYXkobnVtX3BpeGVscyk7ICAvLyBBdCBtb3N0IDgtYml0IGluZGljZXMuXG4gICAgR2lmUmVhZGVyTFpXT3V0cHV0SW5kZXhTdHJlYW0oXG4gICAgICAgIGJ1ZiwgZnJhbWUuZGF0YV9vZmZzZXQsIGluZGV4X3N0cmVhbSwgbnVtX3BpeGVscyk7XG4gICAgdmFyIHBhbGV0dGVfb2Zmc2V0ID0gZnJhbWUucGFsZXR0ZV9vZmZzZXQ7XG5cbiAgICAvLyBOT1RFKGRlYW5tKTogSXQgc2VlbXMgdG8gYmUgbXVjaCBmYXN0ZXIgdG8gY29tcGFyZSBpbmRleCB0byAyNTYgdGhhblxuICAgIC8vIHRvID09PSBudWxsLiAgTm90IHN1cmUgd2h5LCBidXQgQ29tcGFyZVN0dWJfRVFfU1RSSUNUIHNob3dzIHVwIGhpZ2ggaW5cbiAgICAvLyB0aGUgcHJvZmlsZSwgbm90IHN1cmUgaWYgaXQncyByZWxhdGVkIHRvIHVzaW5nIGEgVWludDhBcnJheS5cbiAgICB2YXIgdHJhbnMgPSBmcmFtZS50cmFuc3BhcmVudF9pbmRleDtcbiAgICBpZiAodHJhbnMgPT09IG51bGwpIHRyYW5zID0gMjU2O1xuXG4gICAgLy8gV2UgYXJlIHBvc3NpYmx5IGp1c3QgYmxpdHRpbmcgdG8gYSBwb3J0aW9uIG9mIHRoZSBlbnRpcmUgZnJhbWUuXG4gICAgLy8gVGhhdCBpcyBhIHN1YnJlY3Qgd2l0aGluIHRoZSBmcmFtZXJlY3QsIHNvIHRoZSBhZGRpdGlvbmFsIHBpeGVsc1xuICAgIC8vIG11c3QgYmUgc2tpcHBlZCBvdmVyIGFmdGVyIHdlIGZpbmlzaGVkIGEgc2NhbmxpbmUuXG4gICAgdmFyIGZyYW1ld2lkdGggID0gZnJhbWUud2lkdGg7XG4gICAgdmFyIGZyYW1lc3RyaWRlID0gd2lkdGggLSBmcmFtZXdpZHRoO1xuICAgIHZhciB4bGVmdCAgICAgICA9IGZyYW1ld2lkdGg7ICAvLyBOdW1iZXIgb2Ygc3VicmVjdCBwaXhlbHMgbGVmdCBpbiBzY2FubGluZS5cblxuICAgIC8vIE91dHB1dCBpbmRpY2llcyBvZiB0aGUgdG9wIGxlZnQgYW5kIGJvdHRvbSByaWdodCBjb3JuZXJzIG9mIHRoZSBzdWJyZWN0LlxuICAgIHZhciBvcGJlZyA9ICgoZnJhbWUueSAqIHdpZHRoKSArIGZyYW1lLngpICogNDtcbiAgICB2YXIgb3BlbmQgPSAoKGZyYW1lLnkgKyBmcmFtZS5oZWlnaHQpICogd2lkdGggKyBmcmFtZS54KSAqIDQ7XG4gICAgdmFyIG9wICAgID0gb3BiZWc7XG5cbiAgICB2YXIgc2NhbnN0cmlkZSA9IGZyYW1lc3RyaWRlICogNDtcblxuICAgIC8vIFVzZSBzY2Fuc3RyaWRlIHRvIHNraXAgcGFzdCB0aGUgcm93cyB3aGVuIGludGVybGFjaW5nLiAgVGhpcyBpcyBza2lwcGluZ1xuICAgIC8vIDcgcm93cyBmb3IgdGhlIGZpcnN0IHR3byBwYXNzZXMsIHRoZW4gMyB0aGVuIDEuXG4gICAgaWYgKGZyYW1lLmludGVybGFjZWQgPT09IHRydWUpIHtcbiAgICAgIHNjYW5zdHJpZGUgKz0gd2lkdGggKiA0ICogNzsgIC8vIFBhc3MgMS5cbiAgICB9XG5cbiAgICB2YXIgaW50ZXJsYWNlc2tpcCA9IDg7ICAvLyBUcmFja2luZyB0aGUgcm93IGludGVydmFsIGluIHRoZSBjdXJyZW50IHBhc3MuXG5cbiAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBpbmRleF9zdHJlYW0ubGVuZ3RoOyBpIDwgaWw7ICsraSkge1xuICAgICAgdmFyIGluZGV4ID0gaW5kZXhfc3RyZWFtW2ldO1xuXG4gICAgICBpZiAoeGxlZnQgPT09IDApIHsgIC8vIEJlZ2lubmluZyBvZiBuZXcgc2NhbiBsaW5lXG4gICAgICAgIG9wICs9IHNjYW5zdHJpZGU7XG4gICAgICAgIHhsZWZ0ID0gZnJhbWV3aWR0aDtcbiAgICAgICAgaWYgKG9wID49IG9wZW5kKSB7IC8vIENhdGNoIHRoZSB3cmFwIHRvIHN3aXRjaCBwYXNzZXMgd2hlbiBpbnRlcmxhY2luZy5cbiAgICAgICAgICBzY2Fuc3RyaWRlID0gZnJhbWVzdHJpZGUgKiA0ICsgd2lkdGggKiA0ICogKGludGVybGFjZXNraXAtMSk7XG4gICAgICAgICAgLy8gaW50ZXJsYWNlc2tpcCAvIDIgKiA0IGlzIGludGVybGFjZXNraXAgPDwgMS5cbiAgICAgICAgICBvcCA9IG9wYmVnICsgKGZyYW1ld2lkdGggKyBmcmFtZXN0cmlkZSkgKiAoaW50ZXJsYWNlc2tpcCA8PCAxKTtcbiAgICAgICAgICBpbnRlcmxhY2Vza2lwID4+PSAxO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpbmRleCA9PT0gdHJhbnMpIHtcbiAgICAgICAgb3AgKz0gNDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByID0gYnVmW3BhbGV0dGVfb2Zmc2V0ICsgaW5kZXggKiAzXTtcbiAgICAgICAgdmFyIGcgPSBidWZbcGFsZXR0ZV9vZmZzZXQgKyBpbmRleCAqIDMgKyAxXTtcbiAgICAgICAgdmFyIGIgPSBidWZbcGFsZXR0ZV9vZmZzZXQgKyBpbmRleCAqIDMgKyAyXTtcbiAgICAgICAgcGl4ZWxzW29wKytdID0gcjtcbiAgICAgICAgcGl4ZWxzW29wKytdID0gZztcbiAgICAgICAgcGl4ZWxzW29wKytdID0gYjtcbiAgICAgICAgcGl4ZWxzW29wKytdID0gMjU1O1xuICAgICAgfVxuICAgICAgLS14bGVmdDtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIEdpZlJlYWRlckxaV091dHB1dEluZGV4U3RyZWFtKGNvZGVfc3RyZWFtLCBwLCBvdXRwdXQsIG91dHB1dF9sZW5ndGgpIHtcbiAgdmFyIG1pbl9jb2RlX3NpemUgPSBjb2RlX3N0cmVhbVtwKytdO1xuXG4gIHZhciBjbGVhcl9jb2RlID0gMSA8PCBtaW5fY29kZV9zaXplO1xuICB2YXIgZW9pX2NvZGUgPSBjbGVhcl9jb2RlICsgMTtcbiAgdmFyIG5leHRfY29kZSA9IGVvaV9jb2RlICsgMTtcblxuICB2YXIgY3VyX2NvZGVfc2l6ZSA9IG1pbl9jb2RlX3NpemUgKyAxOyAgLy8gTnVtYmVyIG9mIGJpdHMgcGVyIGNvZGUuXG4gIC8vIE5PVEU6IFRoaXMgc2hhcmVzIHRoZSBzYW1lIG5hbWUgYXMgdGhlIGVuY29kZXIsIGJ1dCBoYXMgYSBkaWZmZXJlbnRcbiAgLy8gbWVhbmluZyBoZXJlLiAgSGVyZSB0aGlzIG1hc2tzIGVhY2ggY29kZSBjb21pbmcgZnJvbSB0aGUgY29kZSBzdHJlYW0uXG4gIHZhciBjb2RlX21hc2sgPSAoMSA8PCBjdXJfY29kZV9zaXplKSAtIDE7XG4gIHZhciBjdXJfc2hpZnQgPSAwO1xuICB2YXIgY3VyID0gMDtcblxuICB2YXIgb3AgPSAwOyAgLy8gT3V0cHV0IHBvaW50ZXIuXG5cbiAgdmFyIHN1YmJsb2NrX3NpemUgPSBjb2RlX3N0cmVhbVtwKytdO1xuXG4gIC8vIFRPRE8oZGVhbm0pOiBXb3VsZCB1c2luZyBhIFR5cGVkQXJyYXkgYmUgYW55IGZhc3Rlcj8gIEF0IGxlYXN0IGl0IHdvdWxkXG4gIC8vIHNvbHZlIHRoZSBmYXN0IG1vZGUgLyBiYWNraW5nIHN0b3JlIHVuY2VydGFpbnR5LlxuICAvLyB2YXIgY29kZV90YWJsZSA9IEFycmF5KDQwOTYpO1xuICB2YXIgY29kZV90YWJsZSA9IG5ldyBJbnQzMkFycmF5KDQwOTYpOyAgLy8gQ2FuIGJlIHNpZ25lZCwgd2Ugb25seSB1c2UgMjAgYml0cy5cblxuICB2YXIgcHJldl9jb2RlID0gbnVsbDsgIC8vIFRyYWNrIGNvZGUtMS5cblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIC8vIFJlYWQgdXAgdG8gdHdvIGJ5dGVzLCBtYWtpbmcgc3VyZSB3ZSBhbHdheXMgMTItYml0cyBmb3IgbWF4IHNpemVkIGNvZGUuXG4gICAgd2hpbGUgKGN1cl9zaGlmdCA8IDE2KSB7XG4gICAgICBpZiAoc3ViYmxvY2tfc2l6ZSA9PT0gMCkgYnJlYWs7ICAvLyBObyBtb3JlIGRhdGEgdG8gYmUgcmVhZC5cblxuICAgICAgY3VyIHw9IGNvZGVfc3RyZWFtW3ArK10gPDwgY3VyX3NoaWZ0O1xuICAgICAgY3VyX3NoaWZ0ICs9IDg7XG5cbiAgICAgIGlmIChzdWJibG9ja19zaXplID09PSAxKSB7ICAvLyBOZXZlciBsZXQgaXQgZ2V0IHRvIDAgdG8gaG9sZCBsb2dpYyBhYm92ZS5cbiAgICAgICAgc3ViYmxvY2tfc2l6ZSA9IGNvZGVfc3RyZWFtW3ArK107ICAvLyBOZXh0IHN1YmJsb2NrLlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLS1zdWJibG9ja19zaXplO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRPRE8oZGVhbm0pOiBXZSBzaG91bGQgbmV2ZXIgcmVhbGx5IGdldCBoZXJlLCB3ZSBzaG91bGQgaGF2ZSByZWNlaXZlZFxuICAgIC8vIGFuZCBFT0kuXG4gICAgaWYgKGN1cl9zaGlmdCA8IGN1cl9jb2RlX3NpemUpXG4gICAgICBicmVhaztcblxuICAgIHZhciBjb2RlID0gY3VyICYgY29kZV9tYXNrO1xuICAgIGN1ciA+Pj0gY3VyX2NvZGVfc2l6ZTtcbiAgICBjdXJfc2hpZnQgLT0gY3VyX2NvZGVfc2l6ZTtcblxuICAgIC8vIFRPRE8oZGVhbm0pOiBNYXliZSBzaG91bGQgY2hlY2sgdGhhdCB0aGUgZmlyc3QgY29kZSB3YXMgYSBjbGVhciBjb2RlLFxuICAgIC8vIGF0IGxlYXN0IHRoaXMgaXMgd2hhdCB5b3UncmUgc3VwcG9zZWQgdG8gZG8uICBCdXQgYWN0dWFsbHkgb3VyIGVuY29kZXJcbiAgICAvLyBub3cgZG9lc24ndCBlbWl0IGEgY2xlYXIgY29kZSBmaXJzdCBhbnl3YXkuXG4gICAgaWYgKGNvZGUgPT09IGNsZWFyX2NvZGUpIHtcbiAgICAgIC8vIFdlIGRvbid0IGFjdHVhbGx5IGhhdmUgdG8gY2xlYXIgdGhlIHRhYmxlLiAgVGhpcyBjb3VsZCBiZSBhIGdvb2QgaWRlYVxuICAgICAgLy8gZm9yIGdyZWF0ZXIgZXJyb3IgY2hlY2tpbmcsIGJ1dCB3ZSBkb24ndCByZWFsbHkgZG8gYW55IGFueXdheS4gIFdlXG4gICAgICAvLyB3aWxsIGp1c3QgdHJhY2sgaXQgd2l0aCBuZXh0X2NvZGUgYW5kIG92ZXJ3cml0ZSBvbGQgZW50cmllcy5cblxuICAgICAgbmV4dF9jb2RlID0gZW9pX2NvZGUgKyAxO1xuICAgICAgY3VyX2NvZGVfc2l6ZSA9IG1pbl9jb2RlX3NpemUgKyAxO1xuICAgICAgY29kZV9tYXNrID0gKDEgPDwgY3VyX2NvZGVfc2l6ZSkgLSAxO1xuXG4gICAgICAvLyBEb24ndCB1cGRhdGUgcHJldl9jb2RlID9cbiAgICAgIHByZXZfY29kZSA9IG51bGw7XG4gICAgICBjb250aW51ZTtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IGVvaV9jb2RlKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyBXZSBoYXZlIGEgc2ltaWxhciBzaXR1YXRpb24gYXMgdGhlIGRlY29kZXIsIHdoZXJlIHdlIHdhbnQgdG8gc3RvcmVcbiAgICAvLyB2YXJpYWJsZSBsZW5ndGggZW50cmllcyAoY29kZSB0YWJsZSBlbnRyaWVzKSwgYnV0IHdlIHdhbnQgdG8gZG8gaW4gYVxuICAgIC8vIGZhc3RlciBtYW5uZXIgdGhhbiBhbiBhcnJheSBvZiBhcnJheXMuICBUaGUgY29kZSBiZWxvdyBzdG9yZXMgc29ydCBvZiBhXG4gICAgLy8gbGlua2VkIGxpc3Qgd2l0aGluIHRoZSBjb2RlIHRhYmxlLCBhbmQgdGhlbiBcImNoYXNlc1wiIHRocm91Z2ggaXQgdG9cbiAgICAvLyBjb25zdHJ1Y3QgdGhlIGRpY3Rpb25hcnkgZW50cmllcy4gIFdoZW4gYSBuZXcgZW50cnkgaXMgY3JlYXRlZCwganVzdCB0aGVcbiAgICAvLyBsYXN0IGJ5dGUgaXMgc3RvcmVkLCBhbmQgdGhlIHJlc3QgKHByZWZpeCkgb2YgdGhlIGVudHJ5IGlzIG9ubHlcbiAgICAvLyByZWZlcmVuY2VkIGJ5IGl0cyB0YWJsZSBlbnRyeS4gIFRoZW4gdGhlIGNvZGUgY2hhc2VzIHRocm91Z2ggdGhlXG4gICAgLy8gcHJlZml4ZXMgdW50aWwgaXQgcmVhY2hlcyBhIHNpbmdsZSBieXRlIGNvZGUuICBXZSBoYXZlIHRvIGNoYXNlIHR3aWNlLFxuICAgIC8vIGZpcnN0IHRvIGNvbXB1dGUgdGhlIGxlbmd0aCwgYW5kIHRoZW4gdG8gYWN0dWFsbHkgY29weSB0aGUgZGF0YSB0byB0aGVcbiAgICAvLyBvdXRwdXQgKGJhY2t3YXJkcywgc2luY2Ugd2Uga25vdyB0aGUgbGVuZ3RoKS4gIFRoZSBhbHRlcm5hdGl2ZSB3b3VsZCBiZVxuICAgIC8vIHN0b3Jpbmcgc29tZXRoaW5nIGluIGFuIGludGVybWVkaWF0ZSBzdGFjaywgYnV0IHRoYXQgZG9lc24ndCBtYWtlIGFueVxuICAgIC8vIG1vcmUgc2Vuc2UuICBJIGltcGxlbWVudGVkIGFuIGFwcHJvYWNoIHdoZXJlIGl0IGFsc28gc3RvcmVkIHRoZSBsZW5ndGhcbiAgICAvLyBpbiB0aGUgY29kZSB0YWJsZSwgYWx0aG91Z2ggaXQncyBhIGJpdCB0cmlja3kgYmVjYXVzZSB5b3UgcnVuIG91dCBvZlxuICAgIC8vIGJpdHMgKDEyICsgMTIgKyA4KSwgYnV0IEkgZGlkbid0IG1lYXN1cmUgbXVjaCBpbXByb3ZlbWVudHMgKHRoZSB0YWJsZVxuICAgIC8vIGVudHJpZXMgYXJlIGdlbmVyYWxseSBub3QgdGhlIGxvbmcpLiAgRXZlbiB3aGVuIEkgY3JlYXRlZCBiZW5jaG1hcmtzIGZvclxuICAgIC8vIHZlcnkgbG9uZyB0YWJsZSBlbnRyaWVzIHRoZSBjb21wbGV4aXR5IGRpZCBub3Qgc2VlbSB3b3J0aCBpdC5cbiAgICAvLyBUaGUgY29kZSB0YWJsZSBzdG9yZXMgdGhlIHByZWZpeCBlbnRyeSBpbiAxMiBiaXRzIGFuZCB0aGVuIHRoZSBzdWZmaXhcbiAgICAvLyBieXRlIGluIDggYml0cywgc28gZWFjaCBlbnRyeSBpcyAyMCBiaXRzLlxuXG4gICAgdmFyIGNoYXNlX2NvZGUgPSBjb2RlIDwgbmV4dF9jb2RlID8gY29kZSA6IHByZXZfY29kZTtcblxuICAgIC8vIENoYXNlIHdoYXQgd2Ugd2lsbCBvdXRwdXQsIGVpdGhlciB7Q09ERX0gb3Ige0NPREUtMX0uXG4gICAgdmFyIGNoYXNlX2xlbmd0aCA9IDA7XG4gICAgdmFyIGNoYXNlID0gY2hhc2VfY29kZTtcbiAgICB3aGlsZSAoY2hhc2UgPiBjbGVhcl9jb2RlKSB7XG4gICAgICBjaGFzZSA9IGNvZGVfdGFibGVbY2hhc2VdID4+IDg7XG4gICAgICArK2NoYXNlX2xlbmd0aDtcbiAgICB9XG5cbiAgICB2YXIgayA9IGNoYXNlO1xuXG4gICAgdmFyIG9wX2VuZCA9IG9wICsgY2hhc2VfbGVuZ3RoICsgKGNoYXNlX2NvZGUgIT09IGNvZGUgPyAxIDogMCk7XG4gICAgaWYgKG9wX2VuZCA+IG91dHB1dF9sZW5ndGgpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiV2FybmluZywgZ2lmIHN0cmVhbSBsb25nZXIgdGhhbiBleHBlY3RlZC5cIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQWxyZWFkeSBoYXZlIHRoZSBmaXJzdCBieXRlIGZyb20gdGhlIGNoYXNlLCBtaWdodCBhcyB3ZWxsIHdyaXRlIGl0IGZhc3QuXG4gICAgb3V0cHV0W29wKytdID0gaztcblxuICAgIG9wICs9IGNoYXNlX2xlbmd0aDtcbiAgICB2YXIgYiA9IG9wOyAgLy8gVHJhY2sgcG9pbnRlciwgd3JpdGluZyBiYWNrd2FyZHMuXG5cbiAgICBpZiAoY2hhc2VfY29kZSAhPT0gY29kZSkgIC8vIFRoZSBjYXNlIG9mIGVtaXR0aW5nIHtDT0RFLTF9ICsgay5cbiAgICAgIG91dHB1dFtvcCsrXSA9IGs7XG5cbiAgICBjaGFzZSA9IGNoYXNlX2NvZGU7XG4gICAgd2hpbGUgKGNoYXNlX2xlbmd0aC0tKSB7XG4gICAgICBjaGFzZSA9IGNvZGVfdGFibGVbY2hhc2VdO1xuICAgICAgb3V0cHV0Wy0tYl0gPSBjaGFzZSAmIDB4ZmY7ICAvLyBXcml0ZSBiYWNrd2FyZHMuXG4gICAgICBjaGFzZSA+Pj0gODsgIC8vIFB1bGwgZG93biB0byB0aGUgcHJlZml4IGNvZGUuXG4gICAgfVxuXG4gICAgaWYgKHByZXZfY29kZSAhPT0gbnVsbCAmJiBuZXh0X2NvZGUgPCA0MDk2KSB7XG4gICAgICBjb2RlX3RhYmxlW25leHRfY29kZSsrXSA9IHByZXZfY29kZSA8PCA4IHwgaztcbiAgICAgIC8vIFRPRE8oZGVhbm0pOiBGaWd1cmUgb3V0IHRoaXMgY2xlYXJpbmcgdnMgY29kZSBncm93dGggbG9naWMgYmV0dGVyLiAgSVxuICAgICAgLy8gaGF2ZSBhbiBmZWVsaW5nIHRoYXQgaXQgc2hvdWxkIGp1c3QgaGFwcGVuIHNvbWV3aGVyZSBlbHNlLCBmb3Igbm93IGl0XG4gICAgICAvLyBpcyBhd2t3YXJkIGJldHdlZW4gd2hlbiB3ZSBncm93IHBhc3QgdGhlIG1heCBhbmQgdGhlbiBoaXQgYSBjbGVhciBjb2RlLlxuICAgICAgLy8gRm9yIG5vdyBqdXN0IGNoZWNrIGlmIHdlIGhpdCB0aGUgbWF4IDEyLWJpdHMgKHRoZW4gYSBjbGVhciBjb2RlIHNob3VsZFxuICAgICAgLy8gZm9sbG93LCBhbHNvIG9mIGNvdXJzZSBlbmNvZGVkIGluIDEyLWJpdHMpLlxuICAgICAgaWYgKG5leHRfY29kZSA+PSBjb2RlX21hc2srMSAmJiBjdXJfY29kZV9zaXplIDwgMTIpIHtcbiAgICAgICAgKytjdXJfY29kZV9zaXplO1xuICAgICAgICBjb2RlX21hc2sgPSBjb2RlX21hc2sgPDwgMSB8IDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcHJldl9jb2RlID0gY29kZTtcbiAgfVxuXG4gIGlmIChvcCAhPT0gb3V0cHV0X2xlbmd0aCkge1xuICAgIGNvbnNvbGUubG9nKFwiV2FybmluZywgZ2lmIHN0cmVhbSBzaG9ydGVyIHRoYW4gZXhwZWN0ZWQuXCIpO1xuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuLy8gQ29tbW9uSlMuXG50cnkgeyBleHBvcnRzLkdpZldyaXRlciA9IEdpZldyaXRlcjsgZXhwb3J0cy5HaWZSZWFkZXIgPSBHaWZSZWFkZXIgfSBjYXRjaChlKSB7fVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///0\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, "canvastoDataURL", function() { return /* reexport */ canvastoDataURL; });\n__webpack_require__.d(__webpack_exports__, "canvastoFile", function() { return /* reexport */ canvastoFile; });\n__webpack_require__.d(__webpack_exports__, "dataURLtoFile", function() { return /* reexport */ dataURLtoFile; });\n__webpack_require__.d(__webpack_exports__, "dataURLtoImage", function() { return /* reexport */ dataURLtoImage; });\n__webpack_require__.d(__webpack_exports__, "downloadFile", function() { return /* reexport */ downloadFile; });\n__webpack_require__.d(__webpack_exports__, "filetoDataURL", function() { return /* reexport */ filetoDataURL; });\n__webpack_require__.d(__webpack_exports__, "imagetoCanvas", function() { return /* reexport */ imagetoCanvas; });\n__webpack_require__.d(__webpack_exports__, "urltoBlob", function() { return /* reexport */ urltoBlob; });\n__webpack_require__.d(__webpack_exports__, "urltoImage", function() { return /* reexport */ urltoImage; });\n__webpack_require__.d(__webpack_exports__, "compress", function() { return /* binding */ compress; });\n__webpack_require__.d(__webpack_exports__, "compressAccurately", function() { return /* binding */ compressAccurately; });\n__webpack_require__.d(__webpack_exports__, "EImageType", function() { return /* reexport */ EImageType; });\n\n// CONCATENATED MODULE: ./src/models/index.ts\nvar EImageType;\r\n(function (EImageType) {\r\n    EImageType["PNG"] = "image/png";\r\n    EImageType["JPEG"] = "image/jpeg";\r\n    EImageType["GIF"] = "image/gif";\r\n})(EImageType || (EImageType = {}));\r\n\n// CONCATENATED MODULE: ./src/utils/checkImageType.ts\nfunction checkImageType(type) {\r\n    return [\'image/png\', \'image/jpeg\', \'image/gif\'].some(i => i === type);\r\n}\r\n\n// CONCATENATED MODULE: ./src/utils/index.ts\n\r\n\r\n\n// CONCATENATED MODULE: ./src/canvastoDataURL.ts\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n/**\r\n * CanvasdataURL\r\n * \r\n *\r\n * @param {canvas} canvas\r\n * @param {number=} quality -  0-10.92\r\n * @param {string=} type -  "image/png", "image/jpeg", "image/gif","image/jpeg"\r\n * @returns {Promise(string)} PromisedataURL\r\n */\r\nfunction canvastoDataURL(canvas, quality = 0.92, type = EImageType.JPEG) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        if (!checkImageType(type)) {\r\n            type = EImageType.JPEG;\r\n        }\r\n        return canvas.toDataURL(type, quality);\r\n    });\r\n}\r\n;\r\n\n// CONCATENATED MODULE: ./src/canvastoFile.ts\n\r\n/**\r\n * canvasFileBlob\r\n * \r\n *\r\n * @param {canvas} canvas\r\n * @param {number=} quality -  0-10.92\r\n * @param {string=} type -  "image/png", "image/jpeg", "image/gif","image/jpeg"\r\n * @returns {Promise(Blob)}\r\n */\r\nfunction canvastoFile(canvas, quality = 0.92, type = EImageType.JPEG) {\r\n    return new Promise(resolve => canvas.toBlob(blob => resolve(blob), type, quality));\r\n}\r\n;\r\n\n// CONCATENATED MODULE: ./src/dataURLtoFile.ts\nvar dataURLtoFile_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n/**\r\n * dataURLFileBlob\r\n * File\r\n *\r\n * @param {string} dataURL\r\n * @param {string=} type -  "image/png", "image/jpeg", "image/gif"\r\n * @returns {Promise(Blob)}\r\n */\r\nfunction dataURLtoFile(dataURL, type) {\r\n    return dataURLtoFile_awaiter(this, void 0, void 0, function* () {\r\n        const arr = dataURL.split(\',\');\r\n        let mime = arr[0].match(/:(.*?);/)[1];\r\n        const bstr = atob(arr[1]);\r\n        let n = bstr.length;\r\n        const u8arr = new Uint8Array(n);\r\n        while (n--) {\r\n            u8arr[n] = bstr.charCodeAt(n);\r\n        }\r\n        if (checkImageType(type)) {\r\n            mime = type;\r\n        }\r\n        return new Blob([u8arr], {\r\n            type: mime,\r\n        });\r\n    });\r\n}\r\n;\r\n\n// CONCATENATED MODULE: ./src/dataURLtoImage.ts\n/**\r\n * dataURLimage\r\n *\r\n * @param {srting} dataURL - dataURL\r\n * @returns {Promise(Image)}\r\n */\r\nfunction dataURLtoImage(dataURL) {\r\n    return new Promise((resolve, reject) => {\r\n        const img = new Image();\r\n        img.onload = () => resolve(img);\r\n        img.onerror = () => reject(new Error(\'dataURLtoImage(): dataURL is illegal\'));\r\n        img.src = dataURL;\r\n    });\r\n}\r\n;\r\n\n// CONCATENATED MODULE: ./src/downloadFile.ts\n/**\r\n * \r\n *\r\n * @param {Blob} file - FileBlob\r\n * @param {string=} fileName - \r\n */\r\nfunction downloadFile(file, fileName) {\r\n    const link = document.createElement(\'a\');\r\n    link.href = window.URL.createObjectURL(file);\r\n    link.download = fileName || Date.now().toString(36);\r\n    document.body.appendChild(link);\r\n    const evt = document.createEvent(\'MouseEvents\');\r\n    evt.initEvent(\'click\', false, false);\r\n    link.dispatchEvent(evt);\r\n    document.body.removeChild(link);\r\n}\r\n;\r\n\n// CONCATENATED MODULE: ./src/filetoDataURL.ts\n/**\r\n * FileBlobdataURL\r\n *\r\n * @param {Blob} file\r\n * @returns {Promise(string)} PromisedataURL\r\n */\r\nfunction filetoDataURL(file) {\r\n    return new Promise((resolve) => {\r\n        const reader = new FileReader();\r\n        reader.onloadend = e => resolve(e.target.result);\r\n        reader.readAsDataURL(file);\r\n    });\r\n}\r\n;\r\n\n// EXTERNAL MODULE: ./node_modules/omggif/omggif.js\nvar omggif = __webpack_require__(0);\n\n// CONCATENATED MODULE: ./src/neuquant.js\nfunction NeuQuant() {\r\n    var netsize = 256; // number of colours used\r\n  \r\n    // four primes near 500 - assume no image has a length so large\r\n    // that it is divisible by all four primes\r\n    var prime1 = 499;\r\n    var prime2 = 491;\r\n    var prime3 = 487;\r\n    var prime4 = 503;\r\n  \r\n    // minimum size for input image\r\n    var minpicturebytes = 3 * prime4;\r\n  \r\n    // Network Definitions\r\n  \r\n    var maxnetpos = netsize - 1;\r\n    var netbiasshift = 4; // bias for colour values\r\n    var ncycles = 100; // no. of learning cycles\r\n  \r\n    // defs for freq and bias\r\n    var intbiasshift = 16; // bias for fractions\r\n    var intbias = 1 << intbiasshift;\r\n    var gammashift = 10; // gamma = 1024\r\n    var gamma = 1 << gammashift;\r\n    var betashift = 10;\r\n    var beta = intbias >> betashift; // beta = 1/1024\r\n    var betagamma = intbias << gammashift - betashift;\r\n  \r\n    // defs for decreasing radius factor\r\n    // For 256 colors, radius starts at 32.0 biased by 6 bits\r\n    // and decreases by a factor of 1/30 each cycle\r\n    var initrad = netsize >> 3;\r\n    var radiusbiasshift = 6;\r\n    var radiusbias = 1 << radiusbiasshift;\r\n    var initradius = initrad * radiusbias;\r\n    var radiusdec = 30;\r\n  \r\n    // defs for decreasing alpha factor\r\n    // Alpha starts at 1.0 biased by 10 bits\r\n    var alphabiasshift = 10;\r\n    var initalpha = 1 << alphabiasshift;\r\n    var alphadec;\r\n  \r\n    // radbias and alpharadbias used for radpower calculation\r\n    var radbiasshift = 8;\r\n    var radbias = 1 << radbiasshift;\r\n    var alpharadbshift = alphabiasshift + radbiasshift;\r\n    var alpharadbias = 1 << alpharadbshift;\r\n  \r\n    // Input image\r\n    var thepicture;\r\n    // Height * Width * 3\r\n    var lengthcount;\r\n    // Sampling factor 1..30\r\n    var samplefac;\r\n  \r\n    // The network itself\r\n    var network;\r\n    var netindex = [];\r\n  \r\n    // for network lookup - really 256\r\n    var bias = [];\r\n  \r\n    // bias and freq arrays for learning\r\n    var freq = [];\r\n    var radpower = [];\r\n  \r\n    function NeuQuantConstructor(thepic, len, sample) {\r\n  \r\n      var i;\r\n      var p;\r\n  \r\n      thepicture = thepic;\r\n      lengthcount = len;\r\n      samplefac = sample;\r\n  \r\n      network = new Array(netsize);\r\n  \r\n      for (i = 0; i < netsize; i++) {\r\n        network[i] = new Array(4);\r\n        p = network[i];\r\n        p[0] = p[1] = p[2] = (i << netbiasshift + 8) / netsize | 0;\r\n        freq[i] = intbias / netsize | 0; // 1 / netsize\r\n        bias[i] = 0;\r\n      }\r\n    }\r\n  \r\n    function colorMap() {\r\n      var map = [];\r\n      var index = new Array(netsize);\r\n      for (var i = 0; i < netsize; i++) {\r\n        index[network[i][3]] = i;\r\n      }var k = 0;\r\n      for (var l = 0; l < netsize; l++) {\r\n        var j = index[l];\r\n        map[k++] = network[j][0];\r\n        map[k++] = network[j][1];\r\n        map[k++] = network[j][2];\r\n      }\r\n      return map;\r\n    }\r\n  \r\n    // Insertion sort of network and building of netindex[0..255]\r\n    // (to do after unbias)\r\n    function inxbuild() {\r\n      var i;\r\n      var j;\r\n      var smallpos;\r\n      var smallval;\r\n      var p;\r\n      var q;\r\n      var previouscol;\r\n      var startpos;\r\n  \r\n      previouscol = 0;\r\n      startpos = 0;\r\n  \r\n      for (i = 0; i < netsize; i++) {\r\n  \r\n        p = network[i];\r\n        smallpos = i;\r\n        smallval = p[1]; // index on g\r\n        // find smallest in i..netsize-1\r\n        for (j = i + 1; j < netsize; j++) {\r\n  \r\n          q = network[j];\r\n  \r\n          if (q[1] < smallval) {\r\n            // index on g\r\n            smallpos = j;\r\n            smallval = q[1]; // index on g\r\n          }\r\n        }\r\n  \r\n        q = network[smallpos];\r\n  \r\n        // swap p (i) and q (smallpos) entries\r\n        if (i != smallpos) {\r\n          j = q[0];\r\n          q[0] = p[0];\r\n          p[0] = j;\r\n          j = q[1];\r\n          q[1] = p[1];\r\n          p[1] = j;\r\n          j = q[2];\r\n          q[2] = p[2];\r\n          p[2] = j;\r\n          j = q[3];\r\n          q[3] = p[3];\r\n          p[3] = j;\r\n        }\r\n  \r\n        // smallval entry is now in position i\r\n        if (smallval != previouscol) {\r\n  \r\n          netindex[previouscol] = startpos + i >> 1;\r\n  \r\n          for (j = previouscol + 1; j < smallval; j++) {\r\n            netindex[j] = i;\r\n          }\r\n  \r\n          previouscol = smallval;\r\n          startpos = i;\r\n        }\r\n      }\r\n  \r\n      netindex[previouscol] = startpos + maxnetpos >> 1;\r\n      for (j = previouscol + 1; j < 256; j++) {\r\n        netindex[j] = maxnetpos; // really 256\r\n      }\r\n    }\r\n  \r\n    // Main Learning Loop\r\n  \r\n    function learn() {\r\n      var i;\r\n      var j;\r\n      var b;\r\n      var g;\r\n      var r;\r\n      var radius;\r\n      var rad;\r\n      var alpha;\r\n      var step;\r\n      var delta;\r\n      var samplepixels;\r\n      var p;\r\n      var pix;\r\n      var lim;\r\n  \r\n      if (lengthcount < minpicturebytes) {\r\n        samplefac = 1;\r\n      }\r\n  \r\n      alphadec = 30 + (samplefac - 1) / 3;\r\n      p = thepicture;\r\n      pix = 0;\r\n      lim = lengthcount;\r\n      samplepixels = lengthcount / (3 * samplefac);\r\n      delta = samplepixels / ncycles | 0;\r\n      alpha = initalpha;\r\n      radius = initradius;\r\n  \r\n      rad = radius >> radiusbiasshift;\r\n      if (rad <= 1) {\r\n        rad = 0;\r\n      }\r\n  \r\n      for (i = 0; i < rad; i++) {\r\n        radpower[i] = alpha * ((rad * rad - i * i) * radbias / (rad * rad));\r\n      }\r\n  \r\n      if (lengthcount < minpicturebytes) {\r\n        step = 3;\r\n      } else if (lengthcount % prime1 !== 0) {\r\n        step = 3 * prime1;\r\n      } else {\r\n  \r\n        if (lengthcount % prime2 !== 0) {\r\n          step = 3 * prime2;\r\n        } else {\r\n          if (lengthcount % prime3 !== 0) {\r\n            step = 3 * prime3;\r\n          } else {\r\n            step = 3 * prime4;\r\n          }\r\n        }\r\n      }\r\n  \r\n      i = 0;\r\n  \r\n      while (i < samplepixels) {\r\n  \r\n        b = (p[pix + 0] & 0xff) << netbiasshift;\r\n        g = (p[pix + 1] & 0xff) << netbiasshift;\r\n        r = (p[pix + 2] & 0xff) << netbiasshift;\r\n        j = contest(b, g, r);\r\n  \r\n        altersingle(alpha, j, b, g, r);\r\n  \r\n        if (rad !== 0) {\r\n          // Alter neighbours\r\n          alterneigh(rad, j, b, g, r);\r\n        }\r\n  \r\n        pix += step;\r\n  \r\n        if (pix >= lim) {\r\n          pix -= lengthcount;\r\n        }\r\n  \r\n        i++;\r\n  \r\n        if (delta === 0) {\r\n          delta = 1;\r\n        }\r\n  \r\n        if (i % delta === 0) {\r\n          alpha -= alpha / alphadec;\r\n          radius -= radius / radiusdec;\r\n          rad = radius >> radiusbiasshift;\r\n  \r\n          if (rad <= 1) {\r\n            rad = 0;\r\n          }\r\n  \r\n          for (j = 0; j < rad; j++) {\r\n            radpower[j] = alpha * ((rad * rad - j * j) * radbias / (rad * rad));\r\n          }\r\n        }\r\n      }\r\n    }\r\n  \r\n    // Search for BGR values 0..255 (after net is unbiased) and return colour index\r\n    function map(b, g, r) {\r\n      var i;\r\n      var j;\r\n      var dist;\r\n      var a;\r\n      var bestd;\r\n      var p;\r\n      var best;\r\n  \r\n      // Biggest possible distance is 256 * 3\r\n      bestd = 1000;\r\n      best = -1;\r\n      i = netindex[g]; // index on g\r\n      j = i - 1; // start at netindex[g] and work outwards\r\n  \r\n      while (i < netsize || j >= 0) {\r\n  \r\n        if (i < netsize) {\r\n  \r\n          p = network[i];\r\n  \r\n          dist = p[1] - g; // inx key\r\n  \r\n          if (dist >= bestd) {\r\n            i = netsize; // stop iter\r\n          } else {\r\n  \r\n            i++;\r\n  \r\n            if (dist < 0) {\r\n              dist = -dist;\r\n            }\r\n  \r\n            a = p[0] - b;\r\n  \r\n            if (a < 0) {\r\n              a = -a;\r\n            }\r\n  \r\n            dist += a;\r\n  \r\n            if (dist < bestd) {\r\n              a = p[2] - r;\r\n  \r\n              if (a < 0) {\r\n                a = -a;\r\n              }\r\n  \r\n              dist += a;\r\n  \r\n              if (dist < bestd) {\r\n                bestd = dist;\r\n                best = p[3];\r\n              }\r\n            }\r\n          }\r\n        }\r\n  \r\n        if (j >= 0) {\r\n  \r\n          p = network[j];\r\n  \r\n          dist = g - p[1]; // inx key - reverse dif\r\n  \r\n          if (dist >= bestd) {\r\n            j = -1; // stop iter\r\n          } else {\r\n  \r\n            j--;\r\n            if (dist < 0) {\r\n              dist = -dist;\r\n            }\r\n            a = p[0] - b;\r\n            if (a < 0) {\r\n              a = -a;\r\n            }\r\n            dist += a;\r\n  \r\n            if (dist < bestd) {\r\n              a = p[2] - r;\r\n              if (a < 0) {\r\n                a = -a;\r\n              }\r\n              dist += a;\r\n              if (dist < bestd) {\r\n                bestd = dist;\r\n                best = p[3];\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n  \r\n      return best;\r\n    }\r\n  \r\n    function process() {\r\n      learn();\r\n      unbiasnet();\r\n      inxbuild();\r\n      return colorMap();\r\n    }\r\n  \r\n    // Unbias network to give byte values 0..255 and record position i\r\n    // to prepare for sort\r\n    function unbiasnet() {\r\n      var i;\r\n      var j;\r\n  \r\n      for (i = 0; i < netsize; i++) {\r\n        network[i][0] >>= netbiasshift;\r\n        network[i][1] >>= netbiasshift;\r\n        network[i][2] >>= netbiasshift;\r\n        network[i][3] = i; // record colour no\r\n      }\r\n    }\r\n  \r\n    // Move adjacent neurons by precomputed alpha*(1-((i-j)^2/[r]^2))\r\n    // in radpower[|i-j|]\r\n    function alterneigh(rad, i, b, g, r) {\r\n  \r\n      var j;\r\n      var k;\r\n      var lo;\r\n      var hi;\r\n      var a;\r\n      var m;\r\n  \r\n      var p;\r\n  \r\n      lo = i - rad;\r\n      if (lo < -1) {\r\n        lo = -1;\r\n      }\r\n  \r\n      hi = i + rad;\r\n  \r\n      if (hi > netsize) {\r\n        hi = netsize;\r\n      }\r\n  \r\n      j = i + 1;\r\n      k = i - 1;\r\n      m = 1;\r\n  \r\n      while (j < hi || k > lo) {\r\n  \r\n        a = radpower[m++];\r\n  \r\n        if (j < hi) {\r\n  \r\n          p = network[j++];\r\n  \r\n          try {\r\n  \r\n            p[0] -= a * (p[0] - b) / alpharadbias | 0;\r\n            p[1] -= a * (p[1] - g) / alpharadbias | 0;\r\n            p[2] -= a * (p[2] - r) / alpharadbias | 0;\r\n          } catch (e) {}\r\n        }\r\n  \r\n        if (k > lo) {\r\n  \r\n          p = network[k--];\r\n  \r\n          try {\r\n  \r\n            p[0] -= a * (p[0] - b) / alpharadbias | 0;\r\n            p[1] -= a * (p[1] - g) / alpharadbias | 0;\r\n            p[2] -= a * (p[2] - r) / alpharadbias | 0;\r\n          } catch (e) {}\r\n        }\r\n      }\r\n    }\r\n  \r\n    // Move neuron i towards biased (b,g,r) by factor alpha\r\n    function altersingle(alpha, i, b, g, r) {\r\n  \r\n      // alter hit neuron\r\n      var n = network[i];\r\n      var alphaMult = alpha / initalpha;\r\n      n[0] -= alphaMult * (n[0] - b) | 0;\r\n      n[1] -= alphaMult * (n[1] - g) | 0;\r\n      n[2] -= alphaMult * (n[2] - r) | 0;\r\n    }\r\n  \r\n    // Search for biased BGR values\r\n    function contest(b, g, r) {\r\n  \r\n      // finds closest neuron (min dist) and updates freq\r\n      // finds best neuron (min dist-bias) and returns position\r\n      // for frequently chosen neurons, freq[i] is high and bias[i] is negative\r\n      // bias[i] = gamma*((1/netsize)-freq[i])\r\n  \r\n      var i;\r\n      var dist;\r\n      var a;\r\n      var biasdist;\r\n      var betafreq;\r\n      var bestpos;\r\n      var bestbiaspos;\r\n      var bestd;\r\n      var bestbiasd;\r\n      var n;\r\n  \r\n      bestd = ~(1 << 31);\r\n      bestbiasd = bestd;\r\n      bestpos = -1;\r\n      bestbiaspos = bestpos;\r\n  \r\n      for (i = 0; i < netsize; i++) {\r\n  \r\n        n = network[i];\r\n        dist = n[0] - b;\r\n  \r\n        if (dist < 0) {\r\n          dist = -dist;\r\n        }\r\n  \r\n        a = n[1] - g;\r\n  \r\n        if (a < 0) {\r\n          a = -a;\r\n        }\r\n  \r\n        dist += a;\r\n  \r\n        a = n[2] - r;\r\n  \r\n        if (a < 0) {\r\n          a = -a;\r\n        }\r\n  \r\n        dist += a;\r\n  \r\n        if (dist < bestd) {\r\n          bestd = dist;\r\n          bestpos = i;\r\n        }\r\n  \r\n        biasdist = dist - (bias[i] >> intbiasshift - netbiasshift);\r\n  \r\n        if (biasdist < bestbiasd) {\r\n          bestbiasd = biasdist;\r\n          bestbiaspos = i;\r\n        }\r\n  \r\n        betafreq = freq[i] >> betashift;\r\n        freq[i] -= betafreq;\r\n        bias[i] += betafreq << gammashift;\r\n      }\r\n  \r\n      freq[bestpos] += beta;\r\n      bias[bestpos] -= betagamma;\r\n      return bestbiaspos;\r\n    }\r\n  \r\n    NeuQuantConstructor.apply(this, arguments);\r\n\r\n    let exports = {};\r\n    exports.map = map;\r\n    exports.process = process;\r\n\r\n    return exports;\r\n  }\n// CONCATENATED MODULE: ./src/imageDataToRGB.ts\n/**\r\n * FileBlobdataURL\r\n *\r\n * @param {ImageData} data\r\n * @returns {number[]]} []\r\n */\r\nfunction imageDataToRGB(data, width, height) {\r\n    let length = width * height * 4;\r\n    let i = 0;\r\n    let rgb = [];\r\n    while (i < length) {\r\n        rgb.push(data[i++]);\r\n        rgb.push(data[i++]);\r\n        rgb.push(data[i++]);\r\n        i++; // for the alpha channel which we don\'t care about\r\n    }\r\n    return rgb;\r\n}\r\n\n// CONCATENATED MODULE: ./src/processFrameWithQuantizer.ts\n\r\n\r\nfunction componentizedPaletteToArray(paletteRGB) {\r\n    paletteRGB = paletteRGB || [];\r\n    let paletteArray = [];\r\n    for (let i = 0; i < paletteRGB.length; i += 3) {\r\n        let r = paletteRGB[i];\r\n        let g = paletteRGB[i + 1];\r\n        let b = paletteRGB[i + 2];\r\n        paletteArray.push(r << 16 | g << 8 | b);\r\n    }\r\n    return paletteArray;\r\n}\r\n/**\r\n * FileBlobdataURL\r\n * https://github.com/yahoo/gifshot/blob/master/src/gifshot.js\r\n *\r\n * @param {ImageData} imageData\r\n * @param {number} width\r\n * @param {number} height\r\n * @param {number} sampleInterval\r\n * @returns {Array} PromisedataURL\r\n */\r\nfunction processFrameWithQuantizer(imageData, width, height, sampleInterval) {\r\n    let rgbComponents = imageDataToRGB(Array.prototype.slice.call(imageData.data), width, height);\r\n    let numberPixels = width * height;\r\n    let nq = NeuQuant(rgbComponents, rgbComponents.length, sampleInterval);\r\n    let paletteRGBnq = nq.process();\r\n    let paletteArray = [];\r\n    // Check line 1135, gifshot.js.\r\n    paletteArray = new Uint32Array(componentizedPaletteToArray(paletteRGBnq));\r\n    let indexedPixels = new Uint8Array(numberPixels);\r\n    let k = 0;\r\n    for (let i = 0; i < numberPixels; i++) {\r\n        let r = rgbComponents[k++];\r\n        let g = rgbComponents[k++];\r\n        let b = rgbComponents[k++];\r\n        indexedPixels[i] = nq.map(r, g, b);\r\n    }\r\n    return {\r\n        pixels: indexedPixels,\r\n        palette: paletteArray\r\n    };\r\n}\r\n\n// CONCATENATED MODULE: ./src/urltoBlob.ts\n/**\r\n * urlFileBlob\r\n *\r\n * @param {string} url - URL\r\n * @returns {Promise(Blob)}\r\n *\r\n */\r\nfunction urltoBlob(url) {\r\n    return fetch(url).then(response => response.blob());\r\n}\r\n;\r\n\n// CONCATENATED MODULE: ./src/imagetoCanvas.ts\nvar imagetoCanvas_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\nfunction scaleImageData(imageData, scale_x, scale_y) {\r\n    let canvas = document.createElement(\'canvas\');\r\n    canvas.width = imageData.width;\r\n    canvas.height = imageData.height;\r\n    let context = canvas.getContext(\'2d\');\r\n    context.putImageData(imageData, 0, 0);\r\n    let tmpCanvas = document.createElement(\'canvas\');\r\n    tmpCanvas.width = imageData.width * scale_x;\r\n    tmpCanvas.height = imageData.height * scale_y;\r\n    let tmpCtx = tmpCanvas.getContext(\'2d\');\r\n    tmpCtx.scale(scale_x, scale_y);\r\n    tmpCtx.drawImage(canvas, 0, 0, canvas.width, canvas.height);\r\n    return tmpCtx.getImageData(0, 0, tmpCanvas.width, tmpCanvas.height);\r\n}\r\n/**\r\n * imagecanvas\r\n *\r\n * @param {image} image\r\n *\r\n * @typedef {Object=} config - canvas\r\n * \t\t@param {number} width - canvasimage\r\n * \t\t@param {number} height - canvasimage\r\n * \t\t@param {number} scale - image0-10\r\n * \t\t\tconfig.scaleconfig.widthconfig.height\r\n * \t\t@param {number} orientation - \r\n * \t\t\t\t \r\n * \t\t\t1\t\t0\r\n * \t\t\t2\t\t\r\n * \t\t\t3\t\t180\r\n * \t\t\t4\t\t\r\n * \t\t\t5\t\t90+\r\n * \t\t\t6\t\t90\r\n * \t\t\t7\t\t90+\r\n * \t\t\t8\t\t90\r\n * @type {config}\r\n *\r\n * @returns {Promise(canvas)}\r\n */\r\nfunction imagetoCanvas(image, config = {}) {\r\n    return imagetoCanvas_awaiter(this, void 0, void 0, function* () {\r\n        const myConfig = Object.assign({}, config);\r\n        const cvs = document.createElement(\'canvas\');\r\n        const ctx = cvs.getContext(\'2d\');\r\n        let height;\r\n        let width;\r\n        for (const i in myConfig) {\r\n            if (Object.prototype.hasOwnProperty.call(myConfig, i)) {\r\n                myConfig[i] = Number(myConfig[i]);\r\n            }\r\n        }\r\n        // \r\n        if (!myConfig.scale) {\r\n            width = myConfig.width || myConfig.height * image.width / image.height || image.width;\r\n            height = myConfig.height || myConfig.width * image.height / image.width || image.height;\r\n        }\r\n        else {\r\n            // 0-10\r\n            const scale = myConfig.scale > 0 && myConfig.scale < 10 ? myConfig.scale : 1;\r\n            width = Math.floor(image.width * scale);\r\n            height = Math.floor(image.height * scale);\r\n        }\r\n        // GIF read/write.\r\n        let blob = yield urltoBlob(image.src);\r\n        if (blob.type == "image/gif") {\r\n            let buf = new Uint8Array(yield blob.arrayBuffer());\r\n            let reader = new omggif["GifReader"](buf);\r\n            let gifOptions = {\r\n                loop: reader.loopCount(),\r\n            };\r\n            let writtenBuf = new Uint8Array(width * height * reader.numFrames() * 5);\r\n            let writer = new omggif["GifWriter"](writtenBuf, width, height, gifOptions);\r\n            let imageDatas = new Array(reader.numFrames());\r\n            for (let k = 0; k < imageDatas.length; k++) {\r\n                let image = new ImageData(reader.width, reader.height);\r\n                let frameInfo = reader.frameInfo(k);\r\n                if (k > 0 && frameInfo.disposal < 2) {\r\n                    image.data.set(new Uint8ClampedArray(imageDatas[k - 1].data));\r\n                }\r\n                reader.decodeAndBlitFrameRGBA(k, image.data);\r\n                imageDatas[k] = image;\r\n            }\r\n            ;\r\n            // Write\r\n            imageDatas.map((image, k) => {\r\n                let frameInfo = reader.frameInfo(k);\r\n                image = scaleImageData(image, width / reader.width, height / reader.height);\r\n                let frameNq = processFrameWithQuantizer(image, width, height, 10);\r\n                let frameOptions = {\r\n                    palette: Array.prototype.slice.call(frameNq.palette),\r\n                    delay: frameInfo.delay,\r\n                    disposal: frameInfo.disposal,\r\n                };\r\n                writer.addFrame(0, 0, width, height, frameNq.pixels, frameOptions);\r\n            });\r\n            let base64Png = imageDatas.map((imageData, k) => {\r\n                let canvas = document.createElement(\'canvas\');\r\n                canvas.width = width;\r\n                canvas.height = height;\r\n                let context = canvas.getContext(\'2d\');\r\n                context.putImageData(imageData, 0, 0);\r\n                return canvas.toDataURL("image/png");\r\n            });\r\n            console.log(base64Png);\r\n            writer.end();\r\n            let bufStr = bufferToString(writtenBuf);\r\n            let gif = `data:image/gif;base64,${btoa(bufStr)}`;\r\n            console.log(gif);\r\n        }\r\n        // 90canvas\r\n        if ([5, 6, 7, 8].some(i => i === myConfig.orientation)) {\r\n            cvs.height = width;\r\n            cvs.width = height;\r\n        }\r\n        else {\r\n            cvs.height = height;\r\n            cvs.width = width;\r\n        }\r\n        // \r\n        switch (myConfig.orientation) {\r\n            case 3:\r\n                ctx.rotate(180 * Math.PI / 180);\r\n                ctx.drawImage(image, -cvs.width, -cvs.height, cvs.width, cvs.height);\r\n                break;\r\n            case 6:\r\n                ctx.rotate(90 * Math.PI / 180);\r\n                ctx.drawImage(image, 0, -cvs.width, cvs.height, cvs.width);\r\n                break;\r\n            case 8:\r\n                ctx.rotate(270 * Math.PI / 180);\r\n                ctx.drawImage(image, -cvs.height, 0, cvs.height, cvs.width);\r\n                break;\r\n            case 2:\r\n                ctx.translate(cvs.width, 0);\r\n                ctx.scale(-1, 1);\r\n                ctx.drawImage(image, 0, 0, cvs.width, cvs.height);\r\n                break;\r\n            case 4:\r\n                ctx.translate(cvs.width, 0);\r\n                ctx.scale(-1, 1);\r\n                ctx.rotate(180 * Math.PI / 180);\r\n                ctx.drawImage(image, -cvs.width, -cvs.height, cvs.width, cvs.height);\r\n                break;\r\n            case 5:\r\n                ctx.translate(cvs.width, 0);\r\n                ctx.scale(-1, 1);\r\n                ctx.rotate(90 * Math.PI / 180);\r\n                ctx.drawImage(image, 0, -cvs.width, cvs.height, cvs.width);\r\n                break;\r\n            case 7:\r\n                ctx.translate(cvs.width, 0);\r\n                ctx.scale(-1, 1);\r\n                ctx.rotate(270 * Math.PI / 180);\r\n                ctx.drawImage(image, -cvs.height, 0, cvs.height, cvs.width);\r\n                break;\r\n            default:\r\n                ctx.drawImage(image, 0, 0, cvs.width, cvs.height);\r\n        }\r\n        return cvs;\r\n    });\r\n}\r\n;\r\nlet byteMap = [];\r\nfor (let i = 0; i < 256; i++) {\r\n    byteMap[i] = String.fromCharCode(i);\r\n}\r\nfunction bufferToString(buffer) {\r\n    let numberValues = buffer.length;\r\n    let str = \'\';\r\n    let x = -1;\r\n    while (++x < numberValues) {\r\n        str += byteMap[buffer[x]];\r\n    }\r\n    return str;\r\n}\r\n\n// CONCATENATED MODULE: ./src/urltoImage.ts\n/**\r\n * urlimage\r\n *\r\n * @param {string} url - URL\r\n * @returns {Promise(Image)}\r\n */\r\nfunction urltoImage(url) {\r\n    return new Promise((resolve, reject) => {\r\n        const img = new Image();\r\n        img.onload = () => resolve(img);\r\n        img.onerror = () => reject(new Error(\'urltoImage(): Image failed to load, please check the image URL\'));\r\n        img.src = url;\r\n    });\r\n}\r\n;\r\n\n// CONCATENATED MODULE: ./src/index.ts\nvar src_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * FileBlob\r\n * @param {Blob} file - FileBlob\r\n * @param {(number|object)} config - number 0-1,0.92object\r\n * @example\r\n * \t\timageConversion.compress(file,0.8)\r\n *\r\n * \t\timageConversion.compress(file,{\r\n * \t\t\tquality: 0.8, //\r\n * \t\t\ttype"image/png", // "image/png", "image/jpeg", "image/gif"\r\n * \t\t\twidth: 300, //\r\n * \t\t\theight200 //\r\n * \t\t\tscale: 0.5 //,config.scaleconfig.widthconfig.height\r\n * \t\t\torientation:2, //\r\n * \t\t})\r\n *\r\n * @returns {Promise(Blob)}\r\n */\r\nfunction compress(file, config = {}) {\r\n    return src_awaiter(this, void 0, void 0, function* () {\r\n        if (!(file instanceof Blob)) {\r\n            throw new Error(\'compress(): First arg must be a Blob object or a File object.\');\r\n        }\r\n        if (typeof config !== \'object\') {\r\n            config = Object.assign({\r\n                quality: config,\r\n            });\r\n        }\r\n        config.quality = Number(config.quality);\r\n        if (Number.isNaN(config.quality)) {\r\n            return file;\r\n        }\r\n        const dataURL = yield filetoDataURL(file);\r\n        let originalMime = dataURL.split(\',\')[0].match(/:(.*?);/)[1]; // \r\n        let mime = EImageType.JPEG; // \r\n        if (checkImageType(config.type)) {\r\n            mime = config.type;\r\n            originalMime = config.type;\r\n        }\r\n        const image = yield dataURLtoImage(dataURL);\r\n        const canvas = yield imagetoCanvas(image, Object.assign({}, config));\r\n        const compressDataURL = yield canvastoDataURL(canvas, config.quality, mime);\r\n        const compressFile = yield dataURLtoFile(compressDataURL, originalMime);\r\n        if (compressFile.size > file.size) {\r\n            return file;\r\n        }\r\n        return compressFile;\r\n    });\r\n}\r\n;\r\n/**\r\n * FileBlob\r\n *\r\n * @param {Blob} file - FileBlob\r\n * @param {(number|object)} config - number,Kb;object\r\n * \t\t@param {number} size - ,Kb\r\n * \t\t@param {number} accuracy - 0.8-0.990.95\r\n *         1000Kb,0.9900Kb-1100Kb\r\n * @example\r\n *  \timageConversion.compress(file,100) //100kb\r\n *\r\n * \t\timageConversion.compress(file,{\r\n * \t\t\tsize: 100, //Kb\r\n * \t\t\taccuracy: 0.9, //0.95\r\n * \t\t\ttype"image/png", // "image/png", "image/jpeg", "image/gif"\r\n * \t\t\twidth: 300, //\r\n * \t\t\theight: 200, //\r\n * \t\t\tscale: 0.5, //,config.scaleconfig.widthconfig.height\r\n * \t\t\torientation:2, //\r\n * \t\t})\r\n *\r\n * @returns {Promise(Blob)}\r\n */\r\nfunction compressAccurately(file, config = {}) {\r\n    return src_awaiter(this, void 0, void 0, function* () {\r\n        if (!(file instanceof Blob)) {\r\n            throw new Error(\'compressAccurately(): First arg must be a Blob object or a File object.\');\r\n        }\r\n        if (typeof config !== \'object\') {\r\n            config = Object.assign({\r\n                size: config,\r\n            });\r\n        }\r\n        // \r\n        config.size = Number(config.size);\r\n        if (Number.isNaN(config.size)) {\r\n            return file;\r\n        }\r\n        // \r\n        if (config.size * 1024 > file.size) {\r\n            return file;\r\n        }\r\n        config.accuracy = Number(config.accuracy);\r\n        if (!config.accuracy\r\n            || config.accuracy < 0.8\r\n            || config.accuracy > 0.99) {\r\n            config.accuracy = 0.95; // 0.95\r\n        }\r\n        const resultSize = {\r\n            max: config.size * (2 - config.accuracy) * 1024,\r\n            accurate: config.size * 1024,\r\n            min: config.size * config.accuracy * 1024,\r\n        };\r\n        const dataURL = yield filetoDataURL(file);\r\n        let originalMime = dataURL.split(\',\')[0].match(/:(.*?);/)[1]; // \r\n        let mime = EImageType.JPEG;\r\n        if (checkImageType(config.type)) {\r\n            mime = config.type;\r\n            originalMime = config.type;\r\n        }\r\n        const image = yield dataURLtoImage(dataURL);\r\n        const canvas = yield imagetoCanvas(image, Object.assign({}, config));\r\n        /**\r\n         * blob.sizedataURL.length0.75\r\n         * dataURLtoFile\r\n         * blob.size\r\n         */\r\n        const proportion = 0.75;\r\n        let imageQuality = 0.5;\r\n        let compressDataURL;\r\n        const tempDataURLs = [null, null];\r\n        /**\r\n         * HTMLCanvasElement.toBlob()HTMLCanvasElement.toDataURL()\r\n         * 0.01271287\r\n         */\r\n        for (let x = 1; x <= 7; x++) {\r\n            compressDataURL = yield canvastoDataURL(canvas, imageQuality, mime);\r\n            const CalculationSize = compressDataURL.length * proportion;\r\n            // \r\n            // dataURLdataURL\r\n            if (x === 7) {\r\n                if (resultSize.max < CalculationSize || resultSize.min > CalculationSize) {\r\n                    compressDataURL = [compressDataURL, ...tempDataURLs]\r\n                        .filter(i => i) // null\r\n                        .sort((a, b) => Math.abs(a.length * proportion - resultSize.accurate)\r\n                        - Math.abs(b.length * proportion - resultSize.accurate))[0];\r\n                }\r\n                break;\r\n            }\r\n            if (resultSize.max < CalculationSize) {\r\n                tempDataURLs[1] = compressDataURL;\r\n                imageQuality -= Math.pow(0.5, (x + 1));\r\n            }\r\n            else if (resultSize.min > CalculationSize) {\r\n                tempDataURLs[0] = compressDataURL;\r\n                imageQuality += Math.pow(0.5, (x + 1));\r\n            }\r\n            else {\r\n                break;\r\n            }\r\n        }\r\n        const compressFile = yield dataURLtoFile(compressDataURL, originalMime);\r\n        // \r\n        if (compressFile.size > file.size) {\r\n            return file;\r\n        }\r\n        return compressFile;\r\n    });\r\n}\r\n;\r\n\r\n\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbWFnZUNvbnZlcnNpb24vLi9zcmMvbW9kZWxzL2luZGV4LnRzPzBkNTkiLCJ3ZWJwYWNrOi8vaW1hZ2VDb252ZXJzaW9uLy4vc3JjL3V0aWxzL2NoZWNrSW1hZ2VUeXBlLnRzPzhhYTYiLCJ3ZWJwYWNrOi8vaW1hZ2VDb252ZXJzaW9uLy4vc3JjL3V0aWxzL2luZGV4LnRzP2QyNTciLCJ3ZWJwYWNrOi8vaW1hZ2VDb252ZXJzaW9uLy4vc3JjL2NhbnZhc3RvRGF0YVVSTC50cz81ZjU0Iiwid2VicGFjazovL2ltYWdlQ29udmVyc2lvbi8uL3NyYy9jYW52YXN0b0ZpbGUudHM/OTA4OSIsIndlYnBhY2s6Ly9pbWFnZUNvbnZlcnNpb24vLi9zcmMvZGF0YVVSTHRvRmlsZS50cz84NTRkIiwid2VicGFjazovL2ltYWdlQ29udmVyc2lvbi8uL3NyYy9kYXRhVVJMdG9JbWFnZS50cz82MDJkIiwid2VicGFjazovL2ltYWdlQ29udmVyc2lvbi8uL3NyYy9kb3dubG9hZEZpbGUudHM/YTRlZSIsIndlYnBhY2s6Ly9pbWFnZUNvbnZlcnNpb24vLi9zcmMvZmlsZXRvRGF0YVVSTC50cz8xNGNhIiwid2VicGFjazovL2ltYWdlQ29udmVyc2lvbi8uL3NyYy9uZXVxdWFudC5qcz84MjBmIiwid2VicGFjazovL2ltYWdlQ29udmVyc2lvbi8uL3NyYy9pbWFnZURhdGFUb1JHQi50cz8xMmI2Iiwid2VicGFjazovL2ltYWdlQ29udmVyc2lvbi8uL3NyYy9wcm9jZXNzRnJhbWVXaXRoUXVhbnRpemVyLnRzPzdmZTIiLCJ3ZWJwYWNrOi8vaW1hZ2VDb252ZXJzaW9uLy4vc3JjL3VybHRvQmxvYi50cz8wYjg2Iiwid2VicGFjazovL2ltYWdlQ29udmVyc2lvbi8uL3NyYy9pbWFnZXRvQ2FudmFzLnRzPzhmMDciLCJ3ZWJwYWNrOi8vaW1hZ2VDb252ZXJzaW9uLy4vc3JjL3VybHRvSW1hZ2UudHM/MTZhYyIsIndlYnBhY2s6Ly9pbWFnZUNvbnZlcnNpb24vLi9z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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLGFBQWE7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsYUFBYTs7QUFFOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHOztBQzFoQkE7Ozs7O0dBS0c7QUFDWSxTQUFTLGNBQWMsQ0FBQyxJQUFRLEVBQUUsS0FBYSxFQUFFLE1BQWM7SUFDNUUsSUFBSSxNQUFNLEdBQUcsS0FBSyxHQUFHLE1BQU0sR0FBRyxDQUFDLENBQUM7SUFDaEMsSUFBSSxDQUFDLEdBQUcs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QUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsR0FBRyxDQUFDLEtBQUssRUFBRSxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUM7Z0JBQ2xELE1BQU07WUFDUixLQUFLLENBQUM7Z0JBQ0osR0FBRyxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQyxDQUFDO2dCQUM1QixHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO2dCQUNqQixHQUFHLENBQUMsTUFBTSxDQUFDLEdBQUcsR0FBRyxJQUFJLENBQUMsRUFBRSxHQUFHLEdBQUcsQ0FBQyxDQUFDO2dCQUNoQyxHQUFHLENBQUMsU0FBUyxDQUFDLEtBQUssRUFBRSxDQUFDLEdBQUcsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxHQUFHLENBQUMsTUFBTSxFQUFFLEdBQUcsQ0FBQyxLQUFLLEVBQUUsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDO2dCQUNyRSxNQUFNO1lBQ1IsS0FBSyxDQUFDO2dCQUNKLEdBQUcsQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUMsQ0FBQztnQkFDNUIsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztnQkFDakIsR0FBRyxDQUFDLE1BQU0sQ0FBQyxFQUFFLEdBQUcsSUFBSSxDQUFDLEVBQUUsR0FBRyxHQUFHLENBQUMsQ0FBQztnQkFDL0IsR0FBRyxDQUFDLFNBQVMsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxFQUFFLENBQUMsR0FBRyxDQUFDLEtBQUssRUFBRSxHQUFHLENBQUMsTUFBTSxFQUFFLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQztnQkFDM0QsTUFBTTtZQUNSLEtBQUssQ0FBQztnQkFDSixHQUFHLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDLENBQUM7Z0JBQzVCLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7Z0JB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QUMsQ0FBQyxNQUFNLEdBQUcsVUFBVSxHQUFHLFVBQVUsQ0FBQyxRQUFRLENBQUM7MEJBQ2pFLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLE1BQU0sR0FBRyxVQUFVLEdBQUcsVUFBVSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7aUJBQ2pFO2dCQUNELE1BQU07YUFDUDtZQUNELElBQUksVUFBVSxDQUFDLEdBQUcsR0FBRyxlQUFlLEVBQUU7Z0JBQ3BDLFlBQVksQ0FBQyxDQUFDLENBQUMsR0FBRyxlQUFlLENBQUM7Z0JBQ2xDLFlBQVksSUFBSSxZQUFHLEVBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUM7YUFDaEM7aUJBQU0sSUFBSSxVQUFVLENBQUMsR0FBRyxHQUFHLGVBQWUsRUFBRTtnQkFDM0MsWUFBWSxDQUFDLENBQUMsQ0FBQyxHQUFHLGVBQWUsQ0FBQztnQkFDbEMsWUFBWSxJQUFJLFlBQUcsRUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBQzthQUNoQztpQkFBTTtnQkFDTCxNQUFNO2FBQ1A7U0FDRjtRQUNELE1BQU0sWUFBWSxHQUFHLE1BQU0sYUFBYSxDQUFDLGVBQWUsRUFBRSxZQUFZLENBQUMsQ0FBQztRQUN4RSx5QkFBeUI7UUFDekIsSUFBSSxZQUFZLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQyxJQUFJLEVBQUU7WUFDakMsT0FBTyxJQUFJLENBQUM7U0FDYjtRQUNELE9BQU8sWUFBWSxDQUFDO0lBQ3RCLENBQUM7Q0FBQTtBQUFBLENBQUM7QUFjQTtBQUlBIiwiZmlsZSI6IjEuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZW51bSBFSW1hZ2VUeXBlIHtcclxuICAnUE5HJyA9ICdpbWFnZS9wbmcnLFxyXG4gICdKUEVHJyA9ICdpbWFnZS9qcGVnJyxcclxuICAnR0lGJyA9ICdpbWFnZS9naWYnXHJcbn1cclxuXHJcbmludGVyZmFjZSBJQmFzZUNvbmZpZyB7XHJcbiAgW2tleTogc3RyaW5nXTogYW55O1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEltYWdlMkNhbnZhc0NvbmZpZyBleHRlbmRzIElCYXNlQ29uZmlnIHtcclxuICB3aWR0aD86IG51bWJlcixcclxuICBoZWlnaHQ/OiBudW1iZXIsXHJcbiAgc2NhbGU/OiBudW1iZXIsXHJcbiAgb3JpZW50YXRpb24/OiBudW1iZXIsXHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgSUNvbXByZXNzQ29uZmlnIGV4dGVuZHMgSW1hZ2UyQ2FudmFzQ29uZmlnIHtcclxuICBxdWFsaXR5PzogbnVtYmVyLFxyXG4gIHR5cGU/OiBFSW1hZ2VUeXBlLFxyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIGNvbXByZXNzQWNjdXJhdGVseUNvbmZpZyBleHRlbmRzIEltYWdlMkNhbnZhc0NvbmZpZyB7XHJcbiAgc2l6ZT86IG51bWJlcixcclxuICBhY2N1cmFjeT86IG51bWJlcixcclxuICB0eXBlPzogRUltYWdlVHlwZSxcclxufSIsImltcG9ydCB7IEVJbWFnZVR5cGUgfSBmcm9tICdAbW9kZWxzJztcclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY2hlY2tJbWFnZVR5cGUodHlwZTogRUltYWdlVHlwZSkge1xyXG4gIHJldHVybiBbJ2ltYWdlL3BuZycsICdpbWFnZS9qcGVnJywgJ2ltYWdlL2dpZiddLnNvbWUoaSA9PiBpID09PSB0eXBlKTtcclxufSIsImltcG9ydCBjaGVja0ltYWdlVHlwZSBmcm9tICcuL2NoZWNrSW1hZ2VUeXBlJztcclxuXHJcbmV4cG9ydCB7XHJcbiAgY2hlY2tJbWFnZVR5cGVcclxufTsiLCJpbXBvcnQgeyBFSW1hZ2VUeXBlIH0gZnJvbSAnQG1vZGVscyc7XHJcbmltcG9ydCB7IGNoZWNrSW1hZ2VUeXBlIH0gZnJvbSAnQHV0aWxzJztcclxuXHJcbi8qKlxyXG4gKiDlsIbkuIDkuKpDYW52YXPlr7nosaHovazlj5jkuLrkuIDkuKpkYXRhVVJM5a2X56ym5LiyXHJcbiAqIOivpeaWueazleWPr+S7peWBmuWOi+e8qeWkhOeQhlxyXG4gKlxyXG4gKiBAcGFyYW0ge2NhbnZhc30gY2FudmFzXHJcbiAqIEBwYXJhbSB7bnVtYmVyPX0gcXVhbGl0eSAtIOS8oOWFpeiMg+WbtCAwLTHvvIzooajnpLrlm77niYfljovnvKnotKjph4/vvIzpu5jorqQwLjkyXHJcbiAqIEBwYXJhbSB7c3RyaW5nPX0gdHlwZSAtIOehruWumui9rOaNouWQjueahOWbvueJh+exu+Wei++8jOmAiemhueaciSBcImltYWdlL3BuZ1wiLCBcImltYWdlL2pwZWdcIiwgXCJpbWFnZS9naWZcIizpu5jorqRcImltYWdlL2pwZWdcIlxyXG4gKiBAcmV0dXJucyB7UHJvbWlzZShzdHJpbmcpfSBQcm9taXNl5ZCr5pyJ5LiA5LiqZGF0YVVSTOWtl+espuS4suWPguaVsFxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gY2FudmFzdG9EYXRhVVJMKGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQsIHF1YWxpdHk6IG51bWJlciA9IDAuOTIsIHR5cGU6IEVJbWFnZVR5cGUgPSBFSW1hZ2VUeXBlLkpQRUcpOiBQcm9taXNlPHN0cmluZz4ge1xyXG4gIGlmICghY2hlY2tJbWFnZVR5cGUodHlwZSkpIHtcclxuICAgIHR5cGUgPSBFSW1hZ2VUeXBlLkpQRUc7XHJcbiAgfVxyXG4gIHJldHVybiBjYW52YXMudG9EYXRhVVJMKHR5cGUsIHF1YWxpdHkpO1xyXG59OyIsImltcG9ydCB7IEVJbWFnZVR5cGUgfSBmcm9tICdAbW9kZWxzJztcclxuXHJcbi8qKlxyXG4gKiDlsIbkuIDkuKpjYW52YXPlr7nosaHovazlj5jkuLrkuIDkuKpGaWxl77yIQmxvYu+8ieWvueixoVxyXG4gKiDor6Xmlrnms5Xlj6/ku6XlgZrljovnvKnlpITnkIZcclxuICpcclxuICogQHBhcmFtIHtjYW52YXN9IGNhbnZhc1xyXG4gKiBAcGFyYW0ge251bWJlcj19IHF1YWxpdHkgLSDkvKDlhaXojIPlm7QgMC0x77yM6KGo56S65Zu+54mH5Y6L57yp6LSo6YeP77yM6buY6K6kMC45MlxyXG4gKiBAcGFyYW0ge3N0cmluZz19IHR5cGUgLSDnoa7lrprovazmjaLlkI7nmoTlm77niYfnsbvlnovvvIzpgInpobnmnIkgXCJpbWFnZS9wbmdcIiwgXCJpbWFnZS9qcGVnXCIsIFwiaW1hZ2UvZ2lmXCIs6buY6K6kXCJpbWFnZS9qcGVnXCJcclxuICogQHJldHVybnMge1Byb21pc2UoQmxvYil9XHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjYW52YXN0b0ZpbGUoY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCwgcXVhbGl0eTogbnVtYmVyID0gMC45MiwgdHlwZTogRUltYWdlVHlwZSA9IEVJbWFnZVR5cGUuSlBFRyk6IFByb21pc2U8QmxvYj4ge1xyXG4gIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IGNhbnZhcy50b0Jsb2IoYmxvYiA9PiByZXNvbHZlKGJsb2IpLCB0eXBlLCBxdWFsaXR5KSk7XHJcbn07XHJcbiIsImltcG9ydCB7IEVJbWFnZVR5cGUgfSBmcm9tICdAbW9kZWxzJztcclxuaW1wb3J0IHsgY2hlY2tJbWFnZVR5cGUgfSBmcm9tICdAdXRpbHMnO1xyXG5cclxuLyoqXHJcbiAqIOWwhuS4gOS4qmRhdGFVUkzlrZfnrKbkuLLovazlj5jkuLrkuIDkuKpGaWxl77yIQmxvYu+8ieWvueixoVxyXG4gKiDovazlj5jml7blj6/ku6Xnoa7lrppGaWxl5a+56LGh55qE57G75Z6LXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhVVJMXHJcbiAqIEBwYXJhbSB7c3RyaW5nPX0gdHlwZSAtIOehruWumui9rOaNouWQjueahOWbvueJh+exu+Wei++8jOmAiemhueaciSBcImltYWdlL3BuZ1wiLCBcImltYWdlL2pwZWdcIiwgXCJpbWFnZS9naWZcIlxyXG4gKiBAcmV0dXJucyB7UHJvbWlzZShCbG9iKX1cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIGRhdGFVUkx0b0ZpbGUoZGF0YVVSTDogc3RyaW5nLCB0eXBlOiBFSW1hZ2VUeXBlKTogUHJvbWlzZTxCbG9iPiB7XHJcbiAgY29uc3QgYXJyID0gZGF0YVVSTC5zcGxpdCgnLCcpO1xyXG4gIGxldCBtaW1lID0gYXJyWzBdLm1hdGNoKC86KC4qPyk7LylbMV07XHJcbiAgY29uc3QgYnN0ciA9IGF0b2IoYXJyWzFdKTtcclxuICBsZXQgbiA9IGJzdHIubGVuZ3RoO1xyXG4gIGNvbnN0IHU4YXJyID0gbmV3IFVpbnQ4QXJyYXkobik7XHJcbiAgd2hpbGUgKG4tLSkge1xyXG4gICAgdThhcnJbbl0gPSBic3RyLmNoYXJDb2RlQXQobik7XHJcbiAgfVxyXG4gIGlmIChjaGVja0ltYWdlVHlwZSh0eXBlKSkge1xyXG4gICAgbWltZSA9IHR5cGU7XHJcbiAgfVxyXG4gIHJldHVybiBuZXcgQmxvYihbdThhcnJdLCB7XHJcbiAgICB0eXBlOiBtaW1lLFxyXG4gIH0pO1xyXG59OyIsIi8qKlxyXG4gKiDlsIZkYXRhVVJM5a2X56ym5Liy6L2s5Y+Y5Li6aW1hZ2Xlr7nosaFcclxuICpcclxuICogQHBhcmFtIHtzcnRpbmd9IGRhdGFVUkwgLSBkYXRhVVJM5a2X56ym5LiyXHJcbiAqIEByZXR1cm5zIHtQcm9taXNlKEltYWdlKX1cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGRhdGFVUkx0b0ltYWdlKGRhdGFVUkw6IHN0cmluZyk6IFByb21pc2U8SFRNTEltYWdlRWxlbWVudD4ge1xyXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICBjb25zdCBpbWcgPSBuZXcgSW1hZ2UoKTtcclxuICAgIGltZy5vbmxvYWQgPSAoKSA9PiByZXNvbHZlKGltZyk7XHJcbiAgICBpbWcub25lcnJvciA9ICgpID0+IHJlamVjdChuZXcgRXJyb3IoJ2RhdGFVUkx0b0ltYWdlKCk6IGRhdGFVUkwgaXMgaWxsZWdhbCcpKTtcclxuICAgIGltZy5zcmMgPSBkYXRhVVJMO1xyXG4gIH0pO1xyXG59OyIsIi8qKlxyXG4gKiDlsIblm77niYfkuIvovb3liLDmnKzlnLBcclxuICpcclxuICogQHBhcmFtIHtCbG9ifSBmaWxlIC0g5LiA5LiqRmlsZe+8iEJsb2LvvInlr7nosaFcclxuICogQHBhcmFtIHtzdHJpbmc9fSBmaWxlTmFtZSAtIOS4i+i9veWQjueahOaWh+S7tuWQje+8iOWPr+mAieWPguaVsO+8jOS4jeS8oOS7peaXtumXtOaIs+WRveWQjeaWh+S7tu+8iVxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZG93bmxvYWRGaWxlKGZpbGU6IEZpbGUsIGZpbGVOYW1lOiBzdHJpbmcpOiB2b2lkIHtcclxuICBjb25zdCBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xyXG4gIGxpbmsuaHJlZiA9IHdpbmRvdy5VUkwuY3JlYXRlT2JqZWN0VVJMKGZpbGUpO1xyXG4gIGxpbmsuZG93bmxvYWQgPSBmaWxlTmFtZSB8fCBEYXRlLm5vdygpLnRvU3RyaW5nKDM2KTtcclxuICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGxpbmspO1xyXG4gIGNvbnN0IGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdNb3VzZUV2ZW50cycpO1xyXG4gIGV2dC5pbml0RXZlbnQoJ2NsaWNrJywgZmFsc2UsIGZhbHNlKTtcclxuICBsaW5rLmRpc3BhdGNoRXZlbnQoZXZ0KTtcclxuICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGxpbmspO1xyXG59O1xyXG4iLCIvKipcclxuICog5bCGRmlsZe+8iEJsb2LvvInlr7nosaHovazlj5jkuLrkuIDkuKpkYXRhVVJM5a2X56ym5LiyXHJcbiAqXHJcbiAqIEBwYXJhbSB7QmxvYn0gZmlsZVxyXG4gKiBAcmV0dXJucyB7UHJvbWlzZShzdHJpbmcpfSBQcm9taXNl5ZCr5pyJ5LiA5LiqZGF0YVVSTOWtl+espuS4suWPguaVsFxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZmlsZXRvRGF0YVVSTChmaWxlOiBCbG9iKTogUHJvbWlzZTxzdHJpbmc+IHtcclxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcclxuICAgIGNvbnN0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XHJcbiAgICByZWFkZXIub25sb2FkZW5kID0gZSA9PiByZXNvbHZlKGUudGFyZ2V0LnJlc3VsdCBhcyBzdHJpbmcpO1xyXG4gICAgcmVhZGVyLnJlYWRBc0RhdGFVUkwoZmlsZSk7XHJcbiAgfSk7XHJcbn07XHJcbiIsImV4cG9ydCBmdW5jdGlvbiBOZXVRdWFudCgpIHtcclxuICAgIHZhciBuZXRzaXplID0gMjU2OyAvLyBudW1iZXIgb2YgY29sb3VycyB1c2VkXHJcbiAgXHJcbiAgICAvLyBmb3VyIHByaW1lcyBuZWFyIDUwMCAtIGFzc3VtZSBubyBpbWFnZSBoYXMgYSBsZW5ndGggc28gbGFyZ2VcclxuICAgIC8vIHRoYXQgaXQgaXMgZGl2aXNpYmxlIGJ5IGFsbCBmb3VyIHByaW1lc1xyXG4gICAgdmFyIHByaW1lMSA9IDQ5OTtcclxuICAgIHZhciBwcmltZTIgPSA0OTE7XHJcbiAgICB2YXIgcHJpbWUzID0gNDg3O1xyXG4gICAgdmFyIHByaW1lNCA9IDUwMztcclxuICBcclxuICAgIC8vIG1pbmltdW0gc2l6ZSBmb3IgaW5wdXQgaW1hZ2VcclxuICAgIHZhciBtaW5waWN0dXJlYnl0ZXMgPSAzICogcHJpbWU0O1xyXG4gIFxyXG4gICAgLy8gTmV0d29yayBEZWZpbml0aW9uc1xyXG4gIFxyXG4gICAgdmFyIG1heG5ldHBvcyA9IG5ldHNpemUgLSAxO1xyXG4gICAgdmFyIG5ldGJpYXNzaGlmdCA9IDQ7IC8vIGJpYXMgZm9yIGNvbG91ciB2YWx1ZXNcclxuICAgIHZhciBuY3ljbGVzID0gMTAwOyAvLyBuby4gb2YgbGVhcm5pbmcgY3ljbGVzXHJcbiAgXHJcbiAgICAvLyBkZWZzIGZvciBmcmVxIGFuZCBiaWFzXHJcbiAgICB2YXIgaW50Ymlhc3NoaWZ0ID0gMTY7IC8vIGJpYXMgZm9yIGZyYWN0aW9uc1xyXG4gICAgdmFyIGludGJpYXMgPSAxIDw8IGludGJpYXNzaGlmdDtcclxuICAgIHZhciBnYW1tYXNoaWZ0ID0gMTA7IC8vIGdhbW1hID0gMTAyNFxyXG4gICAgdmFyIGdhbW1hID0gMSA8PCBnYW1tYXNoaWZ0O1xyXG4gICAgdmFyIGJldGFzaGlmdCA9IDEwO1xyXG4gICAgdmFyIGJldGEgPSBpbnRiaWFzID4+IGJldGFzaGlmdDsgLy8gYmV0YSA9IDEvMTAyNFxyXG4gICAgdmFyIGJldGFnYW1tYSA9IGludGJpYXMgPDwgZ2FtbWFzaGlmdCAtIGJldGFzaGlmdDtcclxuICBcclxuICAgIC8vIGRlZnMgZm9yIGRlY3JlYXNpbmcgcmFkaXVzIGZhY3RvclxyXG4gICAgLy8gRm9yIDI1NiBjb2xvcnMsIHJhZGl1cyBzdGFydHMgYXQgMzIuMCBiaWFzZWQgYnkgNiBiaXRzXHJcbiAgICAvLyBhbmQgZGVjcmVhc2VzIGJ5IGEgZmFjdG9yIG9mIDEvMzAgZWFjaCBjeWNsZVxyXG4gICAgdmFyIGluaXRyYWQgPSBuZXRzaXplID4+IDM7XHJcbiAgICB2YXIgcmFkaXVzYmlhc3NoaWZ0ID0gNjtcclxuICAgIHZhciByYWRpdXNiaWFzID0gMSA8PCByYWRpdXNiaWFzc2hpZnQ7XHJcbiAgICB2YXIgaW5pdHJhZGl1cyA9IGluaXRyYWQgKiByYWRpdXNiaWFzO1xyXG4gICAgdmFyIHJhZGl1c2RlYyA9IDMwO1xyXG4gIFxyXG4gICAgLy8gZGVmcyBmb3IgZGVjcmVhc2luZyBhbHBoYSBmYWN0b3JcclxuICAgIC8vIEFscGhhIHN0YXJ0cyBhdCAxLjAgYmlhc2VkIGJ5IDEwIGJpdHNcclxuICAgIHZhciBhbHBoYWJpYXNzaGlmdCA9IDEwO1xyXG4gICAgdmFyIGluaXRhbHBoYSA9IDEgPDwgYWxwaGFiaWFzc2hpZnQ7XHJcbiAgICB2YXIgYWxwaGFkZWM7XHJcbiAgXHJcbiAgICAvLyByYWRiaWFzIGFuZCBhbHBoYXJhZGJpYXMgdXNlZCBmb3IgcmFkcG93ZXIgY2FsY3VsYXRpb25cclxuICAgIHZhciByYWRiaWFzc2hpZnQgPSA4O1xyXG4gICAgdmFyIHJhZGJpYXMgPSAxIDw8IHJhZGJpYXNzaGlmdDtcclxuICAgIHZhciBhbHBoYXJhZGJzaGlmdCA9IGFscGhhYmlhc3NoaWZ0ICsgcmFkYmlhc3NoaWZ0O1xyXG4gICAgdmFyIGFscGhhcmFkYmlhcyA9IDEgPDwgYWxwaGFyYWRic2hpZnQ7XHJcbiAgXHJcbiAgICAvLyBJbnB1dCBpbWFnZVxyXG4gICAgdmFyIHRoZXBpY3R1cmU7XHJcbiAgICAvLyBIZWlnaHQgKiBXaWR0aCAqIDNcclxuICAgIHZhciBsZW5ndGhjb3VudDtcclxuICAgIC8vIFNhbXBsaW5nIGZhY3RvciAxLi4zMFxyXG4gICAgdmFyIHNhbXBsZWZhYztcclxuICBcclxuICAgIC8vIFRoZSBuZXR3b3JrIGl0c2VsZlxyXG4gICAgdmFyIG5ldHdvcms7XHJcbiAgICB2YXIgbmV0aW5kZXggPSBbXTtcclxuICBcclxuICAgIC8vIGZvciBuZXR3b3JrIGxvb2t1cCAtIHJlYWxseSAyNTZcclxuICAgIHZhciBiaWFzID0gW107XHJcbiAgXHJcbiAgICAvLyBiaWFzIGFuZCBmcmVxIGFycmF5cyBmb3IgbGVhcm5pbmdcclxuICAgIHZhciBmcmVxID0gW107XHJcbiAgICB2YXIgcmFkcG93ZXIgPSBbXTtcclxuICBcclxuICAgIGZ1bmN0aW9uIE5ldVF1YW50Q29uc3RydWN0b3IodGhlcGljLCBsZW4sIHNhbXBsZSkge1xyXG4gIFxyXG4gICAgICB2YXIgaTtcclxuICAgICAgdmFyIHA7XHJcbiAgXHJcbiAgICAgIHRoZXBpY3R1cmUgPSB0aGVwaWM7XHJcbiAgICAgIGxlbmd0aGNvdW50ID0gbGVuO1xyXG4gICAgICBzYW1wbGVmYWMgPSBzYW1wbGU7XHJcbiAgXHJcbiAgICAgIG5ldHdvcmsgPSBuZXcgQXJyYXkobmV0c2l6ZSk7XHJcbiAgXHJcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBuZXRzaXplOyBpKyspIHtcclxuICAgICAgICBuZXR3b3JrW2ldID0gbmV3IEFycmF5KDQpO1xyXG4gICAgICAgIHAgPSBuZXR3b3JrW2ldO1xyXG4gICAgICAgIHBbMF0gPSBwWzFdID0gcFsyXSA9IChpIDw8IG5ldGJpYXNzaGlmdCArIDgpIC8gbmV0c2l6ZSB8IDA7XHJcbiAgICAgICAgZnJlcVtpXSA9IGludGJpYXMgLyBuZXRzaXplIHwgMDsgLy8gMSAvIG5ldHNpemVcclxuICAgICAgICBiaWFzW2ldID0gMDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIFxyXG4gICAgZnVuY3Rpb24gY29sb3JNYXAoKSB7XHJcbiAgICAgIHZhciBtYXAgPSBbXTtcclxuICAgICAgdmFyIGluZGV4ID0gbmV3IEFycmF5KG5ldHNpemUpO1xyXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5ldHNpemU7IGkrKykge1xyXG4gICAgICAgIGluZGV4W25ldHdvcmtbaV1bM11dID0gaTtcclxuICAgICAgfXZhciBrID0gMDtcclxuICAgICAgZm9yICh2YXIgbCA9IDA7IGwgPCBuZXRzaXplOyBsKyspIHtcclxuICAgICAgICB2YXIgaiA9IGluZGV4W2xdO1xyXG4gICAgICAgIG1hcFtrKytdID0gbmV0d29ya1tqXVswXTtcclxuICAgICAgICBtYXBbaysrXSA9IG5ldHdvcmtbal1bMV07XHJcbiAgICAgICAgbWFwW2srK10gPSBuZXR3b3JrW2pdWzJdO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBtYXA7XHJcbiAgICB9XHJcbiAgXHJcbiAgICAvLyBJbnNlcnRpb24gc29ydCBvZiBuZXR3b3JrIGFuZCBidWlsZGluZyBvZiBuZXRpbmRleFswLi4yNTVdXHJcbiAgICAvLyAodG8gZG8gYWZ0ZXIgdW5iaWFzKVxyXG4gICAgZnVuY3Rpb24gaW54YnVpbGQoKSB7XHJcbiAgICAgIHZhciBpO1xyXG4gICAgICB2YXIgajtcclxuICAgICAgdmFyIHNtYWxscG9zO1xyXG4gICAgICB2YXIgc21hbGx2YWw7XHJcbiAgICAgIHZhciBwO1xyXG4gICAgICB2YXIgcTtcclxuICAgICAgdmFyIHByZXZpb3VzY29sO1xyXG4gICAgICB2YXIgc3RhcnRwb3M7XHJcbiAgXHJcbiAgICAgIHByZXZpb3VzY29sID0gMDtcclxuICAgICAgc3RhcnRwb3MgPSAwO1xyXG4gIFxyXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbmV0c2l6ZTsgaSsrKSB7XHJcbiAgXHJcbiAgICAgICAgcCA9IG5ldHdvcmtbaV07XHJcbiAgICAgICAgc21hbGxwb3MgPSBpO1xyXG4gICAgICAgIHNtYWxsdmFsID0gcFsxXTsgLy8gaW5kZXggb24gZ1xyXG4gICAgICAgIC8vIGZpbmQgc21hbGxlc3QgaW4gaS4ubmV0c2l6ZS0xXHJcbiAgICAgICAgZm9yIChqID0gaSArIDE7IGogPCBuZXRzaXplOyBqKyspIHtcclxuICBcclxuICAgICAgICAgIHEgPSBuZXR3b3JrW2pdO1xyXG4gIFxyXG4gICAgICAgICAgaWYgKHFbMV0gPCBzbWFsbHZhbCkge1xyXG4gICAgICAgICAgICAvLyBpbmRleCBvbiBnXHJcbiAgICAgICAgICAgIHNtYWxscG9zID0gajtcclxuICAgICAgICAgICAgc21hbGx2YWwgPSBxWzFdOyAvLyBpbmRleCBvbiBnXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gIFxyXG4gICAgICAgIHEgPSBuZXR3b3JrW3NtYWxscG9zXTtcclxuICBcclxuICAgICAgICAvLyBzd2FwIHAgKGkpIGFuZCBxIChzbWFsbHBvcykgZW50cmllc1xyXG4gICAgICAgIGlmIChpICE9IHNtYWxscG9zKSB7XHJcbiAgICAgICAgICBqID0gcVswXTtcclxuICAgICAgICAgIHFbMF0gPSBwWzBdO1xyXG4gICAgICAgICAgcFswXSA9IGo7XHJcbiAgICAgICAgICBqID0gcVsxXTtcclxuICAgICAgICAgIHFbMV0gPSBwWzFdO1xyXG4gICAgICAgICAgcFsxXSA9IGo7XHJcbiAgICAgICAgICBqID0gcVsyXTtcclxuICAgICAgICAgIHFbMl0gPSBwWzJdO1xyXG4gICAgICAgICAgcFsyXSA9IGo7XHJcbiAgICAgICAgICBqID0gcVszXTtcclxuICAgICAgICAgIHFbM10gPSBwWzNdO1xyXG4gICAgICAgICAgcFszXSA9IGo7XHJcbiAgICAgICAgfVxyXG4gIFxyXG4gICAgICAgIC8vIHNtYWxsdmFsIGVudHJ5IGlzIG5vdyBpbiBwb3NpdGlvbiBpXHJcbiAgICAgICAgaWYgKHNtYWxsdmFsICE9IHByZXZpb3VzY29sKSB7XHJcbiAgXHJcbiAgICAgICAgICBuZXRpbmRleFtwcmV2aW91c2NvbF0gPSBzdGFydHBvcyArIGkgPj4gMTtcclxuICBcclxuICAgICAgICAgIGZvciAoaiA9IHByZXZpb3VzY29sICsgMTsgaiA8IHNtYWxsdmFsOyBqKyspIHtcclxuICAgICAgICAgICAgbmV0aW5kZXhbal0gPSBpO1xyXG4gICAgICAgICAgfVxyXG4gIFxyXG4gICAgICAgICAgcHJldmlvdXNjb2wgPSBzbWFsbHZhbDtcclxuICAgICAgICAgIHN0YXJ0cG9zID0gaTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICBcclxuICAgICAgbmV0aW5kZXhbcHJldmlvdXNjb2xdID0gc3RhcnRwb3MgKyBtYXhuZXRwb3MgPj4gMTtcclxuICAgICAgZm9yIChqID0gcHJldmlvdXNjb2wgKyAxOyBqIDwgMjU2OyBqKyspIHtcclxuICAgICAgICBuZXRpbmRleFtqXSA9IG1heG5ldHBvczsgLy8gcmVhbGx5IDI1NlxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgXHJcbiAgICAvLyBNYWluIExlYXJuaW5nIExvb3BcclxuICBcclxuICAgIGZ1bmN0aW9uIGxlYXJuKCkge1xyXG4gICAgICB2YXIgaTtcclxuICAgICAgdmFyIGo7XHJcbiAgICAgIHZhciBiO1xyXG4gICAgICB2YXIgZztcclxuICAgICAgdmFyIHI7XHJcbiAgICAgIHZhciByYWRpdXM7XHJcbiAgICAgIHZhciByYWQ7XHJcbiAgICAgIHZhciBhbHBoYTtcclxuICAgICAgdmFyIHN0ZXA7XHJcbiAgICAgIHZhciBkZWx0YTtcclxuICAgICAgdmFyIHNhbXBsZXBpeGVscztcclxuICAgICAgdmFyIHA7XHJcbiAgICAgIHZhciBwaXg7XHJcbiAgICAgIHZhciBsaW07XHJcbiAgXHJcbiAgICAgIGlmIChsZW5ndGhjb3VudCA8IG1pbnBpY3R1cmVieXRlcykge1xyXG4gICAgICAgIHNhbXBsZWZhYyA9IDE7XHJcbiAgICAgIH1cclxuICBcclxuICAgICAgYWxwaGFkZWMgPSAzMCArIChzYW1wbGVmYWMgLSAxKSAvIDM7XHJcbiAgICAgIHAgPSB0aGVwaWN0dXJlO1xyXG4gICAgICBwaXggPSAwO1xyXG4gICAgICBsaW0gPSBsZW5ndGhjb3VudDtcclxuICAgICAgc2FtcGxlcGl4ZWxzID0gbGVuZ3RoY291bnQgLyAoMyAqIHNhbXBsZWZhYyk7XHJcbiAgICAgIGRlbHRhID0gc2FtcGxlcGl4ZWxzIC8gbmN5Y2xlcyB8IDA7XHJcbiAgICAgIGFscGhhID0gaW5pdGFscGhhO1xyXG4gICAgICByYWRpdXMgPSBpbml0cmFkaXVzO1xyXG4gIFxyXG4gICAgICByYWQgPSByYWRpdXMgPj4gcmFkaXVzYmlhc3NoaWZ0O1xyXG4gICAgICBpZiAocmFkIDw9IDEpIHtcclxuICAgICAgICByYWQgPSAwO1xyXG4gICAgICB9XHJcbiAgXHJcbiAgICAgIGZvciAoaSA9IDA7IGkgPCByYWQ7IGkrKykge1xyXG4gICAgICAgIHJhZHBvd2VyW2ldID0gYWxwaGEgKiAoKHJhZCAqIHJhZCAtIGkgKiBpKSAqIHJhZGJpYXMgLyAocmFkICogcmFkKSk7XHJcbiAgICAgIH1cclxuICBcclxuICAgICAgaWYgKGxlbmd0aGNvdW50IDwgbWlucGljdHVyZWJ5dGVzKSB7XHJcbiAgICAgICAgc3RlcCA9IDM7XHJcbiAgICAgIH0gZWxzZSBpZiAobGVuZ3RoY291bnQgJSBwcmltZTEgIT09IDApIHtcclxuICAgICAgICBzdGVwID0gMyAqIHByaW1lMTtcclxuICAgICAgfSBlbHNlIHtcclxuICBcclxuICAgICAgICBpZiAobGVuZ3RoY291bnQgJSBwcmltZTIgIT09IDApIHtcclxuICAgICAgICAgIHN0ZXAgPSAzICogcHJpbWUyO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBpZiAobGVuZ3RoY291bnQgJSBwcmltZTMgIT09IDApIHtcclxuICAgICAgICAgICAgc3RlcCA9IDMgKiBwcmltZTM7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBzdGVwID0gMyAqIHByaW1lNDtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICBcclxuICAgICAgaSA9IDA7XHJcbiAgXHJcbiAgICAgIHdoaWxlIChpIDwgc2FtcGxlcGl4ZWxzKSB7XHJcbiAgXHJcbiAgICAgICAgYiA9IChwW3BpeCArIDBdICYgMHhmZikgPDwgbmV0Ymlhc3NoaWZ0O1xyXG4gICAgICAgIGcgPSAocFtwaXggKyAxXSAmIDB4ZmYpIDw8IG5ldGJpYXNzaGlmdDtcclxuICAgICAgICByID0gKHBbcGl4ICsgMl0gJiAweGZmKSA8PCBuZXRiaWFzc2hpZnQ7XHJcbiAgICAgICAgaiA9IGNvbnRlc3QoYiwgZywgcik7XHJcbiAgXHJcbiAgICAgICAgYWx0ZXJzaW5nbGUoYWxwaGEsIGosIGIsIGcsIHIpO1xyXG4gIFxyXG4gICAgICAgIGlmIChyYWQgIT09IDApIHtcclxuICAgICAgICAgIC8vIEFsdGVyIG5laWdoYm91cnNcclxuICAgICAgICAgIGFsdGVybmVpZ2gocmFkLCBqLCBiLCBnLCByKTtcclxuICAgICAgICB9XHJcbiAgXHJcbiAgICAgICAgcGl4ICs9IHN0ZXA7XHJcbiAgXHJcbiAgICAgICAgaWYgKHBpeCA+PSBsaW0pIHtcclxuICAgICAgICAgIHBpeCAtPSBsZW5ndGhjb3VudDtcclxuICAgICAgICB9XHJcbiAgXHJcbiAgICAgICAgaSsrO1xyXG4gIFxyXG4gICAgICAgIGlmIChkZWx0YSA9PT0gMCkge1xyXG4gICAgICAgICAgZGVsdGEgPSAxO1xyXG4gICAgICAgIH1cclxuICBcclxuICAgICAgICBpZiAoaSAlIGRlbHRhID09PSAwKSB7XHJcbiAgICAgICAgICBhbHBoYSAtPSBhbHBoYSAvIGFscGhhZGVjO1xyXG4gICAgICAgICAgcmFkaXVzIC09IHJhZGl1cyAvIHJhZGl1c2RlYztcclxuICAgICAgICAgIHJhZCA9IHJhZGl1cyA+PiByYWRpdXNiaWFzc2hpZnQ7XHJcbiAgXHJcbiAgICAgICAgICBpZiAocmFkIDw9IDEpIHtcclxuICAgICAgICAgICAgcmFkID0gMDtcclxuICAgICAgICAgIH1cclxuICBcclxuICAgICAgICAgIGZvciAoaiA9IDA7IGogPCByYWQ7IGorKykge1xyXG4gICAgICAgICAgICByYWRwb3dlcltqXSA9IGFscGhhICogKChyYWQgKiByYWQgLSBqICogaikgKiByYWRiaWFzIC8gKHJhZCAqIHJhZCkpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIFxyXG4gICAgLy8gU2VhcmNoIGZvciBCR1IgdmFsdWVzIDAuLjI1NSAoYWZ0ZXIgbmV0IGlzIHVuYmlhc2VkKSBhbmQgcmV0dXJuIGNvbG91ciBpbmRleFxyXG4gICAgZnVuY3Rpb24gbWFwKGIsIGcsIHIpIHtcclxuICAgICAgdmFyIGk7XHJcbiAgICAgIHZhciBqO1xyXG4gICAgICB2YXIgZGlzdDtcclxuICAgICAgdmFyIGE7XHJcbiAgICAgIHZhciBiZXN0ZDtcclxuICAgICAgdmFyIHA7XHJcbiAgICAgIHZhciBiZXN0O1xyXG4gIFxyXG4gICAgICAvLyBCaWdnZXN0IHBvc3NpYmxlIGRpc3RhbmNlIGlzIDI1NiAqIDNcclxuICAgICAgYmVzdGQgPSAxMDAwO1xyXG4gICAgICBiZXN0ID0gLTE7XHJcbiAgICAgIGkgPSBuZXRpbmRleFtnXTsgLy8gaW5kZXggb24gZ1xyXG4gICAgICBqID0gaSAtIDE7IC8vIHN0YXJ0IGF0IG5ldGluZGV4W2ddIGFuZCB3b3JrIG91dHdhcmRzXHJcbiAgXHJcbiAgICAgIHdoaWxlIChpIDwgbmV0c2l6ZSB8fCBqID49IDApIHtcclxuICBcclxuICAgICAgICBpZiAoaSA8IG5ldHNpemUpIHtcclxuICBcclxuICAgICAgICAgIHAgPSBuZXR3b3JrW2ldO1xyXG4gIFxyXG4gICAgICAgICAgZGlzdCA9IHBbMV0gLSBnOyAvLyBpbngga2V5XHJcbiAgXHJcbiAgICAgICAgICBpZiAoZGlzdCA+PSBiZXN0ZCkge1xyXG4gICAgICAgICAgICBpID0gbmV0c2l6ZTsgLy8gc3RvcCBpdGVyXHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gIFxyXG4gICAgICAgICAgICBpKys7XHJcbiAgXHJcbiAgICAgICAgICAgIGlmIChkaXN0IDwgMCkge1xyXG4gICAgICAgICAgICAgIGRpc3QgPSAtZGlzdDtcclxuICAgICAgICAgICAgfVxyXG4gIFxyXG4gICAgICAgICAgICBhID0gcFswXSAtIGI7XHJcbiAgXHJcbiAgICAgICAgICAgIGlmIChhIDwgMCkge1xyXG4gICAgICAgICAgICAgIGEgPSAtYTtcclxuICAgICAgICAgICAgfVxyXG4gIFxyXG4gICAgICAgICAgICBkaXN0ICs9IGE7XHJcbiAgXHJcbiAgICAgICAgICAgIGlmIChkaXN0IDwgYmVzdGQpIHtcclxuICAgICAgICAgICAgICBhID0gcFsyXSAtIHI7XHJcbiAgXHJcbiAgICAgICAgICAgICAgaWYgKGEgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICBhID0gLWE7XHJcbiAgICAgICAgICAgICAgfVxyXG4gIFxyXG4gICAgICAgICAgICAgIGRpc3QgKz0gYTtcclxuICBcclxuICAgICAgICAgICAgICBpZiAoZGlzdCA8IGJlc3RkKSB7XHJcbiAgICAgICAgICAgICAgICBiZXN0ZCA9IGRpc3Q7XHJcbiAgICAgICAgICAgICAgICBiZXN0ID0gcFszXTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgXHJcbiAgICAgICAgaWYgKGogPj0gMCkge1xyXG4gIFxyXG4gICAgICAgICAgcCA9IG5ldHdvcmtbal07XHJcbiAgXHJcbiAgICAgICAgICBkaXN0ID0gZyAtIHBbMV07IC8vIGlueCBrZXkgLSByZXZlcnNlIGRpZlxyXG4gIFxyXG4gICAgICAgICAgaWYgKGRpc3QgPj0gYmVzdGQpIHtcclxuICAgICAgICAgICAgaiA9IC0xOyAvLyBzdG9wIGl0ZXJcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgXHJcbiAgICAgICAgICAgIGotLTtcclxuICAgICAgICAgICAgaWYgKGRpc3QgPCAwKSB7XHJcbiAgICAgICAgICAgICAgZGlzdCA9IC1kaXN0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGEgPSBwWzBdIC0gYjtcclxuICAgICAgICAgICAgaWYgKGEgPCAwKSB7XHJcbiAgICAgICAgICAgICAgYSA9IC1hO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGRpc3QgKz0gYTtcclxuICBcclxuICAgICAgICAgICAgaWYgKGRpc3QgPCBiZXN0ZCkge1xyXG4gICAgICAgICAgICAgIGEgPSBwWzJdIC0gcjtcclxuICAgICAgICAgICAgICBpZiAoYSA8IDApIHtcclxuICAgICAgICAgICAgICAgIGEgPSAtYTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgZGlzdCArPSBhO1xyXG4gICAgICAgICAgICAgIGlmIChkaXN0IDwgYmVzdGQpIHtcclxuICAgICAgICAgICAgICAgIGJlc3RkID0gZGlzdDtcclxuICAgICAgICAgICAgICAgIGJlc3QgPSBwWzNdO1xyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gIFxyXG4gICAgICByZXR1cm4gYmVzdDtcclxuICAgIH1cclxuICBcclxuICAgIGZ1bmN0aW9uIHByb2Nlc3MoKSB7XHJcbiAgICAgIGxlYXJuKCk7XHJcbiAgICAgIHVuYmlhc25ldCgpO1xyXG4gICAgICBpbnhidWlsZCgpO1xyXG4gICAgICByZXR1cm4gY29sb3JNYXAoKTtcclxuICAgIH1cclxuICBcclxuICAgIC8vIFVuYmlhcyBuZXR3b3JrIHRvIGdpdmUgYnl0ZSB2YWx1ZXMgMC4uMjU1IGFuZCByZWNvcmQgcG9zaXRpb24gaVxyXG4gICAgLy8gdG8gcHJlcGFyZSBmb3Igc29ydFxyXG4gICAgZnVuY3Rpb24gdW5iaWFzbmV0KCkge1xyXG4gICAgICB2YXIgaTtcclxuICAgICAgdmFyIGo7XHJcbiAgXHJcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBuZXRzaXplOyBpKyspIHtcclxuICAgICAgICBuZXR3b3JrW2ldWzBdID4+PSBuZXRiaWFzc2hpZnQ7XHJcbiAgICAgICAgbmV0d29ya1tpXVsxXSA+Pj0gbmV0Ymlhc3NoaWZ0O1xyXG4gICAgICAgIG5ldHdvcmtbaV1bMl0gPj49IG5ldGJpYXNzaGlmdDtcclxuICAgICAgICBuZXR3b3JrW2ldWzNdID0gaTsgLy8gcmVjb3JkIGNvbG91ciBub1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgXHJcbiAgICAvLyBNb3ZlIGFkamFjZW50IG5ldXJvbnMgYnkgcHJlY29tcHV0ZWQgYWxwaGEqKDEtKChpLWopXjIvW3JdXjIpKVxyXG4gICAgLy8gaW4gcmFkcG93ZXJbfGktanxdXHJcbiAgICBmdW5jdGlvbiBhbHRlcm5laWdoKHJhZCwgaSwgYiwgZywgcikge1xyXG4gIFxyXG4gICAgICB2YXIgajtcclxuICAgICAgdmFyIGs7XHJcbiAgICAgIHZhciBsbztcclxuICAgICAgdmFyIGhpO1xyXG4gICAgICB2YXIgYTtcclxuICAgICAgdmFyIG07XHJcbiAgXHJcbiAgICAgIHZhciBwO1xyXG4gIFxyXG4gICAgICBsbyA9IGkgLSByYWQ7XHJcbiAgICAgIGlmIChsbyA8IC0xKSB7XHJcbiAgICAgICAgbG8gPSAtMTtcclxuICAgICAgfVxyXG4gIFxyXG4gICAgICBoaSA9IGkgKyByYWQ7XHJcbiAgXHJcbiAgICAgIGlmIChoaSA+IG5ldHNpemUpIHtcclxuICAgICAgICBoaSA9IG5ldHNpemU7XHJcbiAgICAgIH1cclxuICBcclxuICAgICAgaiA9IGkgKyAxO1xyXG4gICAgICBrID0gaSAtIDE7XHJcbiAgICAgIG0gPSAxO1xyXG4gIFxyXG4gICAgICB3aGlsZSAoaiA8IGhpIHx8IGsgPiBsbykge1xyXG4gIFxyXG4gICAgICAgIGEgPSByYWRwb3dlclttKytdO1xyXG4gIFxyXG4gICAgICAgIGlmIChqIDwgaGkpIHtcclxuICBcclxuICAgICAgICAgIHAgPSBuZXR3b3JrW2orK107XHJcbiAgXHJcbiAgICAgICAgICB0cnkge1xyXG4gIFxyXG4gICAgICAgICAgICBwWzBdIC09IGEgKiAocFswXSAtIGIpIC8gYWxwaGFyYWRiaWFzIHwgMDtcclxuICAgICAgICAgICAgcFsxXSAtPSBhICogKHBbMV0gLSBnKSAvIGFscGhhcmFkYmlhcyB8IDA7XHJcbiAgICAgICAgICAgIHBbMl0gLT0gYSAqIChwWzJdIC0gcikgLyBhbHBoYXJhZGJpYXMgfCAwO1xyXG4gICAgICAgICAgfSBjYXRjaCAoZSkge31cclxuICAgICAgICB9XHJcbiAgXHJcbiAgICAgICAgaWYgKGsgPiBsbykge1xyXG4gIFxyXG4gICAgICAgICAgcCA9IG5ldHdvcmtbay0tXTtcclxuICBcclxuICAgICAgICAgIHRyeSB7XHJcbiAgXHJcbiAgICAgICAgICAgIHBbMF0gLT0gYSAqIChwWzBdIC0gYikgLyBhbHBoYXJhZGJpYXMgfCAwO1xyXG4gICAgICAgICAgICBwWzFdIC09IGEgKiAocFsxXSAtIGcpIC8gYWxwaGFyYWRiaWFzIHwgMDtcclxuICAgICAgICAgICAgcFsyXSAtPSBhICogKHBbMl0gLSByKSAvIGFscGhhcmFkYmlhcyB8IDA7XHJcbiAgICAgICAgICB9IGNhdGNoIChlKSB7fVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIFxyXG4gICAgLy8gTW92ZSBuZXVyb24gaSB0b3dhcmRzIGJpYXNlZCAoYixnLHIpIGJ5IGZhY3RvciBhbHBoYVxyXG4gICAgZnVuY3Rpb24gYWx0ZXJzaW5nbGUoYWxwaGEsIGksIGIsIGcsIHIpIHtcclxuICBcclxuICAgICAgLy8gYWx0ZXIgaGl0IG5ldXJvblxyXG4gICAgICB2YXIgbiA9IG5ldHdvcmtbaV07XHJcbiAgICAgIHZhciBhbHBoYU11bHQgPSBhbHBoYSAvIGluaXRhbHBoYTtcclxuICAgICAgblswXSAtPSBhbHBoYU11bHQgKiAoblswXSAtIGIpIHwgMDtcclxuICAgICAgblsxXSAtPSBhbHBoYU11bHQgKiAoblsxXSAtIGcpIHwgMDtcclxuICAgICAgblsyXSAtPSBhbHBoYU11bHQgKiAoblsyXSAtIHIpIHwgMDtcclxuICAgIH1cclxuICBcclxuICAgIC8vIFNlYXJjaCBmb3IgYmlhc2VkIEJHUiB2YWx1ZXNcclxuICAgIGZ1bmN0aW9uIGNvbnRlc3QoYiwgZywgcikge1xyXG4gIFxyXG4gICAgICAvLyBmaW5kcyBjbG9zZXN0IG5ldXJvbiAobWluIGRpc3QpIGFuZCB1cGRhdGVzIGZyZXFcclxuICAgICAgLy8gZmluZHMgYmVzdCBuZXVyb24gKG1pbiBkaXN0LWJpYXMpIGFuZCByZXR1cm5zIHBvc2l0aW9uXHJcbiAgICAgIC8vIGZvciBmcmVxdWVudGx5IGNob3NlbiBuZXVyb25zLCBmcmVxW2ldIGlzIGhpZ2ggYW5kIGJpYXNbaV0gaXMgbmVnYXRpdmVcclxuICAgICAgLy8gYmlhc1tpXSA9IGdhbW1hKigoMS9uZXRzaXplKS1mcmVxW2ldKVxyXG4gIFxyXG4gICAgICB2YXIgaTtcclxuICAgICAgdmFyIGRpc3Q7XHJcbiAgICAgIHZhciBhO1xyXG4gICAgICB2YXIgYmlhc2Rpc3Q7XHJcbiAgICAgIHZhciBiZXRhZnJlcTtcclxuICAgICAgdmFyIGJlc3Rwb3M7XHJcbiAgICAgIHZhciBiZXN0Ymlhc3BvcztcclxuICAgICAgdmFyIGJlc3RkO1xyXG4gICAgICB2YXIgYmVzdGJpYXNkO1xyXG4gICAgICB2YXIgbjtcclxuICBcclxuICAgICAgYmVzdGQgPSB+KDEgPDwgMzEpO1xyXG4gICAgICBiZXN0Ymlhc2QgPSBiZXN0ZDtcclxuICAgICAgYmVzdHBvcyA9IC0xO1xyXG4gICAgICBiZXN0Ymlhc3BvcyA9IGJlc3Rwb3M7XHJcbiAgXHJcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBuZXRzaXplOyBpKyspIHtcclxuICBcclxuICAgICAgICBuID0gbmV0d29ya1tpXTtcclxuICAgICAgICBkaXN0ID0gblswXSAtIGI7XHJcbiAgXHJcbiAgICAgICAgaWYgKGRpc3QgPCAwKSB7XHJcbiAgICAgICAgICBkaXN0ID0gLWRpc3Q7XHJcbiAgICAgICAgfVxyXG4gIFxyXG4gICAgICAgIGEgPSBuWzFdIC0gZztcclxuICBcclxuICAgICAgICBpZiAoYSA8IDApIHtcclxuICAgICAgICAgIGEgPSAtYTtcclxuICAgICAgICB9XHJcbiAgXHJcbiAgICAgICAgZGlzdCArPSBhO1xyXG4gIFxyXG4gICAgICAgIGEgPSBuWzJdIC0gcjtcclxuICBcclxuICAgICAgICBpZiAoYSA8IDApIHtcclxuICAgICAgICAgIGEgPSAtYTtcclxuICAgICAgICB9XHJcbiAgXHJcbiAgICAgICAgZGlzdCArPSBhO1xyXG4gIFxyXG4gICAgICAgIGlmIChkaXN0IDwgYmVzdGQpIHtcclxuICAgICAgICAgIGJlc3RkID0gZGlzdDtcclxuICAgICAgICAgIGJlc3Rwb3MgPSBpO1xyXG4gICAgICAgIH1cclxuICBcclxuICAgICAgICBiaWFzZGlzdCA9IGRpc3QgLSAoYmlhc1tpXSA+PiBpbnRiaWFzc2hpZnQgLSBuZXRiaWFzc2hpZnQpO1xyXG4gIFxyXG4gICAgICAgIGlmIChiaWFzZGlzdCA8IGJlc3RiaWFzZCkge1xyXG4gICAgICAgICAgYmVzdGJpYXNkID0gYmlhc2Rpc3Q7XHJcbiAgICAgICAgICBiZXN0Ymlhc3BvcyA9IGk7XHJcbiAgICAgICAgfVxyXG4gIFxyXG4gICAgICAgIGJldGFmcmVxID0gZnJlcVtpXSA+PiBiZXRhc2hpZnQ7XHJcbiAgICAgICAgZnJlcVtpXSAtPSBiZXRhZnJlcTtcclxuICAgICAgICBiaWFzW2ldICs9IGJldGFmcmVxIDw8IGdhbW1hc2hpZnQ7XHJcbiAgICAgIH1cclxuICBcclxuICAgICAgZnJlcVtiZXN0cG9zXSArPSBiZXRhO1xyXG4gICAgICBiaWFzW2Jlc3Rwb3NdIC09IGJldGFnYW1tYTtcclxuICAgICAgcmV0dXJuIGJlc3RiaWFzcG9zO1xyXG4gICAgfVxyXG4gIFxyXG4gICAgTmV1UXVhbnRDb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG5cclxuICAgIGxldCBleHBvcnRzID0ge307XHJcbiAgICBleHBvcnRzLm1hcCA9IG1hcDtcclxuICAgIGV4cG9ydHMucHJvY2VzcyA9IHByb2Nlc3M7XHJcblxyXG4gICAgcmV0dXJuIGV4cG9ydHM7XHJcbiAgfSIsIi8qKlxyXG4gKiDlsIZGaWxl77yIQmxvYu+8ieWvueixoei9rOWPmOS4uuS4gOS4qmRhdGFVUkzlrZfnrKbkuLJcclxuICpcclxuICogQHBhcmFtIHtJbWFnZURhdGF9IGRhdGFcclxuICogQHJldHVybnMge251bWJlcltdXX0gW11cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGltYWdlRGF0YVRvUkdCKGRhdGE6IFtdLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcik6IG51bWJlcltdIHtcclxuICBsZXQgbGVuZ3RoID0gd2lkdGggKiBoZWlnaHQgKiA0O1xyXG4gIGxldCBpID0gMDtcclxuICBsZXQgcmdiOiBudW1iZXJbXSA9IFtdO1xyXG5cclxuICB3aGlsZSAoaSA8IGxlbmd0aCkge1xyXG4gICAgICByZ2IucHVzaChkYXRhW2krK10pO1xyXG4gICAgICByZ2IucHVzaChkYXRhW2krK10pO1xyXG4gICAgICByZ2IucHVzaChkYXRhW2krK10pO1xyXG4gICAgICBpKys7IC8vIGZvciB0aGUgYWxwaGEgY2hhbm5lbCB3aGljaCB3ZSBkb24ndCBjYXJlIGFib3V0XHJcbiAgfVxyXG5cclxuICByZXR1cm4gcmdiO1xyXG59IiwiaW1wb3J0IHsgTmV1UXVhbnQgfSBmcm9tIFwiLi9uZXVxdWFudC5qc1wiO1xyXG5pbXBvcnQgaW1hZ2VEYXRhVG9SR0IgZnJvbSBcIi4vaW1hZ2VEYXRhVG9SR0JcIjtcclxuXHJcbmZ1bmN0aW9uIGNvbXBvbmVudGl6ZWRQYWxldHRlVG9BcnJheShwYWxldHRlUkdCKSB7XHJcbiAgcGFsZXR0ZVJHQiA9IHBhbGV0dGVSR0IgfHwgW107XHJcblxyXG4gIGxldCBwYWxldHRlQXJyYXkgPSBbXTtcclxuXHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWxldHRlUkdCLmxlbmd0aDsgaSArPSAzKSB7XHJcbiAgICAgIGxldCByID0gcGFsZXR0ZVJHQltpXTtcclxuICAgICAgbGV0IGcgPSBwYWxldHRlUkdCW2kgKyAxXTtcclxuICAgICAgbGV0IGIgPSBwYWxldHRlUkdCW2kgKyAyXTtcclxuXHJcbiAgICAgIHBhbGV0dGVBcnJheS5wdXNoKHIgPDwgMTYgfCBnIDw8IDggfCBiKTtcclxuICB9XHJcblxyXG4gIHJldHVybiBwYWxldHRlQXJyYXk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiDlsIZGaWxl77yIQmxvYu+8ieWvueixoei9rOWPmOS4uuS4gOS4qmRhdGFVUkzlrZfnrKbkuLJcclxuICogaHR0cHM6Ly9naXRodWIuY29tL3lhaG9vL2dpZnNob3QvYmxvYi9tYXN0ZXIvc3JjL2dpZnNob3QuanNcclxuICpcclxuICogQHBhcmFtIHtJbWFnZURhdGF9IGltYWdlRGF0YVxyXG4gKiBAcGFyYW0ge251bWJlcn0gd2lkdGhcclxuICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodFxyXG4gKiBAcGFyYW0ge251bWJlcn0gc2FtcGxlSW50ZXJ2YWxcclxuICogQHJldHVybnMge0FycmF5fSBQcm9taXNl5ZCr5pyJ5LiA5LiqZGF0YVVSTOWtl+espuS4suWPguaVsFxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcHJvY2Vzc0ZyYW1lV2l0aFF1YW50aXplcihpbWFnZURhdGE6IEltYWdlRGF0YSwgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIsIHNhbXBsZUludGVydmFsOiBudW1iZXIpIHtcclxuICBsZXQgcmdiQ29tcG9uZW50cyA9IGltYWdlRGF0YVRvUkdCKEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGltYWdlRGF0YS5kYXRhKSwgd2lkdGgsIGhlaWdodCk7XHJcbiAgbGV0IG51bWJlclBpeGVsczogbnVtYmVyID0gd2lkdGggKiBoZWlnaHQ7XHJcblxyXG4gIGxldCBucSA9IE5ldVF1YW50KHJnYkNvbXBvbmVudHMsIHJnYkNvbXBvbmVudHMubGVuZ3RoLCBzYW1wbGVJbnRlcnZhbCk7XHJcbiAgXHJcbiAgbGV0IHBhbGV0dGVSR0JucSA9IG5xLnByb2Nlc3MoKTtcclxuICBsZXQgcGFsZXR0ZUFycmF5OiBhbnkgPSBbXTtcclxuXHJcbiAgLy8gQ2hlY2sgbGluZSAxMTM1LCBnaWZzaG90LmpzLlxyXG4gIHBhbGV0dGVBcnJheSA9IG5ldyBVaW50MzJBcnJheShjb21wb25lbnRpemVkUGFsZXR0ZVRvQXJyYXkocGFsZXR0ZVJHQm5xKSk7XHJcbiAgbGV0IGluZGV4ZWRQaXhlbHM6IGFueSA9IG5ldyBVaW50OEFycmF5KG51bWJlclBpeGVscyk7XHJcbiAgbGV0IGsgPSAwO1xyXG5cclxuICBmb3IgKGxldCBpID0gMDsgaSA8IG51bWJlclBpeGVsczsgaSsrKSB7XHJcbiAgICAgIGxldCByOiBudW1iZXIgPSByZ2JDb21wb25lbnRzW2srK107XHJcbiAgICAgIGxldCBnOiBudW1iZXIgPSByZ2JDb21wb25lbnRzW2srK107XHJcbiAgICAgIGxldCBiOiBudW1iZXIgPSByZ2JDb21wb25lbnRzW2srK107XHJcblxyXG4gICAgICBpbmRleGVkUGl4ZWxzW2ldID0gbnEubWFwKHIsIGcsIGIpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHtcclxuICAgICAgcGl4ZWxzOiBpbmRleGVkUGl4ZWxzLFxyXG4gICAgICBwYWxldHRlOiBwYWxldHRlQXJyYXlcclxuICB9O1xyXG59IiwiLyoqXHJcbiAqIOmAmui/h+S4gOS4quWbvueJh+eahHVybOWKoOi9veaJgOmcgOimgeeahEZpbGXvvIhCbG9i77yJ5a+56LGhXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgLSDlm77niYdVUkxcclxuICogQHJldHVybnMge1Byb21pc2UoQmxvYil9XHJcbiAqXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB1cmx0b0Jsb2IodXJsOiBzdHJpbmcpOiBQcm9taXNlPEJsb2I+IHtcclxuICByZXR1cm4gZmV0Y2godXJsKS50aGVuKHJlc3BvbnNlID0+IHJlc3BvbnNlLmJsb2IoKSk7XHJcbn07IiwiaW1wb3J0IHsgSW1hZ2UyQ2FudmFzQ29uZmlnIH0gZnJvbSAnQG1vZGVscyc7XHJcbmltcG9ydCB7IEZyYW1lLCBGcmFtZU9wdGlvbnMsIEdpZk9wdGlvbnMsIEdpZlJlYWRlciwgR2lmV3JpdGVyIH0gZnJvbSAnb21nZ2lmJztcclxuaW1wb3J0IHByb2Nlc3NGcmFtZVdpdGhRdWFudGl6ZXIgZnJvbSAnLi9wcm9jZXNzRnJhbWVXaXRoUXVhbnRpemVyJztcclxuaW1wb3J0IHVybHRvQmxvYiBmcm9tICcuL3VybHRvQmxvYic7XHJcblxyXG5mdW5jdGlvbiBzY2FsZUltYWdlRGF0YShpbWFnZURhdGE6IEltYWdlRGF0YSwgc2NhbGVfeDogbnVtYmVyLCBzY2FsZV95OiBudW1iZXIpOiBJbWFnZURhdGEge1xyXG4gIGxldCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuICBjYW52YXMud2lkdGggPSBpbWFnZURhdGEud2lkdGg7XHJcbiAgY2FudmFzLmhlaWdodCA9IGltYWdlRGF0YS5oZWlnaHQ7XHJcblxyXG4gIGxldCBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XHJcbiAgY29udGV4dC5wdXRJbWFnZURhdGEoaW1hZ2VEYXRhLCAwLCAwKTtcclxuICBcclxuICBsZXQgdG1wQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgdG1wQ2FudmFzLndpZHRoID0gaW1hZ2VEYXRhLndpZHRoICogc2NhbGVfeDtcclxuICB0bXBDYW52YXMuaGVpZ2h0ID0gaW1hZ2VEYXRhLmhlaWdodCAqIHNjYWxlX3k7XHJcblxyXG4gIGxldCB0bXBDdHggPSB0bXBDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcclxuICB0bXBDdHguc2NhbGUoc2NhbGVfeCwgc2NhbGVfeSk7XHJcbiAgdG1wQ3R4LmRyYXdJbWFnZShjYW52YXMsIDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XHJcblxyXG4gIHJldHVybiB0bXBDdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIHRtcENhbnZhcy53aWR0aCwgdG1wQ2FudmFzLmhlaWdodCk7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiDlsIbkuIDkuKppbWFnZeWvueixoei9rOWPmOS4uuS4gOS4qmNhbnZhc+WvueixoVxyXG4gKlxyXG4gKiBAcGFyYW0ge2ltYWdlfSBpbWFnZVxyXG4gKlxyXG4gKiBAdHlwZWRlZiB7T2JqZWN0PX0gY29uZmlnIC0g6L2s5Y+Y5Li6Y2FudmFz5pe255qE5LiA5Lqb5Y+C5pWw6YWN572uXHJcbiAqIFx0XHRAcGFyYW0ge251bWJlcn0gd2lkdGggLSBjYW52YXPlm77lg4/nmoTlrr3luqbvvIzpu5jorqTkuLppbWFnZeeahOWuveW6plxyXG4gKiBcdFx0QHBhcmFtIHtudW1iZXJ9IGhlaWdodCAtIGNhbnZhc+WbvuWDj+eahOmrmOW6pu+8jOm7mOiupOS4umltYWdl55qE6auY5bqmXHJcbiAqIFx0XHRAcGFyYW0ge251bWJlcn0gc2NhbGUgLSDnm7jlr7nkuo5pbWFnZeeahOe8qeaUvuavlOS+i++8jOiMg+WbtDAtMTDvvIzpu5jorqTkuI3nvKnmlL7vvJtcclxuICogXHRcdFx06K6+572uY29uZmlnLnNjYWxl5ZCO5Lya6KaG55uWY29uZmlnLndpZHRo5ZKMY29uZmlnLmhlaWdodOeahOiuvue9ru+8m1xyXG4gKiBcdFx0QHBhcmFtIHtudW1iZXJ9IG9yaWVudGF0aW9uIC0g5Zu+54mH5peL6L2s5Y+C5pWw77yM6buY6K6k5LiN5peL6L2s77yM5Y+C6ICD5aaC5LiL77yaXHJcbiAqIFx0XHRcdOWPguaVsFx0IOaXi+i9rOaWueWQkVxyXG4gKiBcdFx0XHQxXHRcdDDCsFxyXG4gKiBcdFx0XHQyXHRcdOawtOW5s+e/u+i9rFxyXG4gKiBcdFx0XHQzXHRcdDE4MMKwXHJcbiAqIFx0XHRcdDRcdFx05Z6C55u057+76L2sXHJcbiAqIFx0XHRcdDVcdFx06aG65pe26ZKIOTDCsCvmsLTlubPnv7vovaxcclxuICogXHRcdFx0Nlx0XHTpobrml7bpkog5MMKwXHJcbiAqIFx0XHRcdDdcdFx06aG65pe26ZKIOTDCsCvlnoLnm7Tnv7vovaxcclxuICogXHRcdFx0OFx0XHTpgIbml7bpkog5MMKwXHJcbiAqIEB0eXBlIHtjb25maWd9XHJcbiAqXHJcbiAqIEByZXR1cm5zIHtQcm9taXNlKGNhbnZhcyl9XHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBpbWFnZXRvQ2FudmFzKGltYWdlOiBIVE1MSW1hZ2VFbGVtZW50LCBjb25maWc6IEltYWdlMkNhbnZhc0NvbmZpZyA9IHt9KTogUHJvbWlzZTxIVE1MQ2FudmFzRWxlbWVudD4ge1xyXG4gIGNvbnN0IG15Q29uZmlnID0geyAuLi5jb25maWcgfTtcclxuICBjb25zdCBjdnMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuICBjb25zdCBjdHggPSBjdnMuZ2V0Q29udGV4dCgnMmQnKTtcclxuICBsZXQgaGVpZ2h0OiBudW1iZXI7XHJcbiAgbGV0IHdpZHRoOiBudW1iZXI7XHJcblxyXG4gIGZvciAoY29uc3QgaSBpbiBteUNvbmZpZykge1xyXG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChteUNvbmZpZywgaSkpIHtcclxuICAgICAgbXlDb25maWdbaV0gPSBOdW1iZXIobXlDb25maWdbaV0pO1xyXG4gICAgfVxyXG4gIH1cclxuICAvLyDorr7nva7lrr3pq5hcclxuICBpZiAoIW15Q29uZmlnLnNjYWxlKSB7XHJcbiAgICB3aWR0aCA9IG15Q29uZmlnLndpZHRoIHx8IG15Q29uZmlnLmhlaWdodCAqIGltYWdlLndpZHRoIC8gaW1hZ2UuaGVpZ2h0IHx8IGltYWdlLndpZHRoO1xyXG4gICAgaGVpZ2h0ID0gbXlDb25maWcuaGVpZ2h0IHx8IG15Q29uZmlnLndpZHRoICogaW1hZ2UuaGVpZ2h0IC8gaW1hZ2Uud2lkdGggfHwgaW1hZ2UuaGVpZ2h0O1xyXG4gIH0gZWxzZSB7XHJcbiAgICAvLyDnvKnmlL7mr5TkvoswLTEw77yM5LiN5Zyo5q2k6IyD5Zu05YiZ5L+d5oyB5Y6f5p2l5Zu+5YOP5aSn5bCPXHJcbiAgICBjb25zdCBzY2FsZSA9IG15Q29uZmlnLnNjYWxlID4gMCAmJiBteUNvbmZpZy5zY2FsZSA8IDEwID8gbXlDb25maWcuc2NhbGUgOiAxO1xyXG4gICAgd2lkdGggPSBNYXRoLmZsb29yKGltYWdlLndpZHRoICogc2NhbGUpO1xyXG4gICAgaGVpZ2h0ID0gTWF0aC5mbG9vcihpbWFnZS5oZWlnaHQgKiBzY2FsZSk7XHJcbiAgfVxyXG5cclxuICAvLyBHSUYgcmVhZC93cml0ZS5cclxuICBsZXQgYmxvYiA9IGF3YWl0IHVybHRvQmxvYihpbWFnZS5zcmMpO1xyXG4gIGlmIChibG9iLnR5cGUgPT0gXCJpbWFnZS9naWZcIil7XHJcbiAgICBsZXQgYnVmOiBVaW50OEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXdhaXQgYmxvYi5hcnJheUJ1ZmZlcigpKTtcclxuICAgIGxldCByZWFkZXI6IEdpZlJlYWRlciA9IG5ldyBHaWZSZWFkZXIoYnVmIGFzIEJ1ZmZlcik7XHJcblxyXG4gICAgbGV0IGdpZk9wdGlvbnM6IEdpZk9wdGlvbnMgPSB7XHJcbiAgICAgIGxvb3A6IHJlYWRlci5sb29wQ291bnQoKSxcclxuICAgICAgLy8gYmFja2dyb3VuZDogMVxyXG4gICAgfTtcclxuICAgIGxldCB3cml0dGVuQnVmOiBVaW50OEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkod2lkdGggKiBoZWlnaHQgKiByZWFkZXIubnVtRnJhbWVzKCkgKiA1KTtcclxuICAgIGxldCB3cml0ZXI6IEdpZldyaXRlciA9IG5ldyBHaWZXcml0ZXIod3JpdHRlbkJ1ZiBhcyBCdWZmZXIsIHdpZHRoLCBoZWlnaHQsIGdpZk9wdGlvbnMpO1xyXG5cclxuICAgIGxldCBpbWFnZURhdGFzOiBJbWFnZURhdGFbXSA9IG5ldyBBcnJheShyZWFkZXIubnVtRnJhbWVzKCkpO1xyXG4gICAgZm9yIChsZXQgazogbnVtYmVyID0gMDsgayA8IGltYWdlRGF0YXMubGVuZ3RoOyBrKyspe1xyXG4gICAgICBsZXQgaW1hZ2UgPSBuZXcgSW1hZ2VEYXRhKHJlYWRlci53aWR0aCwgcmVhZGVyLmhlaWdodCk7XHJcbiAgICAgIGxldCBmcmFtZUluZm86IEZyYW1lID0gcmVhZGVyLmZyYW1lSW5mbyhrKTtcclxuXHJcbiAgICAgIGlmIChrID4gMCAmJiBmcmFtZUluZm8uZGlzcG9zYWwgPCAyKSB7XHJcbiAgICAgICAgaW1hZ2UuZGF0YS5zZXQobmV3IFVpbnQ4Q2xhbXBlZEFycmF5KGltYWdlRGF0YXNbay0xXS5kYXRhKSk7XHJcbiAgICAgIH1cclxuICAgICAgcmVhZGVyLmRlY29kZUFuZEJsaXRGcmFtZVJHQkEoaywgaW1hZ2UuZGF0YSBhcyBVaW50OENsYW1wZWRBcnJheSk7XHJcblxyXG4gICAgICBpbWFnZURhdGFzW2tdID0gaW1hZ2U7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIFdyaXRlXHJcbiAgICBpbWFnZURhdGFzLm1hcCgoaW1hZ2UsIGspID0+IHtcclxuICAgICAgbGV0IGZyYW1lSW5mbzogRnJhbWUgPSByZWFkZXIuZnJhbWVJbmZvKGspO1xyXG4gICAgICBpbWFnZSA9IHNjYWxlSW1hZ2VEYXRhKGltYWdlLCB3aWR0aC9yZWFkZXIud2lkdGgsIGhlaWdodC9yZWFkZXIuaGVpZ2h0KTtcclxuXHJcbiAgICAgIGxldCBmcmFtZU5xID0gcHJvY2Vzc0ZyYW1lV2l0aFF1YW50aXplcihpbWFnZSwgd2lkdGgsIGhlaWdodCwgMTApO1xyXG4gICAgICBsZXQgZnJhbWVPcHRpb25zOiBGcmFtZU9wdGlvbnMgPSB7XHJcbiAgICAgICAgcGFsZXR0ZTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJhbWVOcS5wYWxldHRlKSxcclxuICAgICAgICBkZWxheTogZnJhbWVJbmZvLmRlbGF5LFxyXG4gICAgICAgIGRpc3Bvc2FsOiBmcmFtZUluZm8uZGlzcG9zYWwsXHJcbiAgICAgICAgLy8gdHJhbnNwYXJlbnQ6IGZyYW1lSW5mby50cmFuc3BhcmVudF9pbmRleFxyXG4gICAgICB9O1xyXG4gICAgICB3cml0ZXIuYWRkRnJhbWUoMCwgMCwgd2lkdGgsIGhlaWdodCwgZnJhbWVOcS5waXhlbHMsIGZyYW1lT3B0aW9ucyk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBsZXQgYmFzZTY0UG5nID0gaW1hZ2VEYXRhcy5tYXAoKGltYWdlRGF0YSwgaykgPT4ge1xyXG4gICAgICBsZXQgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcblxyXG4gICAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcclxuICAgICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcclxuXHJcbiAgICAgIGxldCBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XHJcblxyXG4gICAgICBjb250ZXh0LnB1dEltYWdlRGF0YShpbWFnZURhdGEsIDAsIDApO1xyXG4gICAgICByZXR1cm4gY2FudmFzLnRvRGF0YVVSTChcImltYWdlL3BuZ1wiKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnNvbGUubG9nKGJhc2U2NFBuZyk7XHJcblxyXG4gICAgd3JpdGVyLmVuZCgpO1xyXG5cclxuICAgIGxldCBidWZTdHIgPSBidWZmZXJUb1N0cmluZyh3cml0dGVuQnVmKTtcclxuICAgIGxldCBnaWYgPSBgZGF0YTppbWFnZS9naWY7YmFzZTY0LCR7YnRvYShidWZTdHIpfWA7XHJcblxyXG4gICAgY29uc29sZS5sb2coZ2lmKTtcclxuICB9XHJcblxyXG4gIC8vIOW9k+mhuuaXtumSiOaIluiAhemAhuaXtumSiOaXi+i9rDkw5pe277yM6ZyA6KaB5Lqk5o2iY2FudmFz55qE5a696auYXHJcbiAgaWYgKFs1LCA2LCA3LCA4XS5zb21lKGkgPT4gaSA9PT0gbXlDb25maWcub3JpZW50YXRpb24pKSB7XHJcbiAgICBjdnMuaGVpZ2h0ID0gd2lkdGg7XHJcbiAgICBjdnMud2lkdGggPSBoZWlnaHQ7XHJcbiAgfSBlbHNlIHtcclxuICAgIGN2cy5oZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICBjdnMud2lkdGggPSB3aWR0aDtcclxuICB9XHJcbiAgLy8g6K6+572u5pa55ZCRXHJcbiAgc3dpdGNoIChteUNvbmZpZy5vcmllbnRhdGlvbikge1xyXG4gICAgY2FzZSAzOlxyXG4gICAgICBjdHgucm90YXRlKDE4MCAqIE1hdGguUEkgLyAxODApO1xyXG4gICAgICBjdHguZHJhd0ltYWdlKGltYWdlLCAtY3ZzLndpZHRoLCAtY3ZzLmhlaWdodCwgY3ZzLndpZHRoLCBjdnMuaGVpZ2h0KTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIDY6XHJcbiAgICAgIGN0eC5yb3RhdGUoOTAgKiBNYXRoLlBJIC8gMTgwKTtcclxuICAgICAgY3R4LmRyYXdJbWFnZShpbWFnZSwgMCwgLWN2cy53aWR0aCwgY3ZzLmhlaWdodCwgY3ZzLndpZHRoKTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIDg6XHJcbiAgICAgIGN0eC5yb3RhdGUoMjcwICogTWF0aC5QSSAvIDE4MCk7XHJcbiAgICAgIGN0eC5kcmF3SW1hZ2UoaW1hZ2UsIC1jdnMuaGVpZ2h0LCAwLCBjdnMuaGVpZ2h0LCBjdnMud2lkdGgpO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgMjpcclxuICAgICAgY3R4LnRyYW5zbGF0ZShjdnMud2lkdGgsIDApO1xyXG4gICAgICBjdHguc2NhbGUoLTEsIDEpO1xyXG4gICAgICBjdHguZHJhd0ltYWdlKGltYWdlLCAwLCAwLCBjdnMud2lkdGgsIGN2cy5oZWlnaHQpO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgNDpcclxuICAgICAgY3R4LnRyYW5zbGF0ZShjdnMud2lkdGgsIDApO1xyXG4gICAgICBjdHguc2NhbGUoLTEsIDEpO1xyXG4gICAgICBjdHgucm90YXRlKDE4MCAqIE1hdGguUEkgLyAxODApO1xyXG4gICAgICBjdHguZHJhd0ltYWdlKGltYWdlLCAtY3ZzLndpZHRoLCAtY3ZzLmhlaWdodCwgY3ZzLndpZHRoLCBjdnMuaGVpZ2h0KTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIDU6XHJcbiAgICAgIGN0eC50cmFuc2xhdGUoY3ZzLndpZHRoLCAwKTtcclxuICAgICAgY3R4LnNjYWxlKC0xLCAxKTtcclxuICAgICAgY3R4LnJvdGF0ZSg5MCAqIE1hdGguUEkgLyAxODApO1xyXG4gICAgICBjdHguZHJhd0ltYWdlKGltYWdlLCAwLCAtY3ZzLndpZHRoLCBjdnMuaGVpZ2h0LCBjdnMud2lkdGgpO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgNzpcclxuICAgICAgY3R4LnRyYW5zbGF0ZShjdnMud2lkdGgsIDApO1xyXG4gICAgICBjdHguc2NhbGUoLTEsIDEpO1xyXG4gICAgICBjdHgucm90YXRlKDI3MCAqIE1hdGguUEkgLyAxODApO1xyXG4gICAgICBjdHguZHJhd0ltYWdlKGltYWdlLCAtY3ZzLmhlaWdodCwgMCwgY3ZzLmhlaWdodCwgY3ZzLndpZHRoKTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICBjdHguZHJhd0ltYWdlKGltYWdlLCAwLCAwLCBjdnMud2lkdGgsIGN2cy5oZWlnaHQpO1xyXG4gIH1cclxuICByZXR1cm4gY3ZzO1xyXG59O1xyXG5cclxubGV0IGJ5dGVNYXA6IHN0cmluZ1tdID0gW107XHJcblxyXG5mb3IgKGxldCBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XHJcbiAgYnl0ZU1hcFtpXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoaSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGJ1ZmZlclRvU3RyaW5nKGJ1ZmZlcjogVWludDhBcnJheSk6IHN0cmluZyB7XHJcbiAgbGV0IG51bWJlclZhbHVlcyA9IGJ1ZmZlci5sZW5ndGg7XHJcbiAgbGV0IHN0ciA9ICcnO1xyXG4gIGxldCB4ID0gLTE7XHJcblxyXG4gIHdoaWxlICgrK3ggPCBudW1iZXJWYWx1ZXMpIHtcclxuICAgIHN0ciArPSBieXRlTWFwW2J1ZmZlclt4XV07XHJcbiAgfVxyXG5cclxuICByZXR1cm4gc3RyO1xyXG59IiwiLyoqXHJcbiAqIOmAmui/h+S4gOS4quWbvueJh+eahHVybOWKoOi9veaJgOmcgOimgeeahGltYWdl5a+56LGhXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgLSDlm77niYdVUkxcclxuICogQHJldHVybnMge1Byb21pc2UoSW1hZ2UpfVxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdXJsdG9JbWFnZSh1cmw6IHN0cmluZyk6IFByb21pc2U8SFRNTEltYWdlRWxlbWVudD4ge1xyXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICBjb25zdCBpbWcgPSBuZXcgSW1hZ2UoKTtcclxuICAgIGltZy5vbmxvYWQgPSAoKSA9PiByZXNvbHZlKGltZyk7XHJcbiAgICBpbWcub25lcnJvciA9ICgpID0+IHJlamVjdChuZXcgRXJyb3IoJ3VybHRvSW1hZ2UoKTogSW1hZ2UgZmFpbGVkIHRvIGxvYWQsIHBsZWFzZSBjaGVjayB0aGUgaW1hZ2UgVVJMJykpO1xyXG4gICAgaW1nLnNyYyA9IHVybDtcclxuICB9KTtcclxufTsiLCJpbXBvcnQgY2FudmFzdG9EYXRhVVJMIGZyb20gJy4vY2FudmFzdG9EYXRhVVJMJztcclxuaW1wb3J0IGNhbnZhc3RvRmlsZSBmcm9tICcuL2NhbnZhc3RvRmlsZSc7XHJcbmltcG9ydCBkYXRhVVJMdG9GaWxlIGZyb20gJy4vZGF0YVVSTHRvRmlsZSc7XHJcbmltcG9ydCBkYXRhVVJMdG9JbWFnZSBmcm9tICcuL2RhdGFVUkx0b0ltYWdlJztcclxuaW1wb3J0IGRvd25sb2FkRmlsZSBmcm9tICcuL2Rvd25sb2FkRmlsZSc7XHJcbmltcG9ydCBmaWxldG9EYXRhVVJMIGZyb20gJy4vZmlsZXRvRGF0YVVSTCc7XHJcbmltcG9ydCBpbWFnZXRvQ2FudmFzIGZyb20gJy4vaW1hZ2V0b0NhbnZhcyc7XHJcbmltcG9ydCB1cmx0b0Jsb2IgZnJvbSAnLi91cmx0b0Jsb2InO1xyXG5pbXBvcnQgdXJsdG9JbWFnZSBmcm9tICcuL3VybHRvSW1hZ2UnO1xyXG5pbXBvcnQgeyBjaGVja0ltYWdlVHlwZSB9IGZyb20gJ0B1dGlscyc7XHJcbmltcG9ydCB7IEVJbWFnZVR5cGUsIElDb21wcmVzc0NvbmZpZywgY29tcHJlc3NBY2N1cmF0ZWx5Q29uZmlnIH0gZnJvbSAnQG1vZGVscyc7XHJcblxyXG4vKipcclxuICog5Y6L57ypRmlsZe+8iEJsb2LvvInlr7nosaFcclxuICogQHBhcmFtIHtCbG9ifSBmaWxlIC0g5LiA5LiqRmlsZe+8iEJsb2LvvInlr7nosaFcclxuICogQHBhcmFtIHsobnVtYmVyfG9iamVjdCl9IGNvbmZpZyAtIOWmguaenOS8oOWFpeaYr251bWJlcuexu+Wei++8jOS8oOWFpeiMg+WbtCAwLTHvvIzooajnpLrlm77niYfljovnvKnotKjph48s6buY6K6kMC45Mu+8m+S5n+WPr+S7peS8oOWFpW9iamVjdOexu+Wei++8jOS7peS+v+abtOivpue7hueahOmFjee9rlxyXG4gKiBAZXhhbXBsZVxyXG4gKiBcdFx0aW1hZ2VDb252ZXJzaW9uLmNvbXByZXNzKGZpbGUsMC44KVxyXG4gKlxyXG4gKiBcdFx0aW1hZ2VDb252ZXJzaW9uLmNvbXByZXNzKGZpbGUse1xyXG4gKiBcdFx0XHRxdWFsaXR5OiAwLjgsIC8v5Zu+54mH5Y6L57yp6LSo6YePXHJcbiAqIFx0XHRcdHR5cGXvvJpcImltYWdlL3BuZ1wiLCAvL+i9rOaNouWQjueahOWbvueJh+exu+Wei++8jOmAiemhueaciSBcImltYWdlL3BuZ1wiLCBcImltYWdlL2pwZWdcIiwgXCJpbWFnZS9naWZcIlxyXG4gKiBcdFx0XHR3aWR0aDogMzAwLCAvL+eUn+aIkOWbvueJh+eahOWuveW6plxyXG4gKiBcdFx0XHRoZWlnaHTvvJoyMDDvvIwgLy/nlJ/kuqflm77niYfnmoTpq5jluqZcclxuICogXHRcdFx0c2NhbGU6IDAuNe+8jCAvL+ebuOWvueS6juWOn+Wni+WbvueJh+eahOe8qeaUvuavlOeOhyzorr7nva5jb25maWcuc2NhbGXlkI7kvJropobnm5Zjb25maWcud2lkdGjlkoxjb25maWcuaGVpZ2h055qE6K6+572u77ybXHJcbiAqIFx0XHRcdG9yaWVudGF0aW9uOjIsIC8v5Zu+54mH5peL6L2s5pa55ZCRXHJcbiAqIFx0XHR9KVxyXG4gKlxyXG4gKiBAcmV0dXJucyB7UHJvbWlzZShCbG9iKX1cclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGNvbXByZXNzKGZpbGU6IEZpbGUsIGNvbmZpZzogSUNvbXByZXNzQ29uZmlnID0ge30pOiBQcm9taXNlPEJsb2I+IHtcclxuICBpZiAoIShmaWxlIGluc3RhbmNlb2YgQmxvYikpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignY29tcHJlc3MoKTogRmlyc3QgYXJnIG11c3QgYmUgYSBCbG9iIG9iamVjdCBvciBhIEZpbGUgb2JqZWN0LicpO1xyXG4gIH1cclxuICBpZiAodHlwZW9mIGNvbmZpZyAhPT0gJ29iamVjdCcpIHtcclxuICAgIGNvbmZpZyA9IE9iamVjdC5hc3NpZ24oe1xyXG4gICAgICBxdWFsaXR5OiBjb25maWcsXHJcbiAgICB9KTtcclxuICB9XHJcbiAgY29uZmlnLnF1YWxpdHkgPSBOdW1iZXIoY29uZmlnLnF1YWxpdHkpO1xyXG4gIGlmIChOdW1iZXIuaXNOYU4oY29uZmlnLnF1YWxpdHkpKSB7XHJcbiAgICByZXR1cm4gZmlsZTtcclxuICB9XHJcbiAgY29uc3QgZGF0YVVSTCA9IGF3YWl0IGZpbGV0b0RhdGFVUkwoZmlsZSk7XHJcbiAgbGV0IG9yaWdpbmFsTWltZSA9IGRhdGFVUkwuc3BsaXQoJywnKVswXS5tYXRjaCgvOiguKj8pOy8pWzFdIGFzIEVJbWFnZVR5cGU7IC8vIOWOn+Wni+WbvuWDj+WbvueJh+exu+Wei1xyXG4gIGxldCBtaW1lID0gRUltYWdlVHlwZS5KUEVHOyAvLyDpu5jorqTljovnvKnnsbvlnotcclxuICBpZiAoY2hlY2tJbWFnZVR5cGUoY29uZmlnLnR5cGUpKSB7XHJcbiAgICBtaW1lID0gY29uZmlnLnR5cGU7XHJcbiAgICBvcmlnaW5hbE1pbWUgPSBjb25maWcudHlwZTtcclxuICB9XHJcbiAgY29uc3QgaW1hZ2UgPSBhd2FpdCBkYXRhVVJMdG9JbWFnZShkYXRhVVJMKTtcclxuICBjb25zdCBjYW52YXMgPSBhd2FpdCBpbWFnZXRvQ2FudmFzKGltYWdlLCBPYmplY3QuYXNzaWduKHt9LCBjb25maWcpKTtcclxuICBjb25zdCBjb21wcmVzc0RhdGFVUkwgPSBhd2FpdCBjYW52YXN0b0RhdGFVUkwoY2FudmFzLCBjb25maWcucXVhbGl0eSwgbWltZSk7XHJcbiAgY29uc3QgY29tcHJlc3NGaWxlID0gYXdhaXQgZGF0YVVSTHRvRmlsZShjb21wcmVzc0RhdGFVUkwsIG9yaWdpbmFsTWltZSk7XHJcbiAgaWYgKGNvbXByZXNzRmlsZS5zaXplID4gZmlsZS5zaXplKSB7XHJcbiAgICByZXR1cm4gZmlsZTtcclxuICB9XHJcbiAgcmV0dXJuIGNvbXByZXNzRmlsZTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiDmoLnmja7kvZPnp6/ljovnvKlGaWxl77yIQmxvYu+8ieWvueixoVxyXG4gKlxyXG4gKiBAcGFyYW0ge0Jsb2J9IGZpbGUgLSDkuIDkuKpGaWxl77yIQmxvYu+8ieWvueixoVxyXG4gKiBAcGFyYW0geyhudW1iZXJ8b2JqZWN0KX0gY29uZmlnIC0g5aaC5p6c5Lyg5YWl5pivbnVtYmVy57G75Z6L77yM5YiZ5oyH5a6a5Y6L57yp5Zu+54mH55qE5L2T56evLOWNleS9jUtiO+S5n+WPr+S7peS8oOWFpW9iamVjdOexu+Wei++8jOS7peS+v+abtOivpue7hueahOmFjee9rlxyXG4gKiBcdFx0QHBhcmFtIHtudW1iZXJ9IHNpemUgLSDmjIflrprljovnvKnlm77niYfnmoTkvZPnp68s5Y2V5L2NS2JcclxuICogXHRcdEBwYXJhbSB7bnVtYmVyfSBhY2N1cmFjeSAtIOebuOWvueS6juaMh+WumuWOi+e8qeS9k+enr+eahOeyvuehruW6pu+8jOiMg+WbtDAuOC0wLjk577yM6buY6K6kMC45Ne+8m1xyXG4gKiAgICAgICAg5aaC5p6c6K6+572uIOWbvueJh+S9k+enrzEwMDBLYiznsr7noa7luqYwLjnvvIzliJnljovnvKnnu5PmnpzkuLo5MDBLYi0xMTAwS2LnmoTlm77niYfpg73nrpflkIjmoLzvvJtcclxuICogQGV4YW1wbGVcclxuICogIFx0aW1hZ2VDb252ZXJzaW9uLmNvbXByZXNzKGZpbGUsMTAwKSAvL+WOi+e8qeWQjuWbvueJh+Wkp+Wwj+S4ujEwMGtiXHJcbiAqXHJcbiAqIFx0XHRpbWFnZUNvbnZlcnNpb24uY29tcHJlc3MoZmlsZSx7XHJcbiAqIFx0XHRcdHNpemU6IDEwMCwgLy/lm77niYfljovnvKnkvZPnp6/vvIzljZXkvY1LYlxyXG4gKiBcdFx0XHRhY2N1cmFjeTogMC45LCAvL+WbvueJh+WOi+e8qeS9k+enr+eahOeyvuehruW6pu+8jOm7mOiupDAuOTVcclxuICogXHRcdFx0dHlwZe+8mlwiaW1hZ2UvcG5nXCIsIC8v6L2s5o2i5ZCO55qE5Zu+54mH57G75Z6L77yM6YCJ6aG55pyJIFwiaW1hZ2UvcG5nXCIsIFwiaW1hZ2UvanBlZ1wiLCBcImltYWdlL2dpZlwiXHJcbiAqIFx0XHRcdHdpZHRoOiAzMDAsIC8v55Sf5oiQ5Zu+54mH55qE5a695bqmXHJcbiAqIFx0XHRcdGhlaWdodDogMjAwLCAvL+eUn+S6p+WbvueJh+eahOmrmOW6plxyXG4gKiBcdFx0XHRzY2FsZTogMC41LCAvL+ebuOWvueS6juWOn+Wni+WbvueJh+eahOe8qeaUvuavlOeOhyzorr7nva5jb25maWcuc2NhbGXlkI7kvJropobnm5Zjb25maWcud2lkdGjlkoxjb25maWcuaGVpZ2h055qE6K6+572u77ybXHJcbiAqIFx0XHRcdG9yaWVudGF0aW9uOjIsIC8v5Zu+54mH5peL6L2s5pa55ZCRXHJcbiAqIFx0XHR9KVxyXG4gKlxyXG4gKiBAcmV0dXJucyB7UHJvbWlzZShCbG9iKX1cclxuICovXHJcbmFzeW5jIGZ1bmN0aW9uIGNvbXByZXNzQWNjdXJhdGVseShmaWxlOiBCbG9iLCBjb25maWc6IGNvbXByZXNzQWNjdXJhdGVseUNvbmZpZyA9IHt9KTogUHJvbWlzZTxCbG9iPiB7XHJcbiAgaWYgKCEoZmlsZSBpbnN0YW5jZW9mIEJsb2IpKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NvbXByZXNzQWNjdXJhdGVseSgpOiBGaXJzdCBhcmcgbXVzdCBiZSBhIEJsb2Igb2JqZWN0IG9yIGEgRmlsZSBvYmplY3QuJyk7XHJcbiAgfVxyXG4gIGlmICh0eXBlb2YgY29uZmlnICE9PSAnb2JqZWN0Jykge1xyXG4gICAgY29uZmlnID0gT2JqZWN0LmFzc2lnbih7XHJcbiAgICAgIHNpemU6IGNvbmZpZyxcclxuICAgIH0pO1xyXG4gIH1cclxuICAvLyDlpoLmnpzmjIflrprkvZPnp6/kuI3mmK/mlbDlrZfmiJbogIXmlbDlrZflrZfnrKbkuLLvvIzliJnkuI3lgZrlpITnkIZcclxuICBjb25maWcuc2l6ZSA9IE51bWJlcihjb25maWcuc2l6ZSk7XHJcbiAgaWYgKE51bWJlci5pc05hTihjb25maWcuc2l6ZSkpIHtcclxuICAgIHJldHVybiBmaWxlO1xyXG4gIH1cclxuICAvLyDlpoLmnpzmjIflrprkvZPnp6/lpKfkuo7ljp/mlofku7bkvZPnp6/vvIzliJnkuI3lgZrlpITnkIbvvJtcclxuICBpZiAoY29uZmlnLnNpemUgKiAxMDI0ID4gZmlsZS5zaXplKSB7XHJcbiAgICByZXR1cm4gZmlsZTtcclxuICB9XHJcbiAgY29uZmlnLmFjY3VyYWN5ID0gTnVtYmVyKGNvbmZpZy5hY2N1cmFjeSk7XHJcbiAgaWYgKCFjb25maWcuYWNjdXJhY3lcclxuICAgIHx8IGNvbmZpZy5hY2N1cmFjeSA8IDAuOFxyXG4gICAgfHwgY29uZmlnLmFjY3VyYWN5ID4gMC45OSkge1xyXG4gICAgY29uZmlnLmFjY3VyYWN5ID0gMC45NTsgLy8g6buY6K6k57K+5bqmMC45NVxyXG4gIH1cclxuICBjb25zdCByZXN1bHRTaXplID0ge1xyXG4gICAgbWF4OiBjb25maWcuc2l6ZSAqICgyIC0gY29uZmlnLmFjY3VyYWN5KSAqIDEwMjQsXHJcbiAgICBhY2N1cmF0ZTogY29uZmlnLnNpemUgKiAxMDI0LFxyXG4gICAgbWluOiBjb25maWcuc2l6ZSAqIGNvbmZpZy5hY2N1cmFjeSAqIDEwMjQsXHJcbiAgfTtcclxuICBjb25zdCBkYXRhVVJMID0gYXdhaXQgZmlsZXRvRGF0YVVSTChmaWxlKTtcclxuICBsZXQgb3JpZ2luYWxNaW1lID0gZGF0YVVSTC5zcGxpdCgnLCcpWzBdLm1hdGNoKC86KC4qPyk7LylbMV0gYXMgRUltYWdlVHlwZTsgLy8g5Y6f5aeL5Zu+5YOP5Zu+54mH57G75Z6LXHJcbiAgbGV0IG1pbWUgPSBFSW1hZ2VUeXBlLkpQRUc7XHJcbiAgaWYgKGNoZWNrSW1hZ2VUeXBlKGNvbmZpZy50eXBlKSkge1xyXG4gICAgbWltZSA9IGNvbmZpZy50eXBlO1xyXG4gICAgb3JpZ2luYWxNaW1lID0gY29uZmlnLnR5cGU7XHJcbiAgfVxyXG4gIGNvbnN0IGltYWdlID0gYXdhaXQgZGF0YVVSTHRvSW1hZ2UoZGF0YVVSTCk7XHJcbiAgY29uc3QgY2FudmFzID0gYXdhaXQgaW1hZ2V0b0NhbnZhcyhpbWFnZSwgT2JqZWN0LmFzc2lnbih7fSwgY29uZmlnKSk7XHJcbiAgLyoqXHJcbiAgICog57uP6L+H5rWL6K+V5Y+R546w77yMYmxvYi5zaXpl5LiOZGF0YVVSTC5sZW5ndGjnmoTmr5TlgLznuqbnrYnkuo4wLjc1XHJcbiAgICog6L+Z5Liq5q+U5YC85Y+v5Lul5ZCM6L+HZGF0YVVSTHRvRmlsZei/meS4quaWueazleadpea1i+ivlemqjOivgVxyXG4gICAqIOi/memHjOS4uuS6huaPkOmrmOaAp+iDve+8jOebtOaOpemAmui/h+i/meS4quavlOWAvOadpeiuoeeul+WHumJsb2Iuc2l6ZVxyXG4gICAqL1xyXG4gIGNvbnN0IHByb3BvcnRpb24gPSAwLjc1O1xyXG4gIGxldCBpbWFnZVF1YWxpdHkgPSAwLjU7XHJcbiAgbGV0IGNvbXByZXNzRGF0YVVSTDtcclxuICBjb25zdCB0ZW1wRGF0YVVSTHM6IHN0cmluZ1tdID0gW251bGwsIG51bGxdO1xyXG4gIC8qKlxyXG4gICAqIEhUTUxDYW52YXNFbGVtZW50LnRvQmxvYigp5Lul5Y+KSFRNTENhbnZhc0VsZW1lbnQudG9EYXRhVVJMKCnljovnvKnlj4LmlbBcclxuICAgKiDnmoTmnIDlsI/nu4bnspLluqbkuLowLjAx77yM6ICMMueahDfmrKHmlrnkuLoxMjjvvIzljbPlj6ropoHlvqrnjq835qyh77yM5YiZ5Lya6KaG55uW5omA5pyJ5Y+v6IO95oCnXHJcbiAgICovXHJcbiAgZm9yIChsZXQgeCA9IDE7IHggPD0gNzsgeCsrKSB7XHJcbiAgICBjb21wcmVzc0RhdGFVUkwgPSBhd2FpdCBjYW52YXN0b0RhdGFVUkwoY2FudmFzLCBpbWFnZVF1YWxpdHksIG1pbWUpO1xyXG4gICAgY29uc3QgQ2FsY3VsYXRpb25TaXplID0gY29tcHJlc3NEYXRhVVJMLmxlbmd0aCAqIHByb3BvcnRpb247XHJcbiAgICAvLyDlpoLmnpzliLDlvqrnjq/nrKzkuIPmrKHov5jmsqHmnInovr7liLDnsr7noa7luqbnmoTlgLzvvIzpgqPor7TmmI7or6Xlm77niYfkuI3og73ovr7liLDliLDmraTnsr7noa7luqbopoHmsYJcclxuICAgIC8vIOi/meaXtuWAmeacgOWQjuS4gOasoeW+queOr+WHuuadpeeahGRhdGFVUkzlj6/og73kuI3mmK/mnIDnsr7noa7nmoTvvIzpnIDopoHlj5blhbblkajovrnkuKTkuKpkYXRhVVJM5LiJ6ICF5q+U6L6D5p2l6YCJ5Ye65pyA57K+56Gu55qE77ybXHJcbiAgICBpZiAoeCA9PT0gNykge1xyXG4gICAgICBpZiAocmVzdWx0U2l6ZS5tYXggPCBDYWxjdWxhdGlvblNpemUgfHwgcmVzdWx0U2l6ZS5taW4gPiBDYWxjdWxhdGlvblNpemUpIHtcclxuICAgICAgICBjb21wcmVzc0RhdGFVUkwgPSBbY29tcHJlc3NEYXRhVVJMLCAuLi50ZW1wRGF0YVVSTHNdXHJcbiAgICAgICAgICAuZmlsdGVyKGkgPT4gaSkgLy8g5Y676ZmkbnVsbFxyXG4gICAgICAgICAgLnNvcnQoKGEsIGIpID0+IE1hdGguYWJzKGEubGVuZ3RoICogcHJvcG9ydGlvbiAtIHJlc3VsdFNpemUuYWNjdXJhdGUpXHJcbiAgICAgICAgICAgIC0gTWF0aC5hYnMoYi5sZW5ndGggKiBwcm9wb3J0aW9uIC0gcmVzdWx0U2l6ZS5hY2N1cmF0ZSkpWzBdO1xyXG4gICAgICB9XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gICAgaWYgKHJlc3VsdFNpemUubWF4IDwgQ2FsY3VsYXRpb25TaXplKSB7XHJcbiAgICAgIHRlbXBEYXRhVVJMc1sxXSA9IGNvbXByZXNzRGF0YVVSTDtcclxuICAgICAgaW1hZ2VRdWFsaXR5IC09IDAuNSAqKiAoeCArIDEpO1xyXG4gICAgfSBlbHNlIGlmIChyZXN1bHRTaXplLm1pbiA+IENhbGN1bGF0aW9uU2l6ZSkge1xyXG4gICAgICB0ZW1wRGF0YVVSTHNbMF0gPSBjb21wcmVzc0RhdGFVUkw7XHJcbiAgICAgIGltYWdlUXVhbGl0eSArPSAwLjUgKiogKHggKyAxKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxuICBjb25zdCBjb21wcmVzc0ZpbGUgPSBhd2FpdCBkYXRhVVJMdG9GaWxlKGNvbXByZXNzRGF0YVVSTCwgb3JpZ2luYWxNaW1lKTtcclxuICAvLyDlpoLmnpzljovnvKnlkI7kvZPnp6/lpKfkuo7ljp/mlofku7bkvZPnp6/vvIzliJnov5Tlm57mupDmlofku7bvvJtcclxuICBpZiAoY29tcHJlc3NGaWxlLnNpemUgPiBmaWxlLnNpemUpIHtcclxuICAgIHJldHVybiBmaWxlO1xyXG4gIH1cclxuICByZXR1cm4gY29tcHJlc3NGaWxlO1xyXG59O1xyXG5cclxuZXhwb3J0IHtcclxuICBjYW52YXN0b0RhdGFVUkwsXHJcbiAgY2FudmFzdG9GaWxlLFxyXG4gIGRhdGFVUkx0b0ZpbGUsXHJcbiAgZGF0YVVSTHRvSW1hZ2UsXHJcbiAgZG93bmxvYWRGaWxlLFxyXG4gIGZpbGV0b0RhdGFVUkwsXHJcbiAgaW1hZ2V0b0NhbnZhcyxcclxuICB1cmx0b0Jsb2IsXHJcbiAgdXJsdG9JbWFnZSxcclxuICBjb21wcmVzcyxcclxuICBjb21wcmVzc0FjY3VyYXRlbHlcclxufTtcclxuXHJcbmV4cG9ydCB7XHJcbiAgRUltYWdlVHlwZVxyXG59OyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///1\n')}])}));