!function(g,I){"object"==typeof exports&&"object"==typeof module?module.exports=I():"function"==typeof define&&define.amd?define([],I):"object"==typeof exports?exports.imageConversion=I():g.imageConversion=I()}(this,(function(){return function(g){var I={};function B(Q){if(I[Q])return I[Q].exports;var n=I[Q]={i:Q,l:!1,exports:{}};return g[Q].call(n.exports,n,n.exports,B),n.l=!0,n.exports}return B.m=g,B.c=I,B.d=function(g,I,Q){B.o(g,I)||Object.defineProperty(g,I,{enumerable:!0,get:Q})},B.r=function(g){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(g,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(g,"__esModule",{value:!0})},B.t=function(g,I){if(1&I&&(g=B(g)),8&I)return g;if(4&I&&"object"==typeof g&&g&&g.__esModule)return g;var Q=Object.create(null);if(B.r(Q),Object.defineProperty(Q,"default",{enumerable:!0,value:g}),2&I&&"string"!=typeof g)for(var n in g)B.d(Q,n,function(I){return g[I]}.bind(null,n));return Q},B.n=function(g){var I=g&&g.__esModule?function(){return g.default}:function(){return g};return B.d(I,"a",I),I},B.o=function(g,I){return Object.prototype.hasOwnProperty.call(g,I)},B.p="",B(B.s=1)}([function(module,exports,__webpack_require__){"use strict";eval('// (c) Dean McNamee <dean@gmail.com>, 2013.\n//\n// https://github.com/deanm/omggif\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the "Software"), to\n// deal in the Software without restriction, including without limitation the\n// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n// sell copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n// IN THE SOFTWARE.\n//\n// omggif is a JavaScript implementation of a GIF 89a encoder and decoder,\n// including animation and compression.  It does not rely on any specific\n// underlying system, so should run in the browser, Node, or Plask.\n\n\n\nfunction GifWriter(buf, width, height, gopts) {\n  var p = 0;\n\n  var gopts = gopts === undefined ? { } : gopts;\n  var loop_count = gopts.loop === undefined ? null : gopts.loop;\n  var global_palette = gopts.palette === undefined ? null : gopts.palette;\n\n  if (width <= 0 || height <= 0 || width > 65535 || height > 65535)\n    throw new Error("Width/Height invalid.");\n\n  function check_palette_and_num_colors(palette) {\n    var num_colors = palette.length;\n    if (num_colors < 2 || num_colors > 256 ||  num_colors & (num_colors-1)) {\n      throw new Error(\n          "Invalid code/color length, must be power of 2 and 2 .. 256.");\n    }\n    return num_colors;\n  }\n\n  // - Header.\n  buf[p++] = 0x47; buf[p++] = 0x49; buf[p++] = 0x46;  // GIF\n  buf[p++] = 0x38; buf[p++] = 0x39; buf[p++] = 0x61;  // 89a\n\n  // Handling of Global Color Table (palette) and background index.\n  var gp_num_colors_pow2 = 0;\n  var background = 0;\n  if (global_palette !== null) {\n    var gp_num_colors = check_palette_and_num_colors(global_palette);\n    while (gp_num_colors >>= 1) ++gp_num_colors_pow2;\n    gp_num_colors = 1 << gp_num_colors_pow2;\n    --gp_num_colors_pow2;\n    if (gopts.background !== undefined) {\n      background = gopts.background;\n      if (background >= gp_num_colors)\n        throw new Error("Background index out of range.");\n      // The GIF spec states that a background index of 0 should be ignored, so\n      // this is probably a mistake and you really want to set it to another\n      // slot in the palette.  But actually in the end most browsers, etc end\n      // up ignoring this almost completely (including for dispose background).\n      if (background === 0)\n        throw new Error("Background index explicitly passed as 0.");\n    }\n  }\n\n  // - Logical Screen Descriptor.\n  // NOTE(deanm): w/h apparently ignored by implementations, but set anyway.\n  buf[p++] = width & 0xff; buf[p++] = width >> 8 & 0xff;\n  buf[p++] = height & 0xff; buf[p++] = height >> 8 & 0xff;\n  // NOTE: Indicates 0-bpp original color resolution (unused?).\n  buf[p++] = (global_palette !== null ? 0x80 : 0) |  // Global Color Table Flag.\n             gp_num_colors_pow2;  // NOTE: No sort flag (unused?).\n  buf[p++] = background;  // Background Color Index.\n  buf[p++] = 0;  // Pixel aspect ratio (unused?).\n\n  // - Global Color Table\n  if (global_palette !== null) {\n    for (var i = 0, il = global_palette.length; i < il; ++i) {\n      var rgb = global_palette[i];\n      buf[p++] = rgb >> 16 & 0xff;\n      buf[p++] = rgb >> 8 & 0xff;\n      buf[p++] = rgb & 0xff;\n    }\n  }\n\n  if (loop_count !== null) {  // Netscape block for looping.\n    if (loop_count < 0 || loop_count > 65535)\n      throw new Error("Loop count invalid.")\n    // Extension code, label, and length.\n    buf[p++] = 0x21; buf[p++] = 0xff; buf[p++] = 0x0b;\n    // NETSCAPE2.0\n    buf[p++] = 0x4e; buf[p++] = 0x45; buf[p++] = 0x54; buf[p++] = 0x53;\n    buf[p++] = 0x43; buf[p++] = 0x41; buf[p++] = 0x50; buf[p++] = 0x45;\n    buf[p++] = 0x32; buf[p++] = 0x2e; buf[p++] = 0x30;\n    // Sub-block\n    buf[p++] = 0x03; buf[p++] = 0x01;\n    buf[p++] = loop_count & 0xff; buf[p++] = loop_count >> 8 & 0xff;\n    buf[p++] = 0x00;  // Terminator.\n  }\n\n\n  var ended = false;\n\n  this.addFrame = function(x, y, w, h, indexed_pixels, opts) {\n    if (ended === true) { --p; ended = false; }  // Un-end.\n\n    opts = opts === undefined ? { } : opts;\n\n    // TODO(deanm): Bounds check x, y.  Do they need to be within the virtual\n    // canvas width/height, I imagine?\n    if (x < 0 || y < 0 || x > 65535 || y > 65535)\n      throw new Error("x/y invalid.")\n\n    if (w <= 0 || h <= 0 || w > 65535 || h > 65535)\n      throw new Error("Width/Height invalid.")\n\n    if (indexed_pixels.length < w * h)\n      throw new Error("Not enough pixels for the frame size.");\n\n    var using_local_palette = true;\n    var palette = opts.palette;\n    if (palette === undefined || palette === null) {\n      using_local_palette = false;\n      palette = global_palette;\n    }\n\n    if (palette === undefined || palette === null)\n      throw new Error("Must supply either a local or global palette.");\n\n    var num_colors = check_palette_and_num_colors(palette);\n\n    // Compute the min_code_size (power of 2), destroying num_colors.\n    var min_code_size = 0;\n    while (num_colors >>= 1) ++min_code_size;\n    num_colors = 1 << min_code_size;  // Now we can easily get it back.\n\n    var delay = opts.delay === undefined ? 0 : opts.delay;\n\n    // From the spec:\n    //     0 -   No disposal specified. The decoder is\n    //           not required to take any action.\n    //     1 -   Do not dispose. The graphic is to be left\n    //           in place.\n    //     2 -   Restore to background color. The area used by the\n    //           graphic must be restored to the background color.\n    //     3 -   Restore to previous. The decoder is required to\n    //           restore the area overwritten by the graphic with\n    //           what was there prior to rendering the graphic.\n    //  4-7 -    To be defined.\n    // NOTE(deanm): Dispose background doesn\'t really work, apparently most\n    // browsers ignore the background palette index and clear to transparency.\n    var disposal = opts.disposal === undefined ? 0 : opts.disposal;\n    if (disposal < 0 || disposal > 3)  // 4-7 is reserved.\n      throw new Error("Disposal out of range.");\n\n    var use_transparency = false;\n    var transparent_index = 0;\n    if (opts.transparent !== undefined && opts.transparent !== null) {\n      use_transparency = true;\n      transparent_index = opts.transparent;\n      if (transparent_index < 0 || transparent_index >= num_colors)\n        throw new Error("Transparent color index.");\n    }\n\n    if (disposal !== 0 || use_transparency || delay !== 0) {\n      // - Graphics Control Extension\n      buf[p++] = 0x21; buf[p++] = 0xf9;  // Extension / Label.\n      buf[p++] = 4;  // Byte size.\n\n      buf[p++] = disposal << 2 | (use_transparency === true ? 1 : 0);\n      buf[p++] = delay & 0xff; buf[p++] = delay >> 8 & 0xff;\n      buf[p++] = transparent_index;  // Transparent color index.\n      buf[p++] = 0;  // Block Terminator.\n    }\n\n    // - Image Descriptor\n    buf[p++] = 0x2c;  // Image Seperator.\n    buf[p++] = x & 0xff; buf[p++] = x >> 8 & 0xff;  // Left.\n    buf[p++] = y & 0xff; buf[p++] = y >> 8 & 0xff;  // Top.\n    buf[p++] = w & 0xff; buf[p++] = w >> 8 & 0xff;\n    buf[p++] = h & 0xff; buf[p++] = h >> 8 & 0xff;\n    // NOTE: No sort flag (unused?).\n    // TODO(deanm): Support interlace.\n    buf[p++] = using_local_palette === true ? (0x80 | (min_code_size-1)) : 0;\n\n    // - Local Color Table\n    if (using_local_palette === true) {\n      for (var i = 0, il = palette.length; i < il; ++i) {\n        var rgb = palette[i];\n        buf[p++] = rgb >> 16 & 0xff;\n        buf[p++] = rgb >> 8 & 0xff;\n        buf[p++] = rgb & 0xff;\n      }\n    }\n\n    p = GifWriterOutputLZWCodeStream(\n            buf, p, min_code_size < 2 ? 2 : min_code_size, indexed_pixels);\n\n    return p;\n  };\n\n  this.end = function() {\n    if (ended === false) {\n      buf[p++] = 0x3b;  // Trailer.\n      ended = true;\n    }\n    return p;\n  };\n\n  this.getOutputBuffer = function() { return buf; };\n  this.setOutputBuffer = function(v) { buf = v; };\n  this.getOutputBufferPosition = function() { return p; };\n  this.setOutputBufferPosition = function(v) { p = v; };\n}\n\n// Main compression routine, palette indexes -> LZW code stream.\n// |index_stream| must have at least one entry.\nfunction GifWriterOutputLZWCodeStream(buf, p, min_code_size, index_stream) {\n  buf[p++] = min_code_size;\n  var cur_subblock = p++;  // Pointing at the length field.\n\n  var clear_code = 1 << min_code_size;\n  var code_mask = clear_code - 1;\n  var eoi_code = clear_code + 1;\n  var next_code = eoi_code + 1;\n\n  var cur_code_size = min_code_size + 1;  // Number of bits per code.\n  var cur_shift = 0;\n  // We have at most 12-bit codes, so we should have to hold a max of 19\n  // bits here (and then we would write out).\n  var cur = 0;\n\n  function emit_bytes_to_buffer(bit_block_size) {\n    while (cur_shift >= bit_block_size) {\n      buf[p++] = cur & 0xff;\n      cur >>= 8; cur_shift -= 8;\n      if (p === cur_subblock + 256) {  // Finished a subblock.\n        buf[cur_subblock] = 255;\n        cur_subblock = p++;\n      }\n    }\n  }\n\n  function emit_code(c) {\n    cur |= c << cur_shift;\n    cur_shift += cur_code_size;\n    emit_bytes_to_buffer(8);\n  }\n\n  // I am not an expert on the topic, and I don\'t want to write a thesis.\n  // However, it is good to outline here the basic algorithm and the few data\n  // structures and optimizations here that make this implementation fast.\n  // The basic idea behind LZW is to build a table of previously seen runs\n  // addressed by a short id (herein called output code).  All data is\n  // referenced by a code, which represents one or more values from the\n  // original input stream.  All input bytes can be referenced as the same\n  // value as an output code.  So if you didn\'t want any compression, you\n  // could more or less just output the original bytes as codes (there are\n  // some details to this, but it is the idea).  In order to achieve\n  // compression, values greater then the input range (codes can be up to\n  // 12-bit while input only 8-bit) represent a sequence of previously seen\n  // inputs.  The decompressor is able to build the same mapping while\n  // decoding, so there is always a shared common knowledge between the\n  // encoding and decoder, which is also important for "timing" aspects like\n  // how to handle variable bit width code encoding.\n  //\n  // One obvious but very important consequence of the table system is there\n  // is always a unique id (at most 12-bits) to map the runs.  \'A\' might be\n  // 4, then \'AA\' might be 10, \'AAA\' 11, \'AAAA\' 12, etc.  This relationship\n  // can be used for an effecient lookup strategy for the code mapping.  We\n  // need to know if a run has been seen before, and be able to map that run\n  // to the output code.  Since we start with known unique ids (input bytes),\n  // and then from those build more unique ids (table entries), we can\n  // continue this chain (almost like a linked list) to always have small\n  // integer values that represent the current byte chains in the encoder.\n  // This means instead of tracking the input bytes (AAAABCD) to know our\n  // current state, we can track the table entry for AAAABC (it is guaranteed\n  // to exist by the nature of the algorithm) and the next character D.\n  // Therefor the tuple of (table_entry, byte) is guaranteed to also be\n  // unique.  This allows us to create a simple lookup key for mapping input\n  // sequences to codes (table indices) without having to store or search\n  // any of the code sequences.  So if \'AAAA\' has a table entry of 12, the\n  // tuple of (\'AAAA\', K) for any input byte K will be unique, and can be our\n  // key.  This leads to a integer value at most 20-bits, which can always\n  // fit in an SMI value and be used as a fast sparse array / object key.\n\n  // Output code for the current contents of the index buffer.\n  var ib_code = index_stream[0] & code_mask;  // Load first input index.\n  var code_table = { };  // Key\'d on our 20-bit "tuple".\n\n  emit_code(clear_code);  // Spec says first code should be a clear code.\n\n  // First index already loaded, process the rest of the stream.\n  for (var i = 1, il = index_stream.length; i < il; ++i) {\n    var k = index_stream[i] & code_mask;\n    var cur_key = ib_code << 8 | k;  // (prev, k) unique tuple.\n    var cur_code = code_table[cur_key];  // buffer + k.\n\n    // Check if we have to create a new code table entry.\n    if (cur_code === undefined) {  // We don\'t have buffer + k.\n      // Emit index buffer (without k).\n      // This is an inline version of emit_code, because this is the core\n      // writing routine of the compressor (and V8 cannot inline emit_code\n      // because it is a closure here in a different context).  Additionally\n      // we can call emit_byte_to_buffer less often, because we can have\n      // 30-bits (from our 31-bit signed SMI), and we know our codes will only\n      // be 12-bits, so can safely have 18-bits there without overflow.\n      // emit_code(ib_code);\n      cur |= ib_code << cur_shift;\n      cur_shift += cur_code_size;\n      while (cur_shift >= 8) {\n        buf[p++] = cur & 0xff;\n        cur >>= 8; cur_shift -= 8;\n        if (p === cur_subblock + 256) {  // Finished a subblock.\n          buf[cur_subblock] = 255;\n          cur_subblock = p++;\n        }\n      }\n\n      if (next_code === 4096) {  // Table full, need a clear.\n        emit_code(clear_code);\n        next_code = eoi_code + 1;\n        cur_code_size = min_code_size + 1;\n        code_table = { };\n      } else {  // Table not full, insert a new entry.\n        // Increase our variable bit code sizes if necessary.  This is a bit\n        // tricky as it is based on "timing" between the encoding and\n        // decoder.  From the encoders perspective this should happen after\n        // we\'ve already emitted the index buffer and are about to create the\n        // first table entry that would overflow our current code bit size.\n        if (next_code >= (1 << cur_code_size)) ++cur_code_size;\n        code_table[cur_key] = next_code++;  // Insert into code table.\n      }\n\n      ib_code = k;  // Index buffer to single input k.\n    } else {\n      ib_code = cur_code;  // Index buffer to sequence in code table.\n    }\n  }\n\n  emit_code(ib_code);  // There will still be something in the index buffer.\n  emit_code(eoi_code);  // End Of Information.\n\n  // Flush / finalize the sub-blocks stream to the buffer.\n  emit_bytes_to_buffer(1);\n\n  // Finish the sub-blocks, writing out any unfinished lengths and\n  // terminating with a sub-block of length 0.  If we have already started\n  // but not yet used a sub-block it can just become the terminator.\n  if (cur_subblock + 1 === p) {  // Started but unused.\n    buf[cur_subblock] = 0;\n  } else {  // Started and used, write length and additional terminator block.\n    buf[cur_subblock] = p - cur_subblock - 1;\n    buf[p++] = 0;\n  }\n  return p;\n}\n\nfunction GifReader(buf) {\n  var p = 0;\n\n  // - Header (GIF87a or GIF89a).\n  if (buf[p++] !== 0x47 ||            buf[p++] !== 0x49 || buf[p++] !== 0x46 ||\n      buf[p++] !== 0x38 || (buf[p++]+1 & 0xfd) !== 0x38 || buf[p++] !== 0x61) {\n    throw new Error("Invalid GIF 87a/89a header.");\n  }\n\n  // - Logical Screen Descriptor.\n  var width = buf[p++] | buf[p++] << 8;\n  var height = buf[p++] | buf[p++] << 8;\n  var pf0 = buf[p++];  // <Packed Fields>.\n  var global_palette_flag = pf0 >> 7;\n  var num_global_colors_pow2 = pf0 & 0x7;\n  var num_global_colors = 1 << (num_global_colors_pow2 + 1);\n  var background = buf[p++];\n  buf[p++];  // Pixel aspect ratio (unused?).\n\n  var global_palette_offset = null;\n  var global_palette_size   = null;\n\n  if (global_palette_flag) {\n    global_palette_offset = p;\n    global_palette_size = num_global_colors;\n    p += num_global_colors * 3;  // Seek past palette.\n  }\n\n  var no_eof = true;\n\n  var frames = [ ];\n\n  var delay = 0;\n  var transparent_index = null;\n  var disposal = 0;  // 0 - No disposal specified.\n  var loop_count = null;\n\n  this.width = width;\n  this.height = height;\n\n  while (no_eof && p < buf.length) {\n    switch (buf[p++]) {\n      case 0x21:  // Graphics Control Extension Block\n        switch (buf[p++]) {\n          case 0xff:  // Application specific block\n            // Try if it\'s a Netscape block (with animation loop counter).\n            if (buf[p   ] !== 0x0b ||  // 21 FF already read, check block size.\n                // NETSCAPE2.0\n                buf[p+1 ] == 0x4e && buf[p+2 ] == 0x45 && buf[p+3 ] == 0x54 &&\n                buf[p+4 ] == 0x53 && buf[p+5 ] == 0x43 && buf[p+6 ] == 0x41 &&\n                buf[p+7 ] == 0x50 && buf[p+8 ] == 0x45 && buf[p+9 ] == 0x32 &&\n                buf[p+10] == 0x2e && buf[p+11] == 0x30 &&\n                // Sub-block\n                buf[p+12] == 0x03 && buf[p+13] == 0x01 && buf[p+16] == 0) {\n              p += 14;\n              loop_count = buf[p++] | buf[p++] << 8;\n              p++;  // Skip terminator.\n            } else {  // We don\'t know what it is, just try to get past it.\n              p += 12;\n              while (true) {  // Seek through subblocks.\n                var block_size = buf[p++];\n                // Bad block size (ex: undefined from an out of bounds read).\n                if (!(block_size >= 0)) throw Error("Invalid block size");\n                if (block_size === 0) break;  // 0 size is terminator\n                p += block_size;\n              }\n            }\n            break;\n\n          case 0xf9:  // Graphics Control Extension\n            if (buf[p++] !== 0x4 || buf[p+4] !== 0)\n              throw new Error("Invalid graphics extension block.");\n            var pf1 = buf[p++];\n            delay = buf[p++] | buf[p++] << 8;\n            transparent_index = buf[p++];\n            if ((pf1 & 1) === 0) transparent_index = null;\n            disposal = pf1 >> 2 & 0x7;\n            p++;  // Skip terminator.\n            break;\n\n          case 0xfe:  // Comment Extension.\n            while (true) {  // Seek through subblocks.\n              var block_size = buf[p++];\n              // Bad block size (ex: undefined from an out of bounds read).\n              if (!(block_size >= 0)) throw Error("Invalid block size");\n              if (block_size === 0) break;  // 0 size is terminator\n              // console.log(buf.slice(p, p+block_size).toString(\'ascii\'));\n              p += block_size;\n            }\n            break;\n\n          default:\n            throw new Error(\n                "Unknown graphic control label: 0x" + buf[p-1].toString(16));\n        }\n        break;\n\n      case 0x2c:  // Image Descriptor.\n        var x = buf[p++] | buf[p++] << 8;\n        var y = buf[p++] | buf[p++] << 8;\n        var w = buf[p++] | buf[p++] << 8;\n        var h = buf[p++] | buf[p++] << 8;\n        var pf2 = buf[p++];\n        var local_palette_flag = pf2 >> 7;\n        var interlace_flag = pf2 >> 6 & 1;\n        var num_local_colors_pow2 = pf2 & 0x7;\n        var num_local_colors = 1 << (num_local_colors_pow2 + 1);\n        var palette_offset = global_palette_offset;\n        var palette_size = global_palette_size;\n        var has_local_palette = false;\n        if (local_palette_flag) {\n          var has_local_palette = true;\n          palette_offset = p;  // Override with local palette.\n          palette_size = num_local_colors;\n          p += num_local_colors * 3;  // Seek past palette.\n        }\n\n        var data_offset = p;\n\n        p++;  // codesize\n        while (true) {\n          var block_size = buf[p++];\n          // Bad block size (ex: undefined from an out of bounds read).\n          if (!(block_size >= 0)) throw Error("Invalid block size");\n          if (block_size === 0) break;  // 0 size is terminator\n          p += block_size;\n        }\n\n        frames.push({x: x, y: y, width: w, height: h,\n                     has_local_palette: has_local_palette,\n                     palette_offset: palette_offset,\n                     palette_size: palette_size,\n                     data_offset: data_offset,\n                     data_length: p - data_offset,\n                     transparent_index: transparent_index,\n                     interlaced: !!interlace_flag,\n                     delay: delay,\n                     disposal: disposal});\n        break;\n\n      case 0x3b:  // Trailer Marker (end of file).\n        no_eof = false;\n        break;\n\n      default:\n        throw new Error("Unknown gif block: 0x" + buf[p-1].toString(16));\n        break;\n    }\n  }\n\n  this.numFrames = function() {\n    return frames.length;\n  };\n\n  this.loopCount = function() {\n    return loop_count;\n  };\n\n  this.frameInfo = function(frame_num) {\n    if (frame_num < 0 || frame_num >= frames.length)\n      throw new Error("Frame index out of range.");\n    return frames[frame_num];\n  }\n\n  this.decodeAndBlitFrameBGRA = function(frame_num, pixels) {\n    var frame = this.frameInfo(frame_num);\n    var num_pixels = frame.width * frame.height;\n    var index_stream = new Uint8Array(num_pixels);  // At most 8-bit indices.\n    GifReaderLZWOutputIndexStream(\n        buf, frame.data_offset, index_stream, num_pixels);\n    var palette_offset = frame.palette_offset;\n\n    // NOTE(deanm): It seems to be much faster to compare index to 256 than\n    // to === null.  Not sure why, but CompareStub_EQ_STRICT shows up high in\n    // the profile, not sure if it\'s related to using a Uint8Array.\n    var trans = frame.transparent_index;\n    if (trans === null) trans = 256;\n\n    // We are possibly just blitting to a portion of the entire frame.\n    // That is a subrect within the framerect, so the additional pixels\n    // must be skipped over after we finished a scanline.\n    var framewidth  = frame.width;\n    var framestride = width - framewidth;\n    var xleft       = framewidth;  // Number of subrect pixels left in scanline.\n\n    // Output indicies of the top left and bottom right corners of the subrect.\n    var opbeg = ((frame.y * width) + frame.x) * 4;\n    var opend = ((frame.y + frame.height) * width + frame.x) * 4;\n    var op    = opbeg;\n\n    var scanstride = framestride * 4;\n\n    // Use scanstride to skip past the rows when interlacing.  This is skipping\n    // 7 rows for the first two passes, then 3 then 1.\n    if (frame.interlaced === true) {\n      scanstride += width * 4 * 7;  // Pass 1.\n    }\n\n    var interlaceskip = 8;  // Tracking the row interval in the current pass.\n\n    for (var i = 0, il = index_stream.length; i < il; ++i) {\n      var index = index_stream[i];\n\n      if (xleft === 0) {  // Beginning of new scan line\n        op += scanstride;\n        xleft = framewidth;\n        if (op >= opend) { // Catch the wrap to switch passes when interlacing.\n          scanstride = framestride * 4 + width * 4 * (interlaceskip-1);\n          // interlaceskip / 2 * 4 is interlaceskip << 1.\n          op = opbeg + (framewidth + framestride) * (interlaceskip << 1);\n          interlaceskip >>= 1;\n        }\n      }\n\n      if (index === trans) {\n        op += 4;\n      } else {\n        var r = buf[palette_offset + index * 3];\n        var g = buf[palette_offset + index * 3 + 1];\n        var b = buf[palette_offset + index * 3 + 2];\n        pixels[op++] = b;\n        pixels[op++] = g;\n        pixels[op++] = r;\n        pixels[op++] = 255;\n      }\n      --xleft;\n    }\n  };\n\n  // I will go to copy and paste hell one day...\n  this.decodeAndBlitFrameRGBA = function(frame_num, pixels) {\n    var frame = this.frameInfo(frame_num);\n    var num_pixels = frame.width * frame.height;\n    var index_stream = new Uint8Array(num_pixels);  // At most 8-bit indices.\n    GifReaderLZWOutputIndexStream(\n        buf, frame.data_offset, index_stream, num_pixels);\n    var palette_offset = frame.palette_offset;\n\n    // NOTE(deanm): It seems to be much faster to compare index to 256 than\n    // to === null.  Not sure why, but CompareStub_EQ_STRICT shows up high in\n    // the profile, not sure if it\'s related to using a Uint8Array.\n    var trans = frame.transparent_index;\n    if (trans === null) trans = 256;\n\n    // We are possibly just blitting to a portion of the entire frame.\n    // That is a subrect within the framerect, so the additional pixels\n    // must be skipped over after we finished a scanline.\n    var framewidth  = frame.width;\n    var framestride = width - framewidth;\n    var xleft       = framewidth;  // Number of subrect pixels left in scanline.\n\n    // Output indicies of the top left and bottom right corners of the subrect.\n    var opbeg = ((frame.y * width) + frame.x) * 4;\n    var opend = ((frame.y + frame.height) * width + frame.x) * 4;\n    var op    = opbeg;\n\n    var scanstride = framestride * 4;\n\n    // Use scanstride to skip past the rows when interlacing.  This is skipping\n    // 7 rows for the first two passes, then 3 then 1.\n    if (frame.interlaced === true) {\n      scanstride += width * 4 * 7;  // Pass 1.\n    }\n\n    var interlaceskip = 8;  // Tracking the row interval in the current pass.\n\n    for (var i = 0, il = index_stream.length; i < il; ++i) {\n      var index = index_stream[i];\n\n      if (xleft === 0) {  // Beginning of new scan line\n        op += scanstride;\n        xleft = framewidth;\n        if (op >= opend) { // Catch the wrap to switch passes when interlacing.\n          scanstride = framestride * 4 + width * 4 * (interlaceskip-1);\n          // interlaceskip / 2 * 4 is interlaceskip << 1.\n          op = opbeg + (framewidth + framestride) * (interlaceskip << 1);\n          interlaceskip >>= 1;\n        }\n      }\n\n      if (index === trans) {\n        op += 4;\n      } else {\n        var r = buf[palette_offset + index * 3];\n        var g = buf[palette_offset + index * 3 + 1];\n        var b = buf[palette_offset + index * 3 + 2];\n        pixels[op++] = r;\n        pixels[op++] = g;\n        pixels[op++] = b;\n        pixels[op++] = 255;\n      }\n      --xleft;\n    }\n  };\n}\n\nfunction GifReaderLZWOutputIndexStream(code_stream, p, output, output_length) {\n  var min_code_size = code_stream[p++];\n\n  var clear_code = 1 << min_code_size;\n  var eoi_code = clear_code + 1;\n  var next_code = eoi_code + 1;\n\n  var cur_code_size = min_code_size + 1;  // Number of bits per code.\n  // NOTE: This shares the same name as the encoder, but has a different\n  // meaning here.  Here this masks each code coming from the code stream.\n  var code_mask = (1 << cur_code_size) - 1;\n  var cur_shift = 0;\n  var cur = 0;\n\n  var op = 0;  // Output pointer.\n\n  var subblock_size = code_stream[p++];\n\n  // TODO(deanm): Would using a TypedArray be any faster?  At least it would\n  // solve the fast mode / backing store uncertainty.\n  // var code_table = Array(4096);\n  var code_table = new Int32Array(4096);  // Can be signed, we only use 20 bits.\n\n  var prev_code = null;  // Track code-1.\n\n  while (true) {\n    // Read up to two bytes, making sure we always 12-bits for max sized code.\n    while (cur_shift < 16) {\n      if (subblock_size === 0) break;  // No more data to be read.\n\n      cur |= code_stream[p++] << cur_shift;\n      cur_shift += 8;\n\n      if (subblock_size === 1) {  // Never let it get to 0 to hold logic above.\n        subblock_size = code_stream[p++];  // Next subblock.\n      } else {\n        --subblock_size;\n      }\n    }\n\n    // TODO(deanm): We should never really get here, we should have received\n    // and EOI.\n    if (cur_shift < cur_code_size)\n      break;\n\n    var code = cur & code_mask;\n    cur >>= cur_code_size;\n    cur_shift -= cur_code_size;\n\n    // TODO(deanm): Maybe should check that the first code was a clear code,\n    // at least this is what you\'re supposed to do.  But actually our encoder\n    // now doesn\'t emit a clear code first anyway.\n    if (code === clear_code) {\n      // We don\'t actually have to clear the table.  This could be a good idea\n      // for greater error checking, but we don\'t really do any anyway.  We\n      // will just track it with next_code and overwrite old entries.\n\n      next_code = eoi_code + 1;\n      cur_code_size = min_code_size + 1;\n      code_mask = (1 << cur_code_size) - 1;\n\n      // Don\'t update prev_code ?\n      prev_code = null;\n      continue;\n    } else if (code === eoi_code) {\n      break;\n    }\n\n    // We have a similar situation as the decoder, where we want to store\n    // variable length entries (code table entries), but we want to do in a\n    // faster manner than an array of arrays.  The code below stores sort of a\n    // linked list within the code table, and then "chases" through it to\n    // construct the dictionary entries.  When a new entry is created, just the\n    // last byte is stored, and the rest (prefix) of the entry is only\n    // referenced by its table entry.  Then the code chases through the\n    // prefixes until it reaches a single byte code.  We have to chase twice,\n    // first to compute the length, and then to actually copy the data to the\n    // output (backwards, since we know the length).  The alternative would be\n    // storing something in an intermediate stack, but that doesn\'t make any\n    // more sense.  I implemented an approach where it also stored the length\n    // in the code table, although it\'s a bit tricky because you run out of\n    // bits (12 + 12 + 8), but I didn\'t measure much improvements (the table\n    // entries are generally not the long).  Even when I created benchmarks for\n    // very long table entries the complexity did not seem worth it.\n    // The code table stores the prefix entry in 12 bits and then the suffix\n    // byte in 8 bits, so each entry is 20 bits.\n\n    var chase_code = code < next_code ? code : prev_code;\n\n    // Chase what we will output, either {CODE} or {CODE-1}.\n    var chase_length = 0;\n    var chase = chase_code;\n    while (chase > clear_code) {\n      chase = code_table[chase] >> 8;\n      ++chase_length;\n    }\n\n    var k = chase;\n\n    var op_end = op + chase_length + (chase_code !== code ? 1 : 0);\n    if (op_end > output_length) {\n      console.log("Warning, gif stream longer than expected.");\n      return;\n    }\n\n    // Already have the first byte from the chase, might as well write it fast.\n    output[op++] = k;\n\n    op += chase_length;\n    var b = op;  // Track pointer, writing backwards.\n\n    if (chase_code !== code)  // The case of emitting {CODE-1} + k.\n      output[op++] = k;\n\n    chase = chase_code;\n    while (chase_length--) {\n      chase = code_table[chase];\n      output[--b] = chase & 0xff;  // Write backwards.\n      chase >>= 8;  // Pull down to the prefix code.\n    }\n\n    if (prev_code !== null && next_code < 4096) {\n      code_table[next_code++] = prev_code << 8 | k;\n      // TODO(deanm): Figure out this clearing vs code growth logic better.  I\n      // have an feeling that it should just happen somewhere else, for now it\n      // is awkward between when we grow past the max and then hit a clear code.\n      // For now just check if we hit the max 12-bits (then a clear code should\n      // follow, also of course encoded in 12-bits).\n      if (next_code >= code_mask+1 && cur_code_size < 12) {\n        ++cur_code_size;\n        code_mask = code_mask << 1 | 1;\n      }\n    }\n\n    prev_code = code;\n  }\n\n  if (op !== output_length) {\n    console.log("Warning, gif stream shorter than expected.");\n  }\n\n  return output;\n}\n\n// CommonJS.\ntry { exports.GifWriter = GifWriter; exports.GifReader = GifReader } catch(e) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbWFnZUNvbnZlcnNpb24vLi9ub2RlX21vZHVsZXMvb21nZ2lmL29tZ2dpZi5qcz84ZjQ0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViO0FBQ0E7O0FBRUEscUNBQXFDLEVBQUU7QUFDdkM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsaUJBQWlCLGlCQUFpQjtBQUNwRCxrQkFBa0IsaUJBQWlCLGlCQUFpQjs7QUFFcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLHdCQUF3QjtBQUN4QixlQUFlOztBQUVmO0FBQ0E7QUFDQSwrQ0FBK0MsUUFBUTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQSxvQkFBb0IsaUJBQWlCLGlCQUFpQjtBQUN0RCxvQkFBb0IsaUJBQWlCLGlCQUFpQjtBQUN0RCxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0Esb0JBQW9CO0FBQ3BCLGlDQUFpQztBQUNqQyxvQkFBb0I7QUFDcEI7OztBQUdBOztBQUVBO0FBQ0EseUJBQXlCLEtBQUssZUFBZSxFQUFFOztBQUUvQyxpQ0FBaUMsRUFBRTs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7O0FB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QUVBO0FBQ0EsZUFBZTs7QUFFZix1REFBdUQsT0FBTztBQUM5RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMsa0JBQWtCO0FBQ2xCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSywrQkFBK0IsZ0NBQWdDIiwiZmlsZSI6IjAuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvLyAoYykgRGVhbiBNY05hbWVlIDxkZWFuQGdtYWlsLmNvbT4sIDIwMTMuXG4vL1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL2RlYW5tL29tZ2dpZlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvXG4vLyBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZVxuLy8gcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yXG4vLyBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXG4vLyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTXG4vLyBJTiBUSEUgU09GVFdBUkUuXG4vL1xuLy8gb21nZ2lmIGlzIGEgSmF2YVNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiBhIEdJRiA4OWEgZW5jb2RlciBhbmQgZGVjb2Rlcixcbi8vIGluY2x1ZGluZyBhbmltYXRpb24gYW5kIGNvbXByZXNzaW9uLiAgSXQgZG9lcyBub3QgcmVseSBvbiBhbnkgc3BlY2lmaWNcbi8vIHVuZGVybHlpbmcgc3lzdGVtLCBzbyBzaG91bGQgcnVuIGluIHRoZSBicm93c2VyLCBOb2RlLCBvciBQbGFzay5cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIEdpZldyaXRlcihidWYsIHdpZHRoLCBoZWlnaHQsIGdvcHRzKSB7XG4gIHZhciBwID0gMDtcblxuICB2YXIgZ29wdHMgPSBnb3B0cyA9PT0gdW5kZWZpbmVkID8geyB9IDogZ29wdHM7XG4gIHZhciBsb29wX2NvdW50ID0gZ29wdHMubG9vcCA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGdvcHRzLmxvb3A7XG4gIHZhciBnbG9iYWxfcGFsZXR0ZSA9IGdvcHRzLnBhbGV0dGUgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBnb3B0cy5wYWxldHRlO1xuXG4gIGlmICh3aWR0aCA8PSAwIHx8IGhlaWdodCA8PSAwIHx8IHdpZHRoID4gNjU1MzUgfHwgaGVpZ2h0ID4gNjU1MzUpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiV2lkdGgvSGVpZ2h0IGludmFsaWQuXCIpO1xuXG4gIGZ1bmN0aW9uIGNoZWNrX3BhbGV0dGVfYW5kX251bV9jb2xvcnMocGFsZXR0ZSkge1xuICAgIHZhciBudW1fY29sb3JzID0gcGFsZXR0ZS5sZW5ndGg7XG4gICAgaWYgKG51bV9jb2xvcnMgPCAyIHx8IG51bV9jb2xvcnMgPiAyNTYgfHwgIG51bV9jb2xvcnMgJiAobnVtX2NvbG9ycy0xKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIFwiSW52YWxpZCBjb2RlL2NvbG9yIGxlbmd0aCwgbXVzdCBiZSBwb3dlciBvZiAyIGFuZCAyIC4uIDI1Ni5cIik7XG4gICAgfVxuICAgIHJldHVybiBudW1fY29sb3JzO1xuICB9XG5cbiAgLy8gLSBIZWFkZXIuXG4gIGJ1ZltwKytdID0gMHg0NzsgYnVmW3ArK10gPSAweDQ5OyBidWZbcCsrXSA9IDB4NDY7ICAvLyBHSUZcbiAgYnVmW3ArK10gPSAweDM4OyBidWZbcCsrXSA9IDB4Mzk7IGJ1ZltwKytdID0gMHg2MTsgIC8vIDg5YVxuXG4gIC8vIEhhbmRsaW5nIG9mIEdsb2JhbCBDb2xvciBUYWJsZSAocGFsZXR0ZSkgYW5kIGJhY2tncm91bmQgaW5kZXguXG4gIHZhciBncF9udW1fY29sb3JzX3BvdzIgPSAwO1xuICB2YXIgYmFja2dyb3VuZCA9IDA7XG4gIGlmIChnbG9iYWxfcGFsZXR0ZSAhPT0gbnVsbCkge1xuICAgIHZhciBncF9udW1fY29sb3JzID0gY2hlY2tfcGFsZXR0ZV9hbmRfbnVtX2NvbG9ycyhnbG9iYWxfcGFsZXR0ZSk7XG4gICAgd2hpbGUgKGdwX251bV9jb2xvcnMgPj49IDEpICsrZ3BfbnVtX2NvbG9yc19wb3cyO1xuICAgIGdwX251bV9jb2xvcnMgPSAxIDw8IGdwX251bV9jb2xvcnNfcG93MjtcbiAgICAtLWdwX251bV9jb2xvcnNfcG93MjtcbiAgICBpZiAoZ29wdHMuYmFja2dyb3VuZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBiYWNrZ3JvdW5kID0gZ29wdHMuYmFja2dyb3VuZDtcbiAgICAgIGlmIChiYWNrZ3JvdW5kID49IGdwX251bV9jb2xvcnMpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJhY2tncm91bmQgaW5kZXggb3V0IG9mIHJhbmdlLlwiKTtcbiAgICAgIC8vIFRoZSBHSUYgc3BlYyBzdGF0ZXMgdGhhdCBhIGJhY2tncm91bmQgaW5kZXggb2YgMCBzaG91bGQgYmUgaWdub3JlZCwgc29cbiAgICAgIC8vIHRoaXMgaXMgcHJvYmFibHkgYSBtaXN0YWtlIGFuZCB5b3UgcmVhbGx5IHdhbnQgdG8gc2V0IGl0IHRvIGFub3RoZXJcbiAgICAgIC8vIHNsb3QgaW4gdGhlIHBhbGV0dGUuICBCdXQgYWN0dWFsbHkgaW4gdGhlIGVuZCBtb3N0IGJyb3dzZXJzLCBldGMgZW5kXG4gICAgICAvLyB1cCBpZ25vcmluZyB0aGlzIGFsbW9zdCBjb21wbGV0ZWx5IChpbmNsdWRpbmcgZm9yIGRpc3Bvc2UgYmFja2dyb3VuZCkuXG4gICAgICBpZiAoYmFja2dyb3VuZCA9PT0gMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQmFja2dyb3VuZCBpbmRleCBleHBsaWNpdGx5IHBhc3NlZCBhcyAwLlwiKTtcbiAgICB9XG4gIH1cblxuICAvLyAtIExvZ2ljYWwgU2NyZWVuIERlc2NyaXB0b3IuXG4gIC8vIE5PVEUoZGVhbm0pOiB3L2ggYXBwYXJlbnRseSBpZ25vcmVkIGJ5IGltcGxlbWVudGF0aW9ucywgYnV0IHNldCBhbnl3YXkuXG4gIGJ1ZltwKytdID0gd2lkdGggJiAweGZmOyBidWZbcCsrXSA9IHdpZHRoID4+IDggJiAweGZmO1xuICBidWZbcCsrXSA9IGhlaWdodCAmIDB4ZmY7IGJ1ZltwKytdID0gaGVpZ2h0ID4+IDggJiAweGZmO1xuICAvLyBOT1RFOiBJbmRpY2F0ZXMgMC1icHAgb3JpZ2luYWwgY29sb3IgcmVzb2x1dGlvbiAodW51c2VkPykuXG4gIGJ1ZltwKytdID0gKGdsb2JhbF9wYWxldHRlICE9PSBudWxsID8gMHg4MCA6IDApIHwgIC8vIEdsb2JhbCBDb2xvciBUYWJsZSBGbGFnLlxuICAgICAgICAgICAgIGdwX251bV9jb2xvcnNfcG93MjsgIC8vIE5PVEU6IE5vIHNvcnQgZmxhZyAodW51c2VkPykuXG4gIGJ1ZltwKytdID0gYmFja2dyb3VuZDsgIC8vIEJhY2tncm91bmQgQ29sb3IgSW5kZXguXG4gIGJ1ZltwKytdID0gMDsgIC8vIFBpeGVsIGFzcGVjdCByYXRpbyAodW51c2VkPykuXG5cbiAgLy8gLSBHbG9iYWwgQ29sb3IgVGFibGVcbiAgaWYgKGdsb2JhbF9wYWxldHRlICE9PSBudWxsKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGlsID0gZ2xvYmFsX3BhbGV0dGUubGVuZ3RoOyBpIDwgaWw7ICsraSkge1xuICAgICAgdmFyIHJnYiA9IGdsb2JhbF9wYWxldHRlW2ldO1xuICAgICAgYnVmW3ArK10gPSByZ2IgPj4gMTYgJiAweGZmO1xuICAgICAgYnVmW3ArK10gPSByZ2IgPj4gOCAmIDB4ZmY7XG4gICAgICBidWZbcCsrXSA9IHJnYiAmIDB4ZmY7XG4gICAgfVxuICB9XG5cbiAgaWYgKGxvb3BfY291bnQgIT09IG51bGwpIHsgIC8vIE5ldHNjYXBlIGJsb2NrIGZvciBsb29waW5nLlxuICAgIGlmIChsb29wX2NvdW50IDwgMCB8fCBsb29wX2NvdW50ID4gNjU1MzUpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJMb29wIGNvdW50IGludmFsaWQuXCIpXG4gICAgLy8gRXh0ZW5zaW9uIGNvZGUsIGxhYmVsLCBhbmQgbGVuZ3RoLlxuICAgIGJ1ZltwKytdID0gMHgyMTsgYnVmW3ArK10gPSAweGZmOyBidWZbcCsrXSA9IDB4MGI7XG4gICAgLy8gTkVUU0NBUEUyLjBcbiAgICBidWZbcCsrXSA9IDB4NGU7IGJ1ZltwKytdID0gMHg0NTsgYnVmW3ArK10gPSAweDU0OyBidWZbcCsrXSA9IDB4NTM7XG4gICAgYnVmW3ArK10gPSAweDQzOyBidWZbcCsrXSA9IDB4NDE7IGJ1ZltwKytdID0gMHg1MDsgYnVmW3ArK10gPSAweDQ1O1xuICAgIGJ1ZltwKytdID0gMHgzMjsgYnVmW3ArK10gPSAweDJlOyBidWZbcCsrXSA9IDB4MzA7XG4gICAgLy8gU3ViLWJsb2NrXG4gICAgYnVmW3ArK10gPSAweDAzOyBidWZbcCsrXSA9IDB4MDE7XG4gICAgYnVmW3ArK10gPSBsb29wX2NvdW50ICYgMHhmZjsgYnVmW3ArK10gPSBsb29wX2NvdW50ID4+IDggJiAweGZmO1xuICAgIGJ1ZltwKytdID0gMHgwMDsgIC8vIFRlcm1pbmF0b3IuXG4gIH1cblxuXG4gIHZhciBlbmRlZCA9IGZhbHNlO1xuXG4gIHRoaXMuYWRkRnJhbWUgPSBmdW5jdGlvbih4LCB5LCB3LCBoLCBpbmRleGVkX3BpeGVscywgb3B0cykge1xuICAgIGlmIChlbmRlZCA9PT0gdHJ1ZSkgeyAtLXA7IGVuZGVkID0gZmFsc2U7IH0gIC8vIFVuLWVuZC5cblxuICAgIG9wdHMgPSBvcHRzID09PSB1bmRlZmluZWQgPyB7IH0gOiBvcHRzO1xuXG4gICAgLy8gVE9ETyhkZWFubSk6IEJvdW5kcyBjaGVjayB4LCB5LiAgRG8gdGhleSBuZWVkIHRvIGJlIHdpdGhpbiB0aGUgdmlydHVhbFxuICAgIC8vIGNhbnZhcyB3aWR0aC9oZWlnaHQsIEkgaW1hZ2luZT9cbiAgICBpZiAoeCA8IDAgfHwgeSA8IDAgfHwgeCA+IDY1NTM1IHx8IHkgPiA2NTUzNSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIngveSBpbnZhbGlkLlwiKVxuXG4gICAgaWYgKHcgPD0gMCB8fCBoIDw9IDAgfHwgdyA+IDY1NTM1IHx8IGggPiA2NTUzNSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIldpZHRoL0hlaWdodCBpbnZhbGlkLlwiKVxuXG4gICAgaWYgKGluZGV4ZWRfcGl4ZWxzLmxlbmd0aCA8IHcgKiBoKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGVub3VnaCBwaXhlbHMgZm9yIHRoZSBmcmFtZSBzaXplLlwiKTtcblxuICAgIHZhciB1c2luZ19sb2NhbF9wYWxldHRlID0gdHJ1ZTtcbiAgICB2YXIgcGFsZXR0ZSA9IG9wdHMucGFsZXR0ZTtcbiAgICBpZiAocGFsZXR0ZSA9PT0gdW5kZWZpbmVkIHx8IHBhbGV0dGUgPT09IG51bGwpIHtcbiAgICAgIHVzaW5nX2xvY2FsX3BhbGV0dGUgPSBmYWxzZTtcbiAgICAgIHBhbGV0dGUgPSBnbG9iYWxfcGFsZXR0ZTtcbiAgICB9XG5cbiAgICBpZiAocGFsZXR0ZSA9PT0gdW5kZWZpbmVkIHx8IHBhbGV0dGUgPT09IG51bGwpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHN1cHBseSBlaXRoZXIgYSBsb2NhbCBvciBnbG9iYWwgcGFsZXR0ZS5cIik7XG5cbiAgICB2YXIgbnVtX2NvbG9ycyA9IGNoZWNrX3BhbGV0dGVfYW5kX251bV9jb2xvcnMocGFsZXR0ZSk7XG5cbiAgICAvLyBDb21wdXRlIHRoZSBtaW5fY29kZV9zaXplIChwb3dlciBvZiAyKSwgZGVzdHJveWluZyBudW1fY29sb3JzLlxuICAgIHZhciBtaW5fY29kZV9zaXplID0gMDtcbiAgICB3aGlsZSAobnVtX2NvbG9ycyA+Pj0gMSkgKyttaW5fY29kZV9zaXplO1xuICAgIG51bV9jb2xvcnMgPSAxIDw8IG1pbl9jb2RlX3NpemU7ICAvLyBOb3cgd2UgY2FuIGVhc2lseSBnZXQgaXQgYmFjay5cblxuICAgIHZhciBkZWxheSA9IG9wdHMuZGVsYXkgPT09IHVuZGVmaW5lZCA/IDAgOiBvcHRzLmRlbGF5O1xuXG4gICAgLy8gRnJvbSB0aGUgc3BlYzpcbiAgICAvLyAgICAgMCAtICAgTm8gZGlzcG9zYWwgc3BlY2lmaWVkLiBUaGUgZGVjb2RlciBpc1xuICAgIC8vICAgICAgICAgICBub3QgcmVxdWlyZWQgdG8gdGFrZSBhbnkgYWN0aW9uLlxuICAgIC8vICAgICAxIC0gICBEbyBub3QgZGlzcG9zZS4gVGhlIGdyYXBoaWMgaXMgdG8gYmUgbGVmdFxuICAgIC8vICAgICAgICAgICBpbiBwbGFjZS5cbiAgICAvLyAgICAgMiAtICAgUmVzdG9yZSB0byBiYWNrZ3JvdW5kIGNvbG9yLiBUaGUgYXJlYSB1c2VkIGJ5IHRoZVxuICAgIC8vICAgICAgICAgICBncmFwaGljIG11c3QgYmUgcmVzdG9yZWQgdG8gdGhlIGJhY2tncm91bmQgY29sb3IuXG4gICAgLy8gICAgIDMgLSAgIFJlc3RvcmUgdG8gcHJldmlvdXMuIFRoZSBkZWNvZGVyIGlzIHJlcXVpcmVkIHRvXG4gICAgLy8gICAgICAgICAgIHJlc3RvcmUgdGhlIGFyZWEgb3ZlcndyaXR0ZW4gYnkgdGhlIGdyYXBoaWMgd2l0aFxuICAgIC8vICAgICAgICAgICB3aGF0IHdhcyB0aGVyZSBwcmlvciB0byByZW5kZXJpbmcgdGhlIGdyYXBoaWMuXG4gICAgLy8gIDQtNyAtICAgIFRvIGJlIGRlZmluZWQuXG4gICAgLy8gTk9URShkZWFubSk6IERpc3Bvc2UgYmFja2dyb3VuZCBkb2Vzbid0IHJlYWxseSB3b3JrLCBhcHBhcmVudGx5IG1vc3RcbiAgICAvLyBicm93c2VycyBpZ25vcmUgdGhlIGJhY2tncm91bmQgcGFsZXR0ZSBpbmRleCBhbmQgY2xlYXIgdG8gdHJhbnNwYXJlbmN5LlxuICAgIHZhciBkaXNwb3NhbCA9IG9wdHMuZGlzcG9zYWwgPT09IHVuZGVmaW5lZCA/IDAgOiBvcHRzLmRpc3Bvc2FsO1xuICAgIGlmIChkaXNwb3NhbCA8IDAgfHwgZGlzcG9zYWwgPiAzKSAgLy8gNC03IGlzIHJlc2VydmVkLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGlzcG9zYWwgb3V0IG9mIHJhbmdlLlwiKTtcblxuICAgIHZhciB1c2VfdHJhbnNwYXJlbmN5ID0gZmFsc2U7XG4gICAgdmFyIHRyYW5zcGFyZW50X2luZGV4ID0gMDtcbiAgICBpZiAob3B0cy50cmFuc3BhcmVudCAhPT0gdW5kZWZpbmVkICYmIG9wdHMudHJhbnNwYXJlbnQgIT09IG51bGwpIHtcbiAgICAgIHVzZV90cmFuc3BhcmVuY3kgPSB0cnVlO1xuICAgICAgdHJhbnNwYXJlbnRfaW5kZXggPSBvcHRzLnRyYW5zcGFyZW50O1xuICAgICAgaWYgKHRyYW5zcGFyZW50X2luZGV4IDwgMCB8fCB0cmFuc3BhcmVudF9pbmRleCA+PSBudW1fY29sb3JzKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUcmFuc3BhcmVudCBjb2xvciBpbmRleC5cIik7XG4gICAgfVxuXG4gICAgaWYgKGRpc3Bvc2FsICE9PSAwIHx8IHVzZV90cmFuc3BhcmVuY3kgfHwgZGVsYXkgIT09IDApIHtcbiAgICAgIC8vIC0gR3JhcGhpY3MgQ29udHJvbCBFeHRlbnNpb25cbiAgICAgIGJ1ZltwKytdID0gMHgyMTsgYnVmW3ArK10gPSAweGY5OyAgLy8gRXh0ZW5zaW9uIC8gTGFiZWwuXG4gICAgICBidWZbcCsrXSA9IDQ7ICAvLyBCeXRlIHNpemUuXG5cbiAgICAgIGJ1ZltwKytdID0gZGlzcG9zYWwgPDwgMiB8ICh1c2VfdHJhbnNwYXJlbmN5ID09PSB0cnVlID8gMSA6IDApO1xuICAgICAgYnVmW3ArK10gPSBkZWxheSAmIDB4ZmY7IGJ1ZltwKytdID0gZGVsYXkgPj4gOCAmIDB4ZmY7XG4gICAgICBidWZbcCsrXSA9IHRyYW5zcGFyZW50X2luZGV4OyAgLy8gVHJhbnNwYXJlbnQgY29sb3IgaW5kZXguXG4gICAgICBidWZbcCsrXSA9IDA7ICAvLyBCbG9jayBUZXJtaW5hdG9yLlxuICAgIH1cblxuICAgIC8vIC0gSW1hZ2UgRGVzY3JpcHRvclxuICAgIGJ1ZltwKytdID0gMHgyYzsgIC8vIEltYWdlIFNlcGVyYXRvci5cbiAgICBidWZbcCsrXSA9IHggJiAweGZmOyBidWZbcCsrXSA9IHggPj4gOCAmIDB4ZmY7ICAvLyBMZWZ0LlxuICAgIGJ1ZltwKytdID0geSAmIDB4ZmY7IGJ1ZltwKytdID0geSA+PiA4ICYgMHhmZjsgIC8vIFRvcC5cbiAgICBidWZbcCsrXSA9IHcgJiAweGZmOyBidWZbcCsrXSA9IHcgPj4gOCAmIDB4ZmY7XG4gICAgYnVmW3ArK10gPSBoICYgMHhmZjsgYnVmW3ArK10gPSBoID4+IDggJiAweGZmO1xuICAgIC8vIE5PVEU6IE5vIHNvcnQgZmxhZyAodW51c2VkPykuXG4gICAgLy8gVE9ETyhkZWFubSk6IFN1cHBvcnQgaW50ZXJsYWNlLlxuICAgIGJ1ZltwKytdID0gdXNpbmdfbG9jYWxfcGFsZXR0ZSA9PT0gdHJ1ZSA/ICgweDgwIHwgKG1pbl9jb2RlX3NpemUtMSkpIDogMDtcblxuICAgIC8vIC0gTG9jYWwgQ29sb3IgVGFibGVcbiAgICBpZiAodXNpbmdfbG9jYWxfcGFsZXR0ZSA9PT0gdHJ1ZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGlsID0gcGFsZXR0ZS5sZW5ndGg7IGkgPCBpbDsgKytpKSB7XG4gICAgICAgIHZhciByZ2IgPSBwYWxldHRlW2ldO1xuICAgICAgICBidWZbcCsrXSA9IHJnYiA+PiAxNiAmIDB4ZmY7XG4gICAgICAgIGJ1ZltwKytdID0gcmdiID4+IDggJiAweGZmO1xuICAgICAgICBidWZbcCsrXSA9IHJnYiAmIDB4ZmY7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcCA9IEdpZldyaXRlck91dHB1dExaV0NvZGVTdHJlYW0oXG4gICAgICAgICAgICBidWYsIHAsIG1pbl9jb2RlX3NpemUgPCAyID8gMiA6IG1pbl9jb2RlX3NpemUsIGluZGV4ZWRfcGl4ZWxzKTtcblxuICAgIHJldHVybiBwO1xuICB9O1xuXG4gIHRoaXMuZW5kID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKGVuZGVkID09PSBmYWxzZSkge1xuICAgICAgYnVmW3ArK10gPSAweDNiOyAgLy8gVHJhaWxlci5cbiAgICAgIGVuZGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHA7XG4gIH07XG5cbiAgdGhpcy5nZXRPdXRwdXRCdWZmZXIgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGJ1ZjsgfTtcbiAgdGhpcy5zZXRPdXRwdXRCdWZmZXIgPSBmdW5jdGlvbih2KSB7IGJ1ZiA9IHY7IH07XG4gIHRoaXMuZ2V0T3V0cHV0QnVmZmVyUG9zaXRpb24gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHA7IH07XG4gIHRoaXMuc2V0T3V0cHV0QnVmZmVyUG9zaXRpb24gPSBmdW5jdGlvbih2KSB7IHAgPSB2OyB9O1xufVxuXG4vLyBNYWluIGNvbXByZXNzaW9uIHJvdXRpbmUsIHBhbGV0dGUgaW5kZXhlcyAtPiBMWlcgY29kZSBzdHJlYW0uXG4vLyB8aW5kZXhfc3RyZWFtfCBtdXN0IGhhdmUgYXQgbGVhc3Qgb25lIGVudHJ5LlxuZnVuY3Rpb24gR2lmV3JpdGVyT3V0cHV0TFpXQ29kZVN0cmVhbShidWYsIHAsIG1pbl9jb2RlX3NpemUsIGluZGV4X3N0cmVhbSkge1xuICBidWZbcCsrXSA9IG1pbl9jb2RlX3NpemU7XG4gIHZhciBjdXJfc3ViYmxvY2sgPSBwKys7ICAvLyBQb2ludGluZyBhdCB0aGUgbGVuZ3RoIGZpZWxkLlxuXG4gIHZhciBjbGVhcl9jb2RlID0gMSA8PCBtaW5fY29kZV9zaXplO1xuICB2YXIgY29kZV9tYXNrID0gY2xlYXJfY29kZSAtIDE7XG4gIHZhciBlb2lfY29kZSA9IGNsZWFyX2NvZGUgKyAxO1xuICB2YXIgbmV4dF9jb2RlID0gZW9pX2NvZGUgKyAxO1xuXG4gIHZhciBjdXJfY29kZV9zaXplID0gbWluX2NvZGVfc2l6ZSArIDE7ICAvLyBOdW1iZXIgb2YgYml0cyBwZXIgY29kZS5cbiAgdmFyIGN1cl9zaGlmdCA9IDA7XG4gIC8vIFdlIGhhdmUgYXQgbW9zdCAxMi1iaXQgY29kZXMsIHNvIHdlIHNob3VsZCBoYXZlIHRvIGhvbGQgYSBtYXggb2YgMTlcbiAgLy8gYml0cyBoZXJlIChhbmQgdGhlbiB3ZSB3b3VsZCB3cml0ZSBvdXQpLlxuICB2YXIgY3VyID0gMDtcblxuICBmdW5jdGlvbiBlbWl0X2J5dGVzX3RvX2J1ZmZlcihiaXRfYmxvY2tfc2l6ZSkge1xuICAgIHdoaWxlIChjdXJfc2hpZnQgPj0gYml0X2Jsb2NrX3NpemUpIHtcbiAgICAgIGJ1ZltwKytdID0gY3VyICYgMHhmZjtcbiAgICAgIGN1ciA+Pj0gODsgY3VyX3NoaWZ0IC09IDg7XG4gICAgICBpZiAocCA9PT0gY3VyX3N1YmJsb2NrICsgMjU2KSB7ICAvLyBGaW5pc2hlZCBhIHN1YmJsb2NrLlxuICAgICAgICBidWZbY3VyX3N1YmJsb2NrXSA9IDI1NTtcbiAgICAgICAgY3VyX3N1YmJsb2NrID0gcCsrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGVtaXRfY29kZShjKSB7XG4gICAgY3VyIHw9IGMgPDwgY3VyX3NoaWZ0O1xuICAgIGN1cl9zaGlmdCArPSBjdXJfY29kZV9zaXplO1xuICAgIGVtaXRfYnl0ZXNfdG9fYnVmZmVyKDgpO1xuICB9XG5cbiAgLy8gSSBhbSBub3QgYW4gZXhwZXJ0IG9uIHRoZSB0b3BpYywgYW5kIEkgZG9uJ3Qgd2FudCB0byB3cml0ZSBhIHRoZXNpcy5cbiAgLy8gSG93ZXZlciwgaXQgaXMgZ29vZCB0byBvdXRsaW5lIGhlcmUgdGhlIGJhc2ljIGFsZ29yaXRobSBhbmQgdGhlIGZldyBkYXRhXG4gIC8vIHN0cnVjdHVyZXMgYW5kIG9wdGltaXphdGlvbnMgaGVyZSB0aGF0IG1ha2UgdGhpcyBpbXBsZW1lbnRhdGlvbiBmYXN0LlxuICAvLyBUaGUgYmFzaWMgaWRlYSBiZWhpbmQgTFpXIGlzIHRvIGJ1aWxkIGEgdGFibGUgb2YgcHJldmlvdXNseSBzZWVuIHJ1bnNcbiAgLy8gYWRkcmVzc2VkIGJ5IGEgc2hvcnQgaWQgKGhlcmVpbiBjYWxsZWQgb3V0cHV0IGNvZGUpLiAgQWxsIGRhdGEgaXNcbiAgLy8gcmVmZXJlbmNlZCBieSBhIGNvZGUsIHdoaWNoIHJlcHJlc2VudHMgb25lIG9yIG1vcmUgdmFsdWVzIGZyb20gdGhlXG4gIC8vIG9yaWdpbmFsIGlucHV0IHN0cmVhbS4gIEFsbCBpbnB1dCBieXRlcyBjYW4gYmUgcmVmZXJlbmNlZCBhcyB0aGUgc2FtZVxuICAvLyB2YWx1ZSBhcyBhbiBvdXRwdXQgY29kZS4gIFNvIGlmIHlvdSBkaWRuJ3Qgd2FudCBhbnkgY29tcHJlc3Npb24sIHlvdVxuICAvLyBjb3VsZCBtb3JlIG9yIGxlc3MganVzdCBvdXRwdXQgdGhlIG9yaWdpbmFsIGJ5dGVzIGFzIGNvZGVzICh0aGVyZSBhcmVcbiAgLy8gc29tZSBkZXRhaWxzIHRvIHRoaXMsIGJ1dCBpdCBpcyB0aGUgaWRlYSkuICBJbiBvcmRlciB0byBhY2hpZXZlXG4gIC8vIGNvbXByZXNzaW9uLCB2YWx1ZXMgZ3JlYXRlciB0aGVuIHRoZSBpbnB1dCByYW5nZSAoY29kZXMgY2FuIGJlIHVwIHRvXG4gIC8vIDEyLWJpdCB3aGlsZSBpbnB1dCBvbmx5IDgtYml0KSByZXByZXNlbnQgYSBzZXF1ZW5jZSBvZiBwcmV2aW91c2x5IHNlZW5cbiAgLy8gaW5wdXRzLiAgVGhlIGRlY29tcHJlc3NvciBpcyBhYmxlIHRvIGJ1aWxkIHRoZSBzYW1lIG1hcHBpbmcgd2hpbGVcbiAgLy8gZGVjb2RpbmcsIHNvIHRoZXJlIGlzIGFsd2F5cyBhIHNoYXJlZCBjb21tb24ga25vd2xlZGdlIGJldHdlZW4gdGhlXG4gIC8vIGVuY29kaW5nIGFuZCBkZWNvZGVyLCB3aGljaCBpcyBhbHNvIGltcG9ydGFudCBmb3IgXCJ0aW1pbmdcIiBhc3BlY3RzIGxpa2VcbiAgLy8gaG93IHRvIGhhbmRsZSB2YXJpYWJsZSBiaXQgd2lkdGggY29kZSBlbmNvZGluZy5cbiAgLy9cbiAgLy8gT25lIG9idmlvdXMgYnV0IHZlcnkgaW1wb3J0YW50IGNvbnNlcXVlbmNlIG9mIHRoZSB0YWJsZSBzeXN0ZW0gaXMgdGhlcmVcbiAgLy8gaXMgYWx3YXlzIGEgdW5pcXVlIGlkIChhdCBtb3N0IDEyLWJpdHMpIHRvIG1hcCB0aGUgcnVucy4gICdBJyBtaWdodCBiZVxuICAvLyA0LCB0aGVuICdBQScgbWlnaHQgYmUgMTAsICdBQUEnIDExLCAnQUFBQScgMTIsIGV0Yy4gIFRoaXMgcmVsYXRpb25zaGlwXG4gIC8vIGNhbiBiZSB1c2VkIGZvciBhbiBlZmZlY2llbnQgbG9va3VwIHN0cmF0ZWd5IGZvciB0aGUgY29kZSBtYXBwaW5nLiAgV2VcbiAgLy8gbmVlZCB0byBrbm93IGlmIGEgcnVuIGhhcyBiZWVuIHNlZW4gYmVmb3JlLCBhbmQgYmUgYWJsZSB0byBtYXAgdGhhdCBydW5cbiAgLy8gdG8gdGhlIG91dHB1dCBjb2RlLiAgU2luY2Ugd2Ugc3RhcnQgd2l0aCBrbm93biB1bmlxdWUgaWRzIChpbnB1dCBieXRlcyksXG4gIC8vIGFuZCB0aGVuIGZyb20gdGhvc2UgYnVpbGQgbW9yZSB1bmlxdWUgaWRzICh0YWJsZSBlbnRyaWVzKSwgd2UgY2FuXG4gIC8vIGNvbnRpbnVlIHRoaXMgY2hhaW4gKGFsbW9zdCBsaWtlIGEgbGlua2VkIGxpc3QpIHRvIGFsd2F5cyBoYXZlIHNtYWxsXG4gIC8vIGludGVnZXIgdmFsdWVzIHRoYXQgcmVwcmVzZW50IHRoZSBjdXJyZW50IGJ5dGUgY2hhaW5zIGluIHRoZSBlbmNvZGVyLlxuICAvLyBUaGlzIG1lYW5zIGluc3RlYWQgb2YgdHJhY2tpbmcgdGhlIGlucHV0IGJ5dGVzIChBQUFBQkNEKSB0byBrbm93IG91clxuICAvLyBjdXJyZW50IHN0YXRlLCB3ZSBjYW4gdHJhY2sgdGhlIHRhYmxlIGVudHJ5IGZvciBBQUFBQkMgKGl0IGlzIGd1YXJhbnRlZWRcbiAgLy8gdG8gZXhpc3QgYnkgdGhlIG5hdHVyZSBvZiB0aGUgYWxnb3JpdGhtKSBhbmQgdGhlIG5leHQgY2hhcmFjdGVyIEQuXG4gIC8vIFRoZXJlZm9yIHRoZSB0dXBsZSBvZiAodGFibGVfZW50cnksIGJ5dGUpIGlzIGd1YXJhbnRlZWQgdG8gYWxzbyBiZVxuICAvLyB1bmlxdWUuICBUaGlzIGFsbG93cyB1cyB0byBjcmVhdGUgYSBzaW1wbGUgbG9va3VwIGtleSBmb3IgbWFwcGluZyBpbnB1dFxuICAvLyBzZXF1ZW5jZXMgdG8gY29kZXMgKHRhYmxlIGluZGljZXMpIHdpdGhvdXQgaGF2aW5nIHRvIHN0b3JlIG9yIHNlYXJjaFxuICAvLyBhbnkgb2YgdGhlIGNvZGUgc2VxdWVuY2VzLiAgU28gaWYgJ0FBQUEnIGhhcyBhIHRhYmxlIGVudHJ5IG9mIDEyLCB0aGVcbiAgLy8gdHVwbGUgb2YgKCdBQUFBJywgSykgZm9yIGFueSBpbnB1dCBieXRlIEsgd2lsbCBiZSB1bmlxdWUsIGFuZCBjYW4gYmUgb3VyXG4gIC8vIGtleS4gIFRoaXMgbGVhZHMgdG8gYSBpbnRlZ2VyIHZhbHVlIGF0IG1vc3QgMjAtYml0cywgd2hpY2ggY2FuIGFsd2F5c1xuICAvLyBmaXQgaW4gYW4gU01JIHZhbHVlIGFuZCBiZSB1c2VkIGFzIGEgZmFzdCBzcGFyc2UgYXJyYXkgLyBvYmplY3Qga2V5LlxuXG4gIC8vIE91dHB1dCBjb2RlIGZvciB0aGUgY3VycmVudCBjb250ZW50cyBvZiB0aGUgaW5kZXggYnVmZmVyLlxuICB2YXIgaWJfY29kZSA9IGluZGV4X3N0cmVhbVswXSAmIGNvZGVfbWFzazsgIC8vIExvYWQgZmlyc3QgaW5wdXQgaW5kZXguXG4gIHZhciBjb2RlX3RhYmxlID0geyB9OyAgLy8gS2V5J2Qgb24gb3VyIDIwLWJpdCBcInR1cGxlXCIuXG5cbiAgZW1pdF9jb2RlKGNsZWFyX2NvZGUpOyAgLy8gU3BlYyBzYXlzIGZpcnN0IGNvZGUgc2hvdWxkIGJlIGEgY2xlYXIgY29kZS5cblxuICAvLyBGaXJzdCBpbmRleCBhbHJlYWR5IGxvYWRlZCwgcHJvY2VzcyB0aGUgcmVzdCBvZiB0aGUgc3RyZWFtLlxuICBmb3IgKHZhciBpID0gMSwgaWwgPSBpbmRleF9zdHJlYW0ubGVuZ3RoOyBpIDwgaWw7ICsraSkge1xuICAgIHZhciBrID0gaW5kZXhfc3RyZWFtW2ldICYgY29kZV9tYXNrO1xuICAgIHZhciBjdXJfa2V5ID0gaWJfY29kZSA8PCA4IHwgazsgIC8vIChwcmV2LCBrKSB1bmlxdWUgdHVwbGUuXG4gICAgdmFyIGN1cl9jb2RlID0gY29kZV90YWJsZVtjdXJfa2V5XTsgIC8vIGJ1ZmZlciArIGsuXG5cbiAgICAvLyBDaGVjayBpZiB3ZSBoYXZlIHRvIGNyZWF0ZSBhIG5ldyBjb2RlIHRhYmxlIGVudHJ5LlxuICAgIGlmIChjdXJfY29kZSA9PT0gdW5kZWZpbmVkKSB7ICAvLyBXZSBkb24ndCBoYXZlIGJ1ZmZlciArIGsuXG4gICAgICAvLyBFbWl0IGluZGV4IGJ1ZmZlciAod2l0aG91dCBrKS5cbiAgICAgIC8vIFRoaXMgaXMgYW4gaW5saW5lIHZlcnNpb24gb2YgZW1pdF9jb2RlLCBiZWNhdXNlIHRoaXMgaXMgdGhlIGNvcmVcbiAgICAgIC8vIHdyaXRpbmcgcm91dGluZSBvZiB0aGUgY29tcHJlc3NvciAoYW5kIFY4IGNhbm5vdCBpbmxpbmUgZW1pdF9jb2RlXG4gICAgICAvLyBiZWNhdXNlIGl0IGlzIGEgY2xvc3VyZSBoZXJlIGluIGEgZGlmZmVyZW50IGNvbnRleHQpLiAgQWRkaXRpb25hbGx5XG4gICAgICAvLyB3ZSBjYW4gY2FsbCBlbWl0X2J5dGVfdG9fYnVmZmVyIGxlc3Mgb2Z0ZW4sIGJlY2F1c2Ugd2UgY2FuIGhhdmVcbiAgICAgIC8vIDMwLWJpdHMgKGZyb20gb3VyIDMxLWJpdCBzaWduZWQgU01JKSwgYW5kIHdlIGtub3cgb3VyIGNvZGVzIHdpbGwgb25seVxuICAgICAgLy8gYmUgMTItYml0cywgc28gY2FuIHNhZmVseSBoYXZlIDE4LWJpdHMgdGhlcmUgd2l0aG91dCBvdmVyZmxvdy5cbiAgICAgIC8vIGVtaXRfY29kZShpYl9jb2RlKTtcbiAgICAgIGN1ciB8PSBpYl9jb2RlIDw8IGN1cl9zaGlmdDtcbiAgICAgIGN1cl9zaGlmdCArPSBjdXJfY29kZV9zaXplO1xuICAgICAgd2hpbGUgKGN1cl9zaGlmdCA+PSA4KSB7XG4gICAgICAgIGJ1ZltwKytdID0gY3VyICYgMHhmZjtcbiAgICAgICAgY3VyID4+PSA4OyBjdXJfc2hpZnQgLT0gODtcbiAgICAgICAgaWYgKHAgPT09IGN1cl9zdWJibG9jayArIDI1NikgeyAgLy8gRmluaXNoZWQgYSBzdWJibG9jay5cbiAgICAgICAgICBidWZbY3VyX3N1YmJsb2NrXSA9IDI1NTtcbiAgICAgICAgICBjdXJfc3ViYmxvY2sgPSBwKys7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG5leHRfY29kZSA9PT0gNDA5NikgeyAgLy8gVGFibGUgZnVsbCwgbmVlZCBhIGNsZWFyLlxuICAgICAgICBlbWl0X2NvZGUoY2xlYXJfY29kZSk7XG4gICAgICAgIG5leHRfY29kZSA9IGVvaV9jb2RlICsgMTtcbiAgICAgICAgY3VyX2NvZGVfc2l6ZSA9IG1pbl9jb2RlX3NpemUgKyAxO1xuICAgICAgICBjb2RlX3RhYmxlID0geyB9O1xuICAgICAgfSBlbHNlIHsgIC8vIFRhYmxlIG5vdCBmdWxsLCBpbnNlcnQgYSBuZXcgZW50cnkuXG4gICAgICAgIC8vIEluY3JlYXNlIG91ciB2YXJpYWJsZSBiaXQgY29kZSBzaXplcyBpZiBuZWNlc3NhcnkuICBUaGlzIGlzIGEgYml0XG4gICAgICAgIC8vIHRyaWNreSBhcyBpdCBpcyBiYXNlZCBvbiBcInRpbWluZ1wiIGJldHdlZW4gdGhlIGVuY29kaW5nIGFuZFxuICAgICAgICAvLyBkZWNvZGVyLiAgRnJvbSB0aGUgZW5jb2RlcnMgcGVyc3BlY3RpdmUgdGhpcyBzaG91bGQgaGFwcGVuIGFmdGVyXG4gICAgICAgIC8vIHdlJ3ZlIGFscmVhZHkgZW1pdHRlZCB0aGUgaW5kZXggYnVmZmVyIGFuZCBhcmUgYWJvdXQgdG8gY3JlYXRlIHRoZVxuICAgICAgICAvLyBmaXJzdCB0YWJsZSBlbnRyeSB0aGF0IHdvdWxkIG92ZXJmbG93IG91ciBjdXJyZW50IGNvZGUgYml0IHNpemUuXG4gICAgICAgIGlmIChuZXh0X2NvZGUgPj0gKDEgPDwgY3VyX2NvZGVfc2l6ZSkpICsrY3VyX2NvZGVfc2l6ZTtcbiAgICAgICAgY29kZV90YWJsZVtjdXJfa2V5XSA9IG5leHRfY29kZSsrOyAgLy8gSW5zZXJ0IGludG8gY29kZSB0YWJsZS5cbiAgICAgIH1cblxuICAgICAgaWJfY29kZSA9IGs7ICAvLyBJbmRleCBidWZmZXIgdG8gc2luZ2xlIGlucHV0IGsuXG4gICAgfSBlbHNlIHtcbiAgICAgIGliX2NvZGUgPSBjdXJfY29kZTsgIC8vIEluZGV4IGJ1ZmZlciB0byBzZXF1ZW5jZSBpbiBjb2RlIHRhYmxlLlxuICAgIH1cbiAgfVxuXG4gIGVtaXRfY29kZShpYl9jb2RlKTsgIC8vIFRoZXJlIHdpbGwgc3RpbGwgYmUgc29tZXRoaW5nIGluIHRoZSBpbmRleCBidWZmZXIuXG4gIGVtaXRfY29kZShlb2lfY29kZSk7ICAvLyBFbmQgT2YgSW5mb3JtYXRpb24uXG5cbiAgLy8gRmx1c2ggLyBmaW5hbGl6ZSB0aGUgc3ViLWJsb2NrcyBzdHJlYW0gdG8gdGhlIGJ1ZmZlci5cbiAgZW1pdF9ieXRlc190b19idWZmZXIoMSk7XG5cbiAgLy8gRmluaXNoIHRoZSBzdWItYmxvY2tzLCB3cml0aW5nIG91dCBhbnkgdW5maW5pc2hlZCBsZW5ndGhzIGFuZFxuICAvLyB0ZXJtaW5hdGluZyB3aXRoIGEgc3ViLWJsb2NrIG9mIGxlbmd0aCAwLiAgSWYgd2UgaGF2ZSBhbHJlYWR5IHN0YXJ0ZWRcbiAgLy8gYnV0IG5vdCB5ZXQgdXNlZCBhIHN1Yi1ibG9jayBpdCBjYW4ganVzdCBiZWNvbWUgdGhlIHRlcm1pbmF0b3IuXG4gIGlmIChjdXJfc3ViYmxvY2sgKyAxID09PSBwKSB7ICAvLyBTdGFydGVkIGJ1dCB1bnVzZWQuXG4gICAgYnVmW2N1cl9zdWJibG9ja10gPSAwO1xuICB9IGVsc2UgeyAgLy8gU3RhcnRlZCBhbmQgdXNlZCwgd3JpdGUgbGVuZ3RoIGFuZCBhZGRpdGlvbmFsIHRlcm1pbmF0b3IgYmxvY2suXG4gICAgYnVmW2N1cl9zdWJibG9ja10gPSBwIC0gY3VyX3N1YmJsb2NrIC0gMTtcbiAgICBidWZbcCsrXSA9IDA7XG4gIH1cbiAgcmV0dXJuIHA7XG59XG5cbmZ1bmN0aW9uIEdpZlJlYWRlcihidWYpIHtcbiAgdmFyIHAgPSAwO1xuXG4gIC8vIC0gSGVhZGVyIChHSUY4N2Egb3IgR0lGODlhKS5cbiAgaWYgKGJ1ZltwKytdICE9PSAweDQ3IHx8ICAgICAgICAgICAgYnVmW3ArK10gIT09IDB4NDkgfHwgYnVmW3ArK10gIT09IDB4NDYgfHxcbiAgICAgIGJ1ZltwKytdICE9PSAweDM4IHx8IChidWZbcCsrXSsxICYgMHhmZCkgIT09IDB4MzggfHwgYnVmW3ArK10gIT09IDB4NjEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIEdJRiA4N2EvODlhIGhlYWRlci5cIik7XG4gIH1cblxuICAvLyAtIExvZ2ljYWwgU2NyZWVuIERlc2NyaXB0b3IuXG4gIHZhciB3aWR0aCA9IGJ1ZltwKytdIHwgYnVmW3ArK10gPDwgODtcbiAgdmFyIGhlaWdodCA9IGJ1ZltwKytdIHwgYnVmW3ArK10gPDwgODtcbiAgdmFyIHBmMCA9IGJ1ZltwKytdOyAgLy8gPFBhY2tlZCBGaWVsZHM+LlxuICB2YXIgZ2xvYmFsX3BhbGV0dGVfZmxhZyA9IHBmMCA+PiA3O1xuICB2YXIgbnVtX2dsb2JhbF9jb2xvcnNfcG93MiA9IHBmMCAmIDB4NztcbiAgdmFyIG51bV9nbG9iYWxfY29sb3JzID0gMSA8PCAobnVtX2dsb2JhbF9jb2xvcnNfcG93MiArIDEpO1xuICB2YXIgYmFja2dyb3VuZCA9IGJ1ZltwKytdO1xuICBidWZbcCsrXTsgIC8vIFBpeGVsIGFzcGVjdCByYXRpbyAodW51c2VkPykuXG5cbiAgdmFyIGdsb2JhbF9wYWxldHRlX29mZnNldCA9IG51bGw7XG4gIHZhciBnbG9iYWxfcGFsZXR0ZV9zaXplICAgPSBudWxsO1xuXG4gIGlmIChnbG9iYWxfcGFsZXR0ZV9mbGFnKSB7XG4gICAgZ2xvYmFsX3BhbGV0dGVfb2Zmc2V0ID0gcDtcbiAgICBnbG9iYWxfcGFsZXR0ZV9zaXplID0gbnVtX2dsb2JhbF9jb2xvcnM7XG4gICAgcCArPSBudW1fZ2xvYmFsX2NvbG9ycyAqIDM7ICAvLyBTZWVrIHBhc3QgcGFsZXR0ZS5cbiAgfVxuXG4gIHZhciBub19lb2YgPSB0cnVlO1xuXG4gIHZhciBmcmFtZXMgPSBbIF07XG5cbiAgdmFyIGRlbGF5ID0gMDtcbiAgdmFyIHRyYW5zcGFyZW50X2luZGV4ID0gbnVsbDtcbiAgdmFyIGRpc3Bvc2FsID0gMDsgIC8vIDAgLSBObyBkaXNwb3NhbCBzcGVjaWZpZWQuXG4gIHZhciBsb29wX2NvdW50ID0gbnVsbDtcblxuICB0aGlzLndpZHRoID0gd2lkdGg7XG4gIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gIHdoaWxlIChub19lb2YgJiYgcCA8IGJ1Zi5sZW5ndGgpIHtcbiAgICBzd2l0Y2ggKGJ1ZltwKytdKSB7XG4gICAgICBjYXNlIDB4MjE6ICAvLyBHcmFwaGljcyBDb250cm9sIEV4dGVuc2lvbiBCbG9ja1xuICAgICAgICBzd2l0Y2ggKGJ1ZltwKytdKSB7XG4gICAgICAgICAgY2FzZSAweGZmOiAgLy8gQXBwbGljYXRpb24gc3BlY2lmaWMgYmxvY2tcbiAgICAgICAgICAgIC8vIFRyeSBpZiBpdCdzIGEgTmV0c2NhcGUgYmxvY2sgKHdpdGggYW5pbWF0aW9uIGxvb3AgY291bnRlcikuXG4gICAgICAgICAgICBpZiAoYnVmW3AgICBdICE9PSAweDBiIHx8ICAvLyAyMSBGRiBhbHJlYWR5IHJlYWQsIGNoZWNrIGJsb2NrIHNpemUuXG4gICAgICAgICAgICAgICAgLy8gTkVUU0NBUEUyLjBcbiAgICAgICAgICAgICAgICBidWZbcCsxIF0gPT0gMHg0ZSAmJiBidWZbcCsyIF0gPT0gMHg0NSAmJiBidWZbcCszIF0gPT0gMHg1NCAmJlxuICAgICAgICAgICAgICAgIGJ1ZltwKzQgXSA9PSAweDUzICYmIGJ1ZltwKzUgXSA9PSAweDQzICYmIGJ1ZltwKzYgXSA9PSAweDQxICYmXG4gICAgICAgICAgICAgICAgYnVmW3ArNyBdID09IDB4NTAgJiYgYnVmW3ArOCBdID09IDB4NDUgJiYgYnVmW3ArOSBdID09IDB4MzIgJiZcbiAgICAgICAgICAgICAgICBidWZbcCsxMF0gPT0gMHgyZSAmJiBidWZbcCsxMV0gPT0gMHgzMCAmJlxuICAgICAgICAgICAgICAgIC8vIFN1Yi1ibG9ja1xuICAgICAgICAgICAgICAgIGJ1ZltwKzEyXSA9PSAweDAzICYmIGJ1ZltwKzEzXSA9PSAweDAxICYmIGJ1ZltwKzE2XSA9PSAwKSB7XG4gICAgICAgICAgICAgIHAgKz0gMTQ7XG4gICAgICAgICAgICAgIGxvb3BfY291bnQgPSBidWZbcCsrXSB8IGJ1ZltwKytdIDw8IDg7XG4gICAgICAgICAgICAgIHArKzsgIC8vIFNraXAgdGVybWluYXRvci5cbiAgICAgICAgICAgIH0gZWxzZSB7ICAvLyBXZSBkb24ndCBrbm93IHdoYXQgaXQgaXMsIGp1c3QgdHJ5IHRvIGdldCBwYXN0IGl0LlxuICAgICAgICAgICAgICBwICs9IDEyO1xuICAgICAgICAgICAgICB3aGlsZSAodHJ1ZSkgeyAgLy8gU2VlayB0aHJvdWdoIHN1YmJsb2Nrcy5cbiAgICAgICAgICAgICAgICB2YXIgYmxvY2tfc2l6ZSA9IGJ1ZltwKytdO1xuICAgICAgICAgICAgICAgIC8vIEJhZCBibG9jayBzaXplIChleDogdW5kZWZpbmVkIGZyb20gYW4gb3V0IG9mIGJvdW5kcyByZWFkKS5cbiAgICAgICAgICAgICAgICBpZiAoIShibG9ja19zaXplID49IDApKSB0aHJvdyBFcnJvcihcIkludmFsaWQgYmxvY2sgc2l6ZVwiKTtcbiAgICAgICAgICAgICAgICBpZiAoYmxvY2tfc2l6ZSA9PT0gMCkgYnJlYWs7ICAvLyAwIHNpemUgaXMgdGVybWluYXRvclxuICAgICAgICAgICAgICAgIHAgKz0gYmxvY2tfc2l6ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDB4Zjk6ICAvLyBHcmFwaGljcyBDb250cm9sIEV4dGVuc2lvblxuICAgICAgICAgICAgaWYgKGJ1ZltwKytdICE9PSAweDQgfHwgYnVmW3ArNF0gIT09IDApXG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZ3JhcGhpY3MgZXh0ZW5zaW9uIGJsb2NrLlwiKTtcbiAgICAgICAgICAgIHZhciBwZjEgPSBidWZbcCsrXTtcbiAgICAgICAgICAgIGRlbGF5ID0gYnVmW3ArK10gfCBidWZbcCsrXSA8PCA4O1xuICAgICAgICAgICAgdHJhbnNwYXJlbnRfaW5kZXggPSBidWZbcCsrXTtcbiAgICAgICAgICAgIGlmICgocGYxICYgMSkgPT09IDApIHRyYW5zcGFyZW50X2luZGV4ID0gbnVsbDtcbiAgICAgICAgICAgIGRpc3Bvc2FsID0gcGYxID4+IDIgJiAweDc7XG4gICAgICAgICAgICBwKys7ICAvLyBTa2lwIHRlcm1pbmF0b3IuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMHhmZTogIC8vIENvbW1lbnQgRXh0ZW5zaW9uLlxuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHsgIC8vIFNlZWsgdGhyb3VnaCBzdWJibG9ja3MuXG4gICAgICAgICAgICAgIHZhciBibG9ja19zaXplID0gYnVmW3ArK107XG4gICAgICAgICAgICAgIC8vIEJhZCBibG9jayBzaXplIChleDogdW5kZWZpbmVkIGZyb20gYW4gb3V0IG9mIGJvdW5kcyByZWFkKS5cbiAgICAgICAgICAgICAgaWYgKCEoYmxvY2tfc2l6ZSA+PSAwKSkgdGhyb3cgRXJyb3IoXCJJbnZhbGlkIGJsb2NrIHNpemVcIik7XG4gICAgICAgICAgICAgIGlmIChibG9ja19zaXplID09PSAwKSBicmVhazsgIC8vIDAgc2l6ZSBpcyB0ZXJtaW5hdG9yXG4gICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGJ1Zi5zbGljZShwLCBwK2Jsb2NrX3NpemUpLnRvU3RyaW5nKCdhc2NpaScpKTtcbiAgICAgICAgICAgICAgcCArPSBibG9ja19zaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIFwiVW5rbm93biBncmFwaGljIGNvbnRyb2wgbGFiZWw6IDB4XCIgKyBidWZbcC0xXS50b1N0cmluZygxNikpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDB4MmM6ICAvLyBJbWFnZSBEZXNjcmlwdG9yLlxuICAgICAgICB2YXIgeCA9IGJ1ZltwKytdIHwgYnVmW3ArK10gPDwgODtcbiAgICAgICAgdmFyIHkgPSBidWZbcCsrXSB8IGJ1ZltwKytdIDw8IDg7XG4gICAgICAgIHZhciB3ID0gYnVmW3ArK10gfCBidWZbcCsrXSA8PCA4O1xuICAgICAgICB2YXIgaCA9IGJ1ZltwKytdIHwgYnVmW3ArK10gPDwgODtcbiAgICAgICAgdmFyIHBmMiA9IGJ1ZltwKytdO1xuICAgICAgICB2YXIgbG9jYWxfcGFsZXR0ZV9mbGFnID0gcGYyID4+IDc7XG4gICAgICAgIHZhciBpbnRlcmxhY2VfZmxhZyA9IHBmMiA+PiA2ICYgMTtcbiAgICAgICAgdmFyIG51bV9sb2NhbF9jb2xvcnNfcG93MiA9IHBmMiAmIDB4NztcbiAgICAgICAgdmFyIG51bV9sb2NhbF9jb2xvcnMgPSAxIDw8IChudW1fbG9jYWxfY29sb3JzX3BvdzIgKyAxKTtcbiAgICAgICAgdmFyIHBhbGV0dGVfb2Zmc2V0ID0gZ2xvYmFsX3BhbGV0dGVfb2Zmc2V0O1xuICAgICAgICB2YXIgcGFsZXR0ZV9zaXplID0gZ2xvYmFsX3BhbGV0dGVfc2l6ZTtcbiAgICAgICAgdmFyIGhhc19sb2NhbF9wYWxldHRlID0gZmFsc2U7XG4gICAgICAgIGlmIChsb2NhbF9wYWxldHRlX2ZsYWcpIHtcbiAgICAgICAgICB2YXIgaGFzX2xvY2FsX3BhbGV0dGUgPSB0cnVlO1xuICAgICAgICAgIHBhbGV0dGVfb2Zmc2V0ID0gcDsgIC8vIE92ZXJyaWRlIHdpdGggbG9jYWwgcGFsZXR0ZS5cbiAgICAgICAgICBwYWxldHRlX3NpemUgPSBudW1fbG9jYWxfY29sb3JzO1xuICAgICAgICAgIHAgKz0gbnVtX2xvY2FsX2NvbG9ycyAqIDM7ICAvLyBTZWVrIHBhc3QgcGFsZXR0ZS5cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkYXRhX29mZnNldCA9IHA7XG5cbiAgICAgICAgcCsrOyAgLy8gY29kZXNpemVcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICB2YXIgYmxvY2tfc2l6ZSA9IGJ1ZltwKytdO1xuICAgICAgICAgIC8vIEJhZCBibG9jayBzaXplIChleDogdW5kZWZpbmVkIGZyb20gYW4gb3V0IG9mIGJvdW5kcyByZWFkKS5cbiAgICAgICAgICBpZiAoIShibG9ja19zaXplID49IDApKSB0aHJvdyBFcnJvcihcIkludmFsaWQgYmxvY2sgc2l6ZVwiKTtcbiAgICAgICAgICBpZiAoYmxvY2tfc2l6ZSA9PT0gMCkgYnJlYWs7ICAvLyAwIHNpemUgaXMgdGVybWluYXRvclxuICAgICAgICAgIHAgKz0gYmxvY2tfc2l6ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZyYW1lcy5wdXNoKHt4OiB4LCB5OiB5LCB3aWR0aDogdywgaGVpZ2h0OiBoLFxuICAgICAgICAgICAgICAgICAgICAgaGFzX2xvY2FsX3BhbGV0dGU6IGhhc19sb2NhbF9wYWxldHRlLFxuICAgICAgICAgICAgICAgICAgICAgcGFsZXR0ZV9vZmZzZXQ6IHBhbGV0dGVfb2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgcGFsZXR0ZV9zaXplOiBwYWxldHRlX3NpemUsXG4gICAgICAgICAgICAgICAgICAgICBkYXRhX29mZnNldDogZGF0YV9vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICBkYXRhX2xlbmd0aDogcCAtIGRhdGFfb2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgdHJhbnNwYXJlbnRfaW5kZXg6IHRyYW5zcGFyZW50X2luZGV4LFxuICAgICAgICAgICAgICAgICAgICAgaW50ZXJsYWNlZDogISFpbnRlcmxhY2VfZmxhZyxcbiAgICAgICAgICAgICAgICAgICAgIGRlbGF5OiBkZWxheSxcbiAgICAgICAgICAgICAgICAgICAgIGRpc3Bvc2FsOiBkaXNwb3NhbH0pO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAweDNiOiAgLy8gVHJhaWxlciBNYXJrZXIgKGVuZCBvZiBmaWxlKS5cbiAgICAgICAgbm9fZW9mID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGdpZiBibG9jazogMHhcIiArIGJ1ZltwLTFdLnRvU3RyaW5nKDE2KSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMubnVtRnJhbWVzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGZyYW1lcy5sZW5ndGg7XG4gIH07XG5cbiAgdGhpcy5sb29wQ291bnQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbG9vcF9jb3VudDtcbiAgfTtcblxuICB0aGlzLmZyYW1lSW5mbyA9IGZ1bmN0aW9uKGZyYW1lX251bSkge1xuICAgIGlmIChmcmFtZV9udW0gPCAwIHx8IGZyYW1lX251bSA+PSBmcmFtZXMubGVuZ3RoKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRnJhbWUgaW5kZXggb3V0IG9mIHJhbmdlLlwiKTtcbiAgICByZXR1cm4gZnJhbWVzW2ZyYW1lX251bV07XG4gIH1cblxuICB0aGlzLmRlY29kZUFuZEJsaXRGcmFtZUJHUkEgPSBmdW5jdGlvbihmcmFtZV9udW0sIHBpeGVscykge1xuICAgIHZhciBmcmFtZSA9IHRoaXMuZnJhbWVJbmZvKGZyYW1lX251bSk7XG4gICAgdmFyIG51bV9waXhlbHMgPSBmcmFtZS53aWR0aCAqIGZyYW1lLmhlaWdodDtcbiAgICB2YXIgaW5kZXhfc3RyZWFtID0gbmV3IFVpbnQ4QXJyYXkobnVtX3BpeGVscyk7ICAvLyBBdCBtb3N0IDgtYml0IGluZGljZXMuXG4gICAgR2lmUmVhZGVyTFpXT3V0cHV0SW5kZXhTdHJlYW0oXG4gICAgICAgIGJ1ZiwgZnJhbWUuZGF0YV9vZmZzZXQsIGluZGV4X3N0cmVhbSwgbnVtX3BpeGVscyk7XG4gICAgdmFyIHBhbGV0dGVfb2Zmc2V0ID0gZnJhbWUucGFsZXR0ZV9vZmZzZXQ7XG5cbiAgICAvLyBOT1RFKGRlYW5tKTogSXQgc2VlbXMgdG8gYmUgbXVjaCBmYXN0ZXIgdG8gY29tcGFyZSBpbmRleCB0byAyNTYgdGhhblxuICAgIC8vIHRvID09PSBudWxsLiAgTm90IHN1cmUgd2h5LCBidXQgQ29tcGFyZVN0dWJfRVFfU1RSSUNUIHNob3dzIHVwIGhpZ2ggaW5cbiAgICAvLyB0aGUgcHJvZmlsZSwgbm90IHN1cmUgaWYgaXQncyByZWxhdGVkIHRvIHVzaW5nIGEgVWludDhBcnJheS5cbiAgICB2YXIgdHJhbnMgPSBmcmFtZS50cmFuc3BhcmVudF9pbmRleDtcbiAgICBpZiAodHJhbnMgPT09IG51bGwpIHRyYW5zID0gMjU2O1xuXG4gICAgLy8gV2UgYXJlIHBvc3NpYmx5IGp1c3QgYmxpdHRpbmcgdG8gYSBwb3J0aW9uIG9mIHRoZSBlbnRpcmUgZnJhbWUuXG4gICAgLy8gVGhhdCBpcyBhIHN1YnJlY3Qgd2l0aGluIHRoZSBmcmFtZXJlY3QsIHNvIHRoZSBhZGRpdGlvbmFsIHBpeGVsc1xuICAgIC8vIG11c3QgYmUgc2tpcHBlZCBvdmVyIGFmdGVyIHdlIGZpbmlzaGVkIGEgc2NhbmxpbmUuXG4gICAgdmFyIGZyYW1ld2lkdGggID0gZnJhbWUud2lkdGg7XG4gICAgdmFyIGZyYW1lc3RyaWRlID0gd2lkdGggLSBmcmFtZXdpZHRoO1xuICAgIHZhciB4bGVmdCAgICAgICA9IGZyYW1ld2lkdGg7ICAvLyBOdW1iZXIgb2Ygc3VicmVjdCBwaXhlbHMgbGVmdCBpbiBzY2FubGluZS5cblxuICAgIC8vIE91dHB1dCBpbmRpY2llcyBvZiB0aGUgdG9wIGxlZnQgYW5kIGJvdHRvbSByaWdodCBjb3JuZXJzIG9mIHRoZSBzdWJyZWN0LlxuICAgIHZhciBvcGJlZyA9ICgoZnJhbWUueSAqIHdpZHRoKSArIGZyYW1lLngpICogNDtcbiAgICB2YXIgb3BlbmQgPSAoKGZyYW1lLnkgKyBmcmFtZS5oZWlnaHQpICogd2lkdGggKyBmcmFtZS54KSAqIDQ7XG4gICAgdmFyIG9wICAgID0gb3BiZWc7XG5cbiAgICB2YXIgc2NhbnN0cmlkZSA9IGZyYW1lc3RyaWRlICogNDtcblxuICAgIC8vIFVzZSBzY2Fuc3RyaWRlIHRvIHNraXAgcGFzdCB0aGUgcm93cyB3aGVuIGludGVybGFjaW5nLiAgVGhpcyBpcyBza2lwcGluZ1xuICAgIC8vIDcgcm93cyBmb3IgdGhlIGZpcnN0IHR3byBwYXNzZXMsIHRoZW4gMyB0aGVuIDEuXG4gICAgaWYgKGZyYW1lLmludGVybGFjZWQgPT09IHRydWUpIHtcbiAgICAgIHNjYW5zdHJpZGUgKz0gd2lkdGggKiA0ICogNzsgIC8vIFBhc3MgMS5cbiAgICB9XG5cbiAgICB2YXIgaW50ZXJsYWNlc2tpcCA9IDg7ICAvLyBUcmFja2luZyB0aGUgcm93IGludGVydmFsIGluIHRoZSBjdXJyZW50IHBhc3MuXG5cbiAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBpbmRleF9zdHJlYW0ubGVuZ3RoOyBpIDwgaWw7ICsraSkge1xuICAgICAgdmFyIGluZGV4ID0gaW5kZXhfc3RyZWFtW2ldO1xuXG4gICAgICBpZiAoeGxlZnQgPT09IDApIHsgIC8vIEJlZ2lubmluZyBvZiBuZXcgc2NhbiBsaW5lXG4gICAgICAgIG9wICs9IHNjYW5zdHJpZGU7XG4gICAgICAgIHhsZWZ0ID0gZnJhbWV3aWR0aDtcbiAgICAgICAgaWYgKG9wID49IG9wZW5kKSB7IC8vIENhdGNoIHRoZSB3cmFwIHRvIHN3aXRjaCBwYXNzZXMgd2hlbiBpbnRlcmxhY2luZy5cbiAgICAgICAgICBzY2Fuc3RyaWRlID0gZnJhbWVzdHJpZGUgKiA0ICsgd2lkdGggKiA0ICogKGludGVybGFjZXNraXAtMSk7XG4gICAgICAgICAgLy8gaW50ZXJsYWNlc2tpcCAvIDIgKiA0IGlzIGludGVybGFjZXNraXAgPDwgMS5cbiAgICAgICAgICBvcCA9IG9wYmVnICsgKGZyYW1ld2lkdGggKyBmcmFtZXN0cmlkZSkgKiAoaW50ZXJsYWNlc2tpcCA8PCAxKTtcbiAgICAgICAgICBpbnRlcmxhY2Vza2lwID4+PSAxO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpbmRleCA9PT0gdHJhbnMpIHtcbiAgICAgICAgb3AgKz0gNDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByID0gYnVmW3BhbGV0dGVfb2Zmc2V0ICsgaW5kZXggKiAzXTtcbiAgICAgICAgdmFyIGcgPSBidWZbcGFsZXR0ZV9vZmZzZXQgKyBpbmRleCAqIDMgKyAxXTtcbiAgICAgICAgdmFyIGIgPSBidWZbcGFsZXR0ZV9vZmZzZXQgKyBpbmRleCAqIDMgKyAyXTtcbiAgICAgICAgcGl4ZWxzW29wKytdID0gYjtcbiAgICAgICAgcGl4ZWxzW29wKytdID0gZztcbiAgICAgICAgcGl4ZWxzW29wKytdID0gcjtcbiAgICAgICAgcGl4ZWxzW29wKytdID0gMjU1O1xuICAgICAgfVxuICAgICAgLS14bGVmdDtcbiAgICB9XG4gIH07XG5cbiAgLy8gSSB3aWxsIGdvIHRvIGNvcHkgYW5kIHBhc3RlIGhlbGwgb25lIGRheS4uLlxuICB0aGlzLmRlY29kZUFuZEJsaXRGcmFtZVJHQkEgPSBmdW5jdGlvbihmcmFtZV9udW0sIHBpeGVscykge1xuICAgIHZhciBmcmFtZSA9IHRoaXMuZnJhbWVJbmZvKGZyYW1lX251bSk7XG4gICAgdmFyIG51bV9waXhlbHMgPSBmcmFtZS53aWR0aCAqIGZyYW1lLmhlaWdodDtcbiAgICB2YXIgaW5kZXhfc3RyZWFtID0gbmV3IFVpbnQ4QXJyYXkobnVtX3BpeGVscyk7ICAvLyBBdCBtb3N0IDgtYml0IGluZGljZXMuXG4gICAgR2lmUmVhZGVyTFpXT3V0cHV0SW5kZXhTdHJlYW0oXG4gICAgICAgIGJ1ZiwgZnJhbWUuZGF0YV9vZmZzZXQsIGluZGV4X3N0cmVhbSwgbnVtX3BpeGVscyk7XG4gICAgdmFyIHBhbGV0dGVfb2Zmc2V0ID0gZnJhbWUucGFsZXR0ZV9vZmZzZXQ7XG5cbiAgICAvLyBOT1RFKGRlYW5tKTogSXQgc2VlbXMgdG8gYmUgbXVjaCBmYXN0ZXIgdG8gY29tcGFyZSBpbmRleCB0byAyNTYgdGhhblxuICAgIC8vIHRvID09PSBudWxsLiAgTm90IHN1cmUgd2h5LCBidXQgQ29tcGFyZVN0dWJfRVFfU1RSSUNUIHNob3dzIHVwIGhpZ2ggaW5cbiAgICAvLyB0aGUgcHJvZmlsZSwgbm90IHN1cmUgaWYgaXQncyByZWxhdGVkIHRvIHVzaW5nIGEgVWludDhBcnJheS5cbiAgICB2YXIgdHJhbnMgPSBmcmFtZS50cmFuc3BhcmVudF9pbmRleDtcbiAgICBpZiAodHJhbnMgPT09IG51bGwpIHRyYW5zID0gMjU2O1xuXG4gICAgLy8gV2UgYXJlIHBvc3NpYmx5IGp1c3QgYmxpdHRpbmcgdG8gYSBwb3J0aW9uIG9mIHRoZSBlbnRpcmUgZnJhbWUuXG4gICAgLy8gVGhhdCBpcyBhIHN1YnJlY3Qgd2l0aGluIHRoZSBmcmFtZXJlY3QsIHNvIHRoZSBhZGRpdGlvbmFsIHBpeGVsc1xuICAgIC8vIG11c3QgYmUgc2tpcHBlZCBvdmVyIGFmdGVyIHdlIGZpbmlzaGVkIGEgc2NhbmxpbmUuXG4gICAgdmFyIGZyYW1ld2lkdGggID0gZnJhbWUud2lkdGg7XG4gICAgdmFyIGZyYW1lc3RyaWRlID0gd2lkdGggLSBmcmFtZXdpZHRoO1xuICAgIHZhciB4bGVmdCAgICAgICA9IGZyYW1ld2lkdGg7ICAvLyBOdW1iZXIgb2Ygc3VicmVjdCBwaXhlbHMgbGVmdCBpbiBzY2FubGluZS5cblxuICAgIC8vIE91dHB1dCBpbmRpY2llcyBvZiB0aGUgdG9wIGxlZnQgYW5kIGJvdHRvbSByaWdodCBjb3JuZXJzIG9mIHRoZSBzdWJyZWN0LlxuICAgIHZhciBvcGJlZyA9ICgoZnJhbWUueSAqIHdpZHRoKSArIGZyYW1lLngpICogNDtcbiAgICB2YXIgb3BlbmQgPSAoKGZyYW1lLnkgKyBmcmFtZS5oZWlnaHQpICogd2lkdGggKyBmcmFtZS54KSAqIDQ7XG4gICAgdmFyIG9wICAgID0gb3BiZWc7XG5cbiAgICB2YXIgc2NhbnN0cmlkZSA9IGZyYW1lc3RyaWRlICogNDtcblxuICAgIC8vIFVzZSBzY2Fuc3RyaWRlIHRvIHNraXAgcGFzdCB0aGUgcm93cyB3aGVuIGludGVybGFjaW5nLiAgVGhpcyBpcyBza2lwcGluZ1xuICAgIC8vIDcgcm93cyBmb3IgdGhlIGZpcnN0IHR3byBwYXNzZXMsIHRoZW4gMyB0aGVuIDEuXG4gICAgaWYgKGZyYW1lLmludGVybGFjZWQgPT09IHRydWUpIHtcbiAgICAgIHNjYW5zdHJpZGUgKz0gd2lkdGggKiA0ICogNzsgIC8vIFBhc3MgMS5cbiAgICB9XG5cbiAgICB2YXIgaW50ZXJsYWNlc2tpcCA9IDg7ICAvLyBUcmFja2luZyB0aGUgcm93IGludGVydmFsIGluIHRoZSBjdXJyZW50IHBhc3MuXG5cbiAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBpbmRleF9zdHJlYW0ubGVuZ3RoOyBpIDwgaWw7ICsraSkge1xuICAgICAgdmFyIGluZGV4ID0gaW5kZXhfc3RyZWFtW2ldO1xuXG4gICAgICBpZiAoeGxlZnQgPT09IDApIHsgIC8vIEJlZ2lubmluZyBvZiBuZXcgc2NhbiBsaW5lXG4gICAgICAgIG9wICs9IHNjYW5zdHJpZGU7XG4gICAgICAgIHhsZWZ0ID0gZnJhbWV3aWR0aDtcbiAgICAgICAgaWYgKG9wID49IG9wZW5kKSB7IC8vIENhdGNoIHRoZSB3cmFwIHRvIHN3aXRjaCBwYXNzZXMgd2hlbiBpbnRlcmxhY2luZy5cbiAgICAgICAgICBzY2Fuc3RyaWRlID0gZnJhbWVzdHJpZGUgKiA0ICsgd2lkdGggKiA0ICogKGludGVybGFjZXNraXAtMSk7XG4gICAgICAgICAgLy8gaW50ZXJsYWNlc2tpcCAvIDIgKiA0IGlzIGludGVybGFjZXNraXAgPDwgMS5cbiAgICAgICAgICBvcCA9IG9wYmVnICsgKGZyYW1ld2lkdGggKyBmcmFtZXN0cmlkZSkgKiAoaW50ZXJsYWNlc2tpcCA8PCAxKTtcbiAgICAgICAgICBpbnRlcmxhY2Vza2lwID4+PSAxO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpbmRleCA9PT0gdHJhbnMpIHtcbiAgICAgICAgb3AgKz0gNDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByID0gYnVmW3BhbGV0dGVfb2Zmc2V0ICsgaW5kZXggKiAzXTtcbiAgICAgICAgdmFyIGcgPSBidWZbcGFsZXR0ZV9vZmZzZXQgKyBpbmRleCAqIDMgKyAxXTtcbiAgICAgICAgdmFyIGIgPSBidWZbcGFsZXR0ZV9vZmZzZXQgKyBpbmRleCAqIDMgKyAyXTtcbiAgICAgICAgcGl4ZWxzW29wKytdID0gcjtcbiAgICAgICAgcGl4ZWxzW29wKytdID0gZztcbiAgICAgICAgcGl4ZWxzW29wKytdID0gYjtcbiAgICAgICAgcGl4ZWxzW29wKytdID0gMjU1O1xuICAgICAgfVxuICAgICAgLS14bGVmdDtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIEdpZlJlYWRlckxaV091dHB1dEluZGV4U3RyZWFtKGNvZGVfc3RyZWFtLCBwLCBvdXRwdXQsIG91dHB1dF9sZW5ndGgpIHtcbiAgdmFyIG1pbl9jb2RlX3NpemUgPSBjb2RlX3N0cmVhbVtwKytdO1xuXG4gIHZhciBjbGVhcl9jb2RlID0gMSA8PCBtaW5fY29kZV9zaXplO1xuICB2YXIgZW9pX2NvZGUgPSBjbGVhcl9jb2RlICsgMTtcbiAgdmFyIG5leHRfY29kZSA9IGVvaV9jb2RlICsgMTtcblxuICB2YXIgY3VyX2NvZGVfc2l6ZSA9IG1pbl9jb2RlX3NpemUgKyAxOyAgLy8gTnVtYmVyIG9mIGJpdHMgcGVyIGNvZGUuXG4gIC8vIE5PVEU6IFRoaXMgc2hhcmVzIHRoZSBzYW1lIG5hbWUgYXMgdGhlIGVuY29kZXIsIGJ1dCBoYXMgYSBkaWZmZXJlbnRcbiAgLy8gbWVhbmluZyBoZXJlLiAgSGVyZSB0aGlzIG1hc2tzIGVhY2ggY29kZSBjb21pbmcgZnJvbSB0aGUgY29kZSBzdHJlYW0uXG4gIHZhciBjb2RlX21hc2sgPSAoMSA8PCBjdXJfY29kZV9zaXplKSAtIDE7XG4gIHZhciBjdXJfc2hpZnQgPSAwO1xuICB2YXIgY3VyID0gMDtcblxuICB2YXIgb3AgPSAwOyAgLy8gT3V0cHV0IHBvaW50ZXIuXG5cbiAgdmFyIHN1YmJsb2NrX3NpemUgPSBjb2RlX3N0cmVhbVtwKytdO1xuXG4gIC8vIFRPRE8oZGVhbm0pOiBXb3VsZCB1c2luZyBhIFR5cGVkQXJyYXkgYmUgYW55IGZhc3Rlcj8gIEF0IGxlYXN0IGl0IHdvdWxkXG4gIC8vIHNvbHZlIHRoZSBmYXN0IG1vZGUgLyBiYWNraW5nIHN0b3JlIHVuY2VydGFpbnR5LlxuICAvLyB2YXIgY29kZV90YWJsZSA9IEFycmF5KDQwOTYpO1xuICB2YXIgY29kZV90YWJsZSA9IG5ldyBJbnQzMkFycmF5KDQwOTYpOyAgLy8gQ2FuIGJlIHNpZ25lZCwgd2Ugb25seSB1c2UgMjAgYml0cy5cblxuICB2YXIgcHJldl9jb2RlID0gbnVsbDsgIC8vIFRyYWNrIGNvZGUtMS5cblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIC8vIFJlYWQgdXAgdG8gdHdvIGJ5dGVzLCBtYWtpbmcgc3VyZSB3ZSBhbHdheXMgMTItYml0cyBmb3IgbWF4IHNpemVkIGNvZGUuXG4gICAgd2hpbGUgKGN1cl9zaGlmdCA8IDE2KSB7XG4gICAgICBpZiAoc3ViYmxvY2tfc2l6ZSA9PT0gMCkgYnJlYWs7ICAvLyBObyBtb3JlIGRhdGEgdG8gYmUgcmVhZC5cblxuICAgICAgY3VyIHw9IGNvZGVfc3RyZWFtW3ArK10gPDwgY3VyX3NoaWZ0O1xuICAgICAgY3VyX3NoaWZ0ICs9IDg7XG5cbiAgICAgIGlmIChzdWJibG9ja19zaXplID09PSAxKSB7ICAvLyBOZXZlciBsZXQgaXQgZ2V0IHRvIDAgdG8gaG9sZCBsb2dpYyBhYm92ZS5cbiAgICAgICAgc3ViYmxvY2tfc2l6ZSA9IGNvZGVfc3RyZWFtW3ArK107ICAvLyBOZXh0IHN1YmJsb2NrLlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLS1zdWJibG9ja19zaXplO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRPRE8oZGVhbm0pOiBXZSBzaG91bGQgbmV2ZXIgcmVhbGx5IGdldCBoZXJlLCB3ZSBzaG91bGQgaGF2ZSByZWNlaXZlZFxuICAgIC8vIGFuZCBFT0kuXG4gICAgaWYgKGN1cl9zaGlmdCA8IGN1cl9jb2RlX3NpemUpXG4gICAgICBicmVhaztcblxuICAgIHZhciBjb2RlID0gY3VyICYgY29kZV9tYXNrO1xuICAgIGN1ciA+Pj0gY3VyX2NvZGVfc2l6ZTtcbiAgICBjdXJfc2hpZnQgLT0gY3VyX2NvZGVfc2l6ZTtcblxuICAgIC8vIFRPRE8oZGVhbm0pOiBNYXliZSBzaG91bGQgY2hlY2sgdGhhdCB0aGUgZmlyc3QgY29kZSB3YXMgYSBjbGVhciBjb2RlLFxuICAgIC8vIGF0IGxlYXN0IHRoaXMgaXMgd2hhdCB5b3UncmUgc3VwcG9zZWQgdG8gZG8uICBCdXQgYWN0dWFsbHkgb3VyIGVuY29kZXJcbiAgICAvLyBub3cgZG9lc24ndCBlbWl0IGEgY2xlYXIgY29kZSBmaXJzdCBhbnl3YXkuXG4gICAgaWYgKGNvZGUgPT09IGNsZWFyX2NvZGUpIHtcbiAgICAgIC8vIFdlIGRvbid0IGFjdHVhbGx5IGhhdmUgdG8gY2xlYXIgdGhlIHRhYmxlLiAgVGhpcyBjb3VsZCBiZSBhIGdvb2QgaWRlYVxuICAgICAgLy8gZm9yIGdyZWF0ZXIgZXJyb3IgY2hlY2tpbmcsIGJ1dCB3ZSBkb24ndCByZWFsbHkgZG8gYW55IGFueXdheS4gIFdlXG4gICAgICAvLyB3aWxsIGp1c3QgdHJhY2sgaXQgd2l0aCBuZXh0X2NvZGUgYW5kIG92ZXJ3cml0ZSBvbGQgZW50cmllcy5cblxuICAgICAgbmV4dF9jb2RlID0gZW9pX2NvZGUgKyAxO1xuICAgICAgY3VyX2NvZGVfc2l6ZSA9IG1pbl9jb2RlX3NpemUgKyAxO1xuICAgICAgY29kZV9tYXNrID0gKDEgPDwgY3VyX2NvZGVfc2l6ZSkgLSAxO1xuXG4gICAgICAvLyBEb24ndCB1cGRhdGUgcHJldl9jb2RlID9cbiAgICAgIHByZXZfY29kZSA9IG51bGw7XG4gICAgICBjb250aW51ZTtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IGVvaV9jb2RlKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyBXZSBoYXZlIGEgc2ltaWxhciBzaXR1YXRpb24gYXMgdGhlIGRlY29kZXIsIHdoZXJlIHdlIHdhbnQgdG8gc3RvcmVcbiAgICAvLyB2YXJpYWJsZSBsZW5ndGggZW50cmllcyAoY29kZSB0YWJsZSBlbnRyaWVzKSwgYnV0IHdlIHdhbnQgdG8gZG8gaW4gYVxuICAgIC8vIGZhc3RlciBtYW5uZXIgdGhhbiBhbiBhcnJheSBvZiBhcnJheXMuICBUaGUgY29kZSBiZWxvdyBzdG9yZXMgc29ydCBvZiBhXG4gICAgLy8gbGlua2VkIGxpc3Qgd2l0aGluIHRoZSBjb2RlIHRhYmxlLCBhbmQgdGhlbiBcImNoYXNlc1wiIHRocm91Z2ggaXQgdG9cbiAgICAvLyBjb25zdHJ1Y3QgdGhlIGRpY3Rpb25hcnkgZW50cmllcy4gIFdoZW4gYSBuZXcgZW50cnkgaXMgY3JlYXRlZCwganVzdCB0aGVcbiAgICAvLyBsYXN0IGJ5dGUgaXMgc3RvcmVkLCBhbmQgdGhlIHJlc3QgKHByZWZpeCkgb2YgdGhlIGVudHJ5IGlzIG9ubHlcbiAgICAvLyByZWZlcmVuY2VkIGJ5IGl0cyB0YWJsZSBlbnRyeS4gIFRoZW4gdGhlIGNvZGUgY2hhc2VzIHRocm91Z2ggdGhlXG4gICAgLy8gcHJlZml4ZXMgdW50aWwgaXQgcmVhY2hlcyBhIHNpbmdsZSBieXRlIGNvZGUuICBXZSBoYXZlIHRvIGNoYXNlIHR3aWNlLFxuICAgIC8vIGZpcnN0IHRvIGNvbXB1dGUgdGhlIGxlbmd0aCwgYW5kIHRoZW4gdG8gYWN0dWFsbHkgY29weSB0aGUgZGF0YSB0byB0aGVcbiAgICAvLyBvdXRwdXQgKGJhY2t3YXJkcywgc2luY2Ugd2Uga25vdyB0aGUgbGVuZ3RoKS4gIFRoZSBhbHRlcm5hdGl2ZSB3b3VsZCBiZVxuICAgIC8vIHN0b3Jpbmcgc29tZXRoaW5nIGluIGFuIGludGVybWVkaWF0ZSBzdGFjaywgYnV0IHRoYXQgZG9lc24ndCBtYWtlIGFueVxuICAgIC8vIG1vcmUgc2Vuc2UuICBJIGltcGxlbWVudGVkIGFuIGFwcHJvYWNoIHdoZXJlIGl0IGFsc28gc3RvcmVkIHRoZSBsZW5ndGhcbiAgICAvLyBpbiB0aGUgY29kZSB0YWJsZSwgYWx0aG91Z2ggaXQncyBhIGJpdCB0cmlja3kgYmVjYXVzZSB5b3UgcnVuIG91dCBvZlxuICAgIC8vIGJpdHMgKDEyICsgMTIgKyA4KSwgYnV0IEkgZGlkbid0IG1lYXN1cmUgbXVjaCBpbXByb3ZlbWVudHMgKHRoZSB0YWJsZVxuICAgIC8vIGVudHJpZXMgYXJlIGdlbmVyYWxseSBub3QgdGhlIGxvbmcpLiAgRXZlbiB3aGVuIEkgY3JlYXRlZCBiZW5jaG1hcmtzIGZvclxuICAgIC8vIHZlcnkgbG9uZyB0YWJsZSBlbnRyaWVzIHRoZSBjb21wbGV4aXR5IGRpZCBub3Qgc2VlbSB3b3J0aCBpdC5cbiAgICAvLyBUaGUgY29kZSB0YWJsZSBzdG9yZXMgdGhlIHByZWZpeCBlbnRyeSBpbiAxMiBiaXRzIGFuZCB0aGVuIHRoZSBzdWZmaXhcbiAgICAvLyBieXRlIGluIDggYml0cywgc28gZWFjaCBlbnRyeSBpcyAyMCBiaXRzLlxuXG4gICAgdmFyIGNoYXNlX2NvZGUgPSBjb2RlIDwgbmV4dF9jb2RlID8gY29kZSA6IHByZXZfY29kZTtcblxuICAgIC8vIENoYXNlIHdoYXQgd2Ugd2lsbCBvdXRwdXQsIGVpdGhlciB7Q09ERX0gb3Ige0NPREUtMX0uXG4gICAgdmFyIGNoYXNlX2xlbmd0aCA9IDA7XG4gICAgdmFyIGNoYXNlID0gY2hhc2VfY29kZTtcbiAgICB3aGlsZSAoY2hhc2UgPiBjbGVhcl9jb2RlKSB7XG4gICAgICBjaGFzZSA9IGNvZGVfdGFibGVbY2hhc2VdID4+IDg7XG4gICAgICArK2NoYXNlX2xlbmd0aDtcbiAgICB9XG5cbiAgICB2YXIgayA9IGNoYXNlO1xuXG4gICAgdmFyIG9wX2VuZCA9IG9wICsgY2hhc2VfbGVuZ3RoICsgKGNoYXNlX2NvZGUgIT09IGNvZGUgPyAxIDogMCk7XG4gICAgaWYgKG9wX2VuZCA+IG91dHB1dF9sZW5ndGgpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiV2FybmluZywgZ2lmIHN0cmVhbSBsb25nZXIgdGhhbiBleHBlY3RlZC5cIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQWxyZWFkeSBoYXZlIHRoZSBmaXJzdCBieXRlIGZyb20gdGhlIGNoYXNlLCBtaWdodCBhcyB3ZWxsIHdyaXRlIGl0IGZhc3QuXG4gICAgb3V0cHV0W29wKytdID0gaztcblxuICAgIG9wICs9IGNoYXNlX2xlbmd0aDtcbiAgICB2YXIgYiA9IG9wOyAgLy8gVHJhY2sgcG9pbnRlciwgd3JpdGluZyBiYWNrd2FyZHMuXG5cbiAgICBpZiAoY2hhc2VfY29kZSAhPT0gY29kZSkgIC8vIFRoZSBjYXNlIG9mIGVtaXR0aW5nIHtDT0RFLTF9ICsgay5cbiAgICAgIG91dHB1dFtvcCsrXSA9IGs7XG5cbiAgICBjaGFzZSA9IGNoYXNlX2NvZGU7XG4gICAgd2hpbGUgKGNoYXNlX2xlbmd0aC0tKSB7XG4gICAgICBjaGFzZSA9IGNvZGVfdGFibGVbY2hhc2VdO1xuICAgICAgb3V0cHV0Wy0tYl0gPSBjaGFzZSAmIDB4ZmY7ICAvLyBXcml0ZSBiYWNrd2FyZHMuXG4gICAgICBjaGFzZSA+Pj0gODsgIC8vIFB1bGwgZG93biB0byB0aGUgcHJlZml4IGNvZGUuXG4gICAgfVxuXG4gICAgaWYgKHByZXZfY29kZSAhPT0gbnVsbCAmJiBuZXh0X2NvZGUgPCA0MDk2KSB7XG4gICAgICBjb2RlX3RhYmxlW25leHRfY29kZSsrXSA9IHByZXZfY29kZSA8PCA4IHwgaztcbiAgICAgIC8vIFRPRE8oZGVhbm0pOiBGaWd1cmUgb3V0IHRoaXMgY2xlYXJpbmcgdnMgY29kZSBncm93dGggbG9naWMgYmV0dGVyLiAgSVxuICAgICAgLy8gaGF2ZSBhbiBmZWVsaW5nIHRoYXQgaXQgc2hvdWxkIGp1c3QgaGFwcGVuIHNvbWV3aGVyZSBlbHNlLCBmb3Igbm93IGl0XG4gICAgICAvLyBpcyBhd2t3YXJkIGJldHdlZW4gd2hlbiB3ZSBncm93IHBhc3QgdGhlIG1heCBhbmQgdGhlbiBoaXQgYSBjbGVhciBjb2RlLlxuICAgICAgLy8gRm9yIG5vdyBqdXN0IGNoZWNrIGlmIHdlIGhpdCB0aGUgbWF4IDEyLWJpdHMgKHRoZW4gYSBjbGVhciBjb2RlIHNob3VsZFxuICAgICAgLy8gZm9sbG93LCBhbHNvIG9mIGNvdXJzZSBlbmNvZGVkIGluIDEyLWJpdHMpLlxuICAgICAgaWYgKG5leHRfY29kZSA+PSBjb2RlX21hc2srMSAmJiBjdXJfY29kZV9zaXplIDwgMTIpIHtcbiAgICAgICAgKytjdXJfY29kZV9zaXplO1xuICAgICAgICBjb2RlX21hc2sgPSBjb2RlX21hc2sgPDwgMSB8IDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcHJldl9jb2RlID0gY29kZTtcbiAgfVxuXG4gIGlmIChvcCAhPT0gb3V0cHV0X2xlbmd0aCkge1xuICAgIGNvbnNvbGUubG9nKFwiV2FybmluZywgZ2lmIHN0cmVhbSBzaG9ydGVyIHRoYW4gZXhwZWN0ZWQuXCIpO1xuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuLy8gQ29tbW9uSlMuXG50cnkgeyBleHBvcnRzLkdpZldyaXRlciA9IEdpZldyaXRlcjsgZXhwb3J0cy5HaWZSZWFkZXIgPSBHaWZSZWFkZXIgfSBjYXRjaChlKSB7fVxuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///0\n')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, "canvastoDataURL", function() { return /* reexport */ canvastoDataURL; });\n__webpack_require__.d(__webpack_exports__, "canvastoFile", function() { return /* reexport */ canvastoFile; });\n__webpack_require__.d(__webpack_exports__, "dataURLtoFile", function() { return /* reexport */ dataURLtoFile; });\n__webpack_require__.d(__webpack_exports__, "dataURLtoImage", function() { return /* reexport */ dataURLtoImage; });\n__webpack_require__.d(__webpack_exports__, "downloadFile", function() { return /* reexport */ downloadFile; });\n__webpack_require__.d(__webpack_exports__, "filetoDataURL", function() { return /* reexport */ filetoDataURL; });\n__webpack_require__.d(__webpack_exports__, "imagetoCanvas", function() { return /* reexport */ imagetoCanvas; });\n__webpack_require__.d(__webpack_exports__, "urltoBlob", function() { return /* reexport */ urltoBlob; });\n__webpack_require__.d(__webpack_exports__, "urltoImage", function() { return /* reexport */ urltoImage; });\n__webpack_require__.d(__webpack_exports__, "compress", function() { return /* binding */ compress; });\n__webpack_require__.d(__webpack_exports__, "compressAccurately", function() { return /* binding */ compressAccurately; });\n__webpack_require__.d(__webpack_exports__, "EImageType", function() { return /* reexport */ EImageType; });\n\n// CONCATENATED MODULE: ./src/models/index.ts\nvar EImageType;\r\n(function (EImageType) {\r\n    EImageType["PNG"] = "image/png";\r\n    EImageType["JPEG"] = "image/jpeg";\r\n    EImageType["GIF"] = "image/gif";\r\n})(EImageType || (EImageType = {}));\r\n\n// CONCATENATED MODULE: ./src/utils/checkImageType.ts\nfunction checkImageType(type) {\r\n    return [\'image/png\', \'image/jpeg\', \'image/gif\'].some(i => i === type);\r\n}\r\n\n// CONCATENATED MODULE: ./src/utils/index.ts\n\r\n\r\n\n// CONCATENATED MODULE: ./src/canvastoDataURL.ts\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n/**\r\n * 将一个Canvas对象转变为一个dataURL字符串\r\n * 该方法可以做压缩处理\r\n *\r\n * @param {canvas} canvas\r\n * @param {number=} quality - 传入范围 0-1，表示图片压缩质量，默认0.92\r\n * @param {string=} type - 确定转换后的图片类型，选项有 "image/png", "image/jpeg", "image/gif",默认"image/jpeg"\r\n * @returns {Promise(string)} Promise含有一个dataURL字符串参数\r\n */\r\nfunction canvastoDataURL(canvas, quality = 0.92, type = EImageType.JPEG) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        if (!checkImageType(type)) {\r\n            type = EImageType.JPEG;\r\n        }\r\n        return canvas.toDataURL(type, quality);\r\n    });\r\n}\r\n;\r\n\n// CONCATENATED MODULE: ./src/canvastoFile.ts\n\r\n/**\r\n * 将一个canvas对象转变为一个File（Blob）对象\r\n * 该方法可以做压缩处理\r\n *\r\n * @param {canvas} canvas\r\n * @param {number=} quality - 传入范围 0-1，表示图片压缩质量，默认0.92\r\n * @param {string=} type - 确定转换后的图片类型，选项有 "image/png", "image/jpeg", "image/gif",默认"image/jpeg"\r\n * @returns {Promise(Blob)}\r\n */\r\nfunction canvastoFile(canvas, quality = 0.92, type = EImageType.JPEG) {\r\n    return new Promise(resolve => canvas.toBlob(blob => resolve(blob), type, quality));\r\n}\r\n;\r\n\n// CONCATENATED MODULE: ./src/dataURLtoFile.ts\nvar dataURLtoFile_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n/**\r\n * 将一个dataURL字符串转变为一个File（Blob）对象\r\n * 转变时可以确定File对象的类型\r\n *\r\n * @param {string} dataURL\r\n * @param {string=} type - 确定转换后的图片类型，选项有 "image/png", "image/jpeg", "image/gif"\r\n * @returns {Promise(Blob)}\r\n */\r\nfunction dataURLtoFile(dataURL, type) {\r\n    return dataURLtoFile_awaiter(this, void 0, void 0, function* () {\r\n        const arr = dataURL.split(\',\');\r\n        let mime = arr[0].match(/:(.*?);/)[1];\r\n        const bstr = atob(arr[1]);\r\n        let n = bstr.length;\r\n        const u8arr = new Uint8Array(n);\r\n        while (n--) {\r\n            u8arr[n] = bstr.charCodeAt(n);\r\n        }\r\n        if (checkImageType(type)) {\r\n            mime = type;\r\n        }\r\n        return new Blob([u8arr], {\r\n            type: mime,\r\n        });\r\n    });\r\n}\r\n;\r\n\n// CONCATENATED MODULE: ./src/dataURLtoImage.ts\n/**\r\n * 将dataURL字符串转变为image对象\r\n *\r\n * @param {srting} dataURL - dataURL字符串\r\n * @returns {Promise(Image)}\r\n */\r\nfunction dataURLtoImage(dataURL) {\r\n    return new Promise((resolve, reject) => {\r\n        const img = new Image();\r\n        img.onload = () => resolve(img);\r\n        img.onerror = () => reject(new Error(\'dataURLtoImage(): dataURL is illegal\'));\r\n        img.src = dataURL;\r\n    });\r\n}\r\n;\r\n\n// CONCATENATED MODULE: ./src/downloadFile.ts\n/**\r\n * 将图片下载到本地\r\n *\r\n * @param {Blob} file - 一个File（Blob）对象\r\n * @param {string=} fileName - 下载后的文件名（可选参数，不传以时间戳命名文件）\r\n */\r\nfunction downloadFile(file, fileName) {\r\n    const link = document.createElement(\'a\');\r\n    link.href = window.URL.createObjectURL(file);\r\n    link.download = fileName || Date.now().toString(36);\r\n    document.body.appendChild(link);\r\n    const evt = document.createEvent(\'MouseEvents\');\r\n    evt.initEvent(\'click\', false, false);\r\n    link.dispatchEvent(evt);\r\n    document.body.removeChild(link);\r\n}\r\n;\r\n\n// CONCATENATED MODULE: ./src/filetoDataURL.ts\n/**\r\n * 将File（Blob）对象转变为一个dataURL字符串\r\n *\r\n * @param {Blob} file\r\n * @returns {Promise(string)} Promise含有一个dataURL字符串参数\r\n */\r\nfunction filetoDataURL(file) {\r\n    return new Promise((resolve) => {\r\n        const reader = new FileReader();\r\n        reader.onloadend = e => resolve(e.target.result);\r\n        reader.readAsDataURL(file);\r\n    });\r\n}\r\n;\r\n\n// EXTERNAL MODULE: ./node_modules/omggif/omggif.js\nvar omggif = __webpack_require__(0);\n\n// CONCATENATED MODULE: ./src/neuquant.js\nfunction NeuQuant() {\r\n    var netsize = 256; // number of colours used\r\n  \r\n    // four primes near 500 - assume no image has a length so large\r\n    // that it is divisible by all four primes\r\n    var prime1 = 499;\r\n    var prime2 = 491;\r\n    var prime3 = 487;\r\n    var prime4 = 503;\r\n  \r\n    // minimum size for input image\r\n    var minpicturebytes = 3 * prime4;\r\n  \r\n    // Network Definitions\r\n  \r\n    var maxnetpos = netsize - 1;\r\n    var netbiasshift = 4; // bias for colour values\r\n    var ncycles = 100; // no. of learning cycles\r\n  \r\n    // defs for freq and bias\r\n    var intbiasshift = 16; // bias for fractions\r\n    var intbias = 1 << intbiasshift;\r\n    var gammashift = 10; // gamma = 1024\r\n    var gamma = 1 << gammashift;\r\n    var betashift = 10;\r\n    var beta = intbias >> betashift; // beta = 1/1024\r\n    var betagamma = intbias << gammashift - betashift;\r\n  \r\n    // defs for decreasing radius factor\r\n    // For 256 colors, radius starts at 32.0 biased by 6 bits\r\n    // and decreases by a factor of 1/30 each cycle\r\n    var initrad = netsize >> 3;\r\n    var radiusbiasshift = 6;\r\n    var radiusbias = 1 << radiusbiasshift;\r\n    var initradius = initrad * radiusbias;\r\n    var radiusdec = 30;\r\n  \r\n    // defs for decreasing alpha factor\r\n    // Alpha starts at 1.0 biased by 10 bits\r\n    var alphabiasshift = 10;\r\n    var initalpha = 1 << alphabiasshift;\r\n    var alphadec;\r\n  \r\n    // radbias and alpharadbias used for radpower calculation\r\n    var radbiasshift = 8;\r\n    var radbias = 1 << radbiasshift;\r\n    var alpharadbshift = alphabiasshift + radbiasshift;\r\n    var alpharadbias = 1 << alpharadbshift;\r\n  \r\n    // Input image\r\n    var thepicture;\r\n    // Height * Width * 3\r\n    var lengthcount;\r\n    // Sampling factor 1..30\r\n    var samplefac;\r\n  \r\n    // The network itself\r\n    var network;\r\n    var netindex = [];\r\n  \r\n    // for network lookup - really 256\r\n    var bias = [];\r\n  \r\n    // bias and freq arrays for learning\r\n    var freq = [];\r\n    var radpower = [];\r\n  \r\n    function NeuQuantConstructor(thepic, len, sample) {\r\n  \r\n      var i;\r\n      var p;\r\n  \r\n      thepicture = thepic;\r\n      lengthcount = len;\r\n      samplefac = sample;\r\n  \r\n      network = new Array(netsize);\r\n  \r\n      for (i = 0; i < netsize; i++) {\r\n        network[i] = new Array(4);\r\n        p = network[i];\r\n        p[0] = p[1] = p[2] = (i << netbiasshift + 8) / netsize | 0;\r\n        freq[i] = intbias / netsize | 0; // 1 / netsize\r\n        bias[i] = 0;\r\n      }\r\n    }\r\n  \r\n    function colorMap() {\r\n      var map = [];\r\n      var index = new Array(netsize);\r\n      for (var i = 0; i < netsize; i++) {\r\n        index[network[i][3]] = i;\r\n      }var k = 0;\r\n      for (var l = 0; l < netsize; l++) {\r\n        var j = index[l];\r\n        map[k++] = network[j][0];\r\n        map[k++] = network[j][1];\r\n        map[k++] = network[j][2];\r\n      }\r\n      return map;\r\n    }\r\n  \r\n    // Insertion sort of network and building of netindex[0..255]\r\n    // (to do after unbias)\r\n    function inxbuild() {\r\n      var i;\r\n      var j;\r\n      var smallpos;\r\n      var smallval;\r\n      var p;\r\n      var q;\r\n      var previouscol;\r\n      var startpos;\r\n  \r\n      previouscol = 0;\r\n      startpos = 0;\r\n  \r\n      for (i = 0; i < netsize; i++) {\r\n  \r\n        p = network[i];\r\n        smallpos = i;\r\n        smallval = p[1]; // index on g\r\n        // find smallest in i..netsize-1\r\n        for (j = i + 1; j < netsize; j++) {\r\n  \r\n          q = network[j];\r\n  \r\n          if (q[1] < smallval) {\r\n            // index on g\r\n            smallpos = j;\r\n            smallval = q[1]; // index on g\r\n          }\r\n        }\r\n  \r\n        q = network[smallpos];\r\n  \r\n        // swap p (i) and q (smallpos) entries\r\n        if (i != smallpos) {\r\n          j = q[0];\r\n          q[0] = p[0];\r\n          p[0] = j;\r\n          j = q[1];\r\n          q[1] = p[1];\r\n          p[1] = j;\r\n          j = q[2];\r\n          q[2] = p[2];\r\n          p[2] = j;\r\n          j = q[3];\r\n          q[3] = p[3];\r\n          p[3] = j;\r\n        }\r\n  \r\n        // smallval entry is now in position i\r\n        if (smallval != previouscol) {\r\n  \r\n          netindex[previouscol] = startpos + i >> 1;\r\n  \r\n          for (j = previouscol + 1; j < smallval; j++) {\r\n            netindex[j] = i;\r\n          }\r\n  \r\n          previouscol = smallval;\r\n          startpos = i;\r\n        }\r\n      }\r\n  \r\n      netindex[previouscol] = startpos + maxnetpos >> 1;\r\n      for (j = previouscol + 1; j < 256; j++) {\r\n        netindex[j] = maxnetpos; // really 256\r\n      }\r\n    }\r\n  \r\n    // Main Learning Loop\r\n  \r\n    function learn() {\r\n      var i;\r\n      var j;\r\n      var b;\r\n      var g;\r\n      var r;\r\n      var radius;\r\n      var rad;\r\n      var alpha;\r\n      var step;\r\n      var delta;\r\n      var samplepixels;\r\n      var p;\r\n      var pix;\r\n      var lim;\r\n  \r\n      if (lengthcount < minpicturebytes) {\r\n        samplefac = 1;\r\n      }\r\n  \r\n      alphadec = 30 + (samplefac - 1) / 3;\r\n      p = thepicture;\r\n      pix = 0;\r\n      lim = lengthcount;\r\n      samplepixels = lengthcount / (3 * samplefac);\r\n      delta = samplepixels / ncycles | 0;\r\n      alpha = initalpha;\r\n      radius = initradius;\r\n  \r\n      rad = radius >> radiusbiasshift;\r\n      if (rad <= 1) {\r\n        rad = 0;\r\n      }\r\n  \r\n      for (i = 0; i < rad; i++) {\r\n        radpower[i] = alpha * ((rad * rad - i * i) * radbias / (rad * rad));\r\n      }\r\n  \r\n      if (lengthcount < minpicturebytes) {\r\n        step = 3;\r\n      } else if (lengthcount % prime1 !== 0) {\r\n        step = 3 * prime1;\r\n      } else {\r\n  \r\n        if (lengthcount % prime2 !== 0) {\r\n          step = 3 * prime2;\r\n        } else {\r\n          if (lengthcount % prime3 !== 0) {\r\n            step = 3 * prime3;\r\n          } else {\r\n            step = 3 * prime4;\r\n          }\r\n        }\r\n      }\r\n  \r\n      i = 0;\r\n  \r\n      while (i < samplepixels) {\r\n  \r\n        b = (p[pix + 0] & 0xff) << netbiasshift;\r\n        g = (p[pix + 1] & 0xff) << netbiasshift;\r\n        r = (p[pix + 2] & 0xff) << netbiasshift;\r\n        j = contest(b, g, r);\r\n  \r\n        altersingle(alpha, j, b, g, r);\r\n  \r\n        if (rad !== 0) {\r\n          // Alter neighbours\r\n          alterneigh(rad, j, b, g, r);\r\n        }\r\n  \r\n        pix += step;\r\n  \r\n        if (pix >= lim) {\r\n          pix -= lengthcount;\r\n        }\r\n  \r\n        i++;\r\n  \r\n        if (delta === 0) {\r\n          delta = 1;\r\n        }\r\n  \r\n        if (i % delta === 0) {\r\n          alpha -= alpha / alphadec;\r\n          radius -= radius / radiusdec;\r\n          rad = radius >> radiusbiasshift;\r\n  \r\n          if (rad <= 1) {\r\n            rad = 0;\r\n          }\r\n  \r\n          for (j = 0; j < rad; j++) {\r\n            radpower[j] = alpha * ((rad * rad - j * j) * radbias / (rad * rad));\r\n          }\r\n        }\r\n      }\r\n    }\r\n  \r\n    // Search for BGR values 0..255 (after net is unbiased) and return colour index\r\n    function map(b, g, r) {\r\n      var i;\r\n      var j;\r\n      var dist;\r\n      var a;\r\n      var bestd;\r\n      var p;\r\n      var best;\r\n  \r\n      // Biggest possible distance is 256 * 3\r\n      bestd = 1000;\r\n      best = -1;\r\n      i = netindex[g]; // index on g\r\n      j = i - 1; // start at netindex[g] and work outwards\r\n  \r\n      while (i < netsize || j >= 0) {\r\n  \r\n        if (i < netsize) {\r\n  \r\n          p = network[i];\r\n  \r\n          dist = p[1] - g; // inx key\r\n  \r\n          if (dist >= bestd) {\r\n            i = netsize; // stop iter\r\n          } else {\r\n  \r\n            i++;\r\n  \r\n            if (dist < 0) {\r\n              dist = -dist;\r\n            }\r\n  \r\n            a = p[0] - b;\r\n  \r\n            if (a < 0) {\r\n              a = -a;\r\n            }\r\n  \r\n            dist += a;\r\n  \r\n            if (dist < bestd) {\r\n              a = p[2] - r;\r\n  \r\n              if (a < 0) {\r\n                a = -a;\r\n              }\r\n  \r\n              dist += a;\r\n  \r\n              if (dist < bestd) {\r\n                bestd = dist;\r\n                best = p[3];\r\n              }\r\n            }\r\n          }\r\n        }\r\n  \r\n        if (j >= 0) {\r\n  \r\n          p = network[j];\r\n  \r\n          dist = g - p[1]; // inx key - reverse dif\r\n  \r\n          if (dist >= bestd) {\r\n            j = -1; // stop iter\r\n          } else {\r\n  \r\n            j--;\r\n            if (dist < 0) {\r\n              dist = -dist;\r\n            }\r\n            a = p[0] - b;\r\n            if (a < 0) {\r\n              a = -a;\r\n            }\r\n            dist += a;\r\n  \r\n            if (dist < bestd) {\r\n              a = p[2] - r;\r\n              if (a < 0) {\r\n                a = -a;\r\n              }\r\n              dist += a;\r\n              if (dist < bestd) {\r\n                bestd = dist;\r\n                best = p[3];\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n  \r\n      return best;\r\n    }\r\n  \r\n    function process() {\r\n      learn();\r\n      unbiasnet();\r\n      inxbuild();\r\n      return colorMap();\r\n    }\r\n  \r\n    // Unbias network to give byte values 0..255 and record position i\r\n    // to prepare for sort\r\n    function unbiasnet() {\r\n      var i;\r\n      var j;\r\n  \r\n      for (i = 0; i < netsize; i++) {\r\n        network[i][0] >>= netbiasshift;\r\n        network[i][1] >>= netbiasshift;\r\n        network[i][2] >>= netbiasshift;\r\n        network[i][3] = i; // record colour no\r\n      }\r\n    }\r\n  \r\n    // Move adjacent neurons by precomputed alpha*(1-((i-j)^2/[r]^2))\r\n    // in radpower[|i-j|]\r\n    function alterneigh(rad, i, b, g, r) {\r\n  \r\n      var j;\r\n      var k;\r\n      var lo;\r\n      var hi;\r\n      var a;\r\n      var m;\r\n  \r\n      var p;\r\n  \r\n      lo = i - rad;\r\n      if (lo < -1) {\r\n        lo = -1;\r\n      }\r\n  \r\n      hi = i + rad;\r\n  \r\n      if (hi > netsize) {\r\n        hi = netsize;\r\n      }\r\n  \r\n      j = i + 1;\r\n      k = i - 1;\r\n      m = 1;\r\n  \r\n      while (j < hi || k > lo) {\r\n  \r\n        a = radpower[m++];\r\n  \r\n        if (j < hi) {\r\n  \r\n          p = network[j++];\r\n  \r\n          try {\r\n  \r\n            p[0] -= a * (p[0] - b) / alpharadbias | 0;\r\n            p[1] -= a * (p[1] - g) / alpharadbias | 0;\r\n            p[2] -= a * (p[2] - r) / alpharadbias | 0;\r\n          } catch (e) {}\r\n        }\r\n  \r\n        if (k > lo) {\r\n  \r\n          p = network[k--];\r\n  \r\n          try {\r\n  \r\n            p[0] -= a * (p[0] - b) / alpharadbias | 0;\r\n            p[1] -= a * (p[1] - g) / alpharadbias | 0;\r\n            p[2] -= a * (p[2] - r) / alpharadbias | 0;\r\n          } catch (e) {}\r\n        }\r\n      }\r\n    }\r\n  \r\n    // Move neuron i towards biased (b,g,r) by factor alpha\r\n    function altersingle(alpha, i, b, g, r) {\r\n  \r\n      // alter hit neuron\r\n      var n = network[i];\r\n      var alphaMult = alpha / initalpha;\r\n      n[0] -= alphaMult * (n[0] - b) | 0;\r\n      n[1] -= alphaMult * (n[1] - g) | 0;\r\n      n[2] -= alphaMult * (n[2] - r) | 0;\r\n    }\r\n  \r\n    // Search for biased BGR values\r\n    function contest(b, g, r) {\r\n  \r\n      // finds closest neuron (min dist) and updates freq\r\n      // finds best neuron (min dist-bias) and returns position\r\n      // for frequently chosen neurons, freq[i] is high and bias[i] is negative\r\n      // bias[i] = gamma*((1/netsize)-freq[i])\r\n  \r\n      var i;\r\n      var dist;\r\n      var a;\r\n      var biasdist;\r\n      var betafreq;\r\n      var bestpos;\r\n      var bestbiaspos;\r\n      var bestd;\r\n      var bestbiasd;\r\n      var n;\r\n  \r\n      bestd = ~(1 << 31);\r\n      bestbiasd = bestd;\r\n      bestpos = -1;\r\n      bestbiaspos = bestpos;\r\n  \r\n      for (i = 0; i < netsize; i++) {\r\n  \r\n        n = network[i];\r\n        dist = n[0] - b;\r\n  \r\n        if (dist < 0) {\r\n          dist = -dist;\r\n        }\r\n  \r\n        a = n[1] - g;\r\n  \r\n        if (a < 0) {\r\n          a = -a;\r\n        }\r\n  \r\n        dist += a;\r\n  \r\n        a = n[2] - r;\r\n  \r\n        if (a < 0) {\r\n          a = -a;\r\n        }\r\n  \r\n        dist += a;\r\n  \r\n        if (dist < bestd) {\r\n          bestd = dist;\r\n          bestpos = i;\r\n        }\r\n  \r\n        biasdist = dist - (bias[i] >> intbiasshift - netbiasshift);\r\n  \r\n        if (biasdist < bestbiasd) {\r\n          bestbiasd = biasdist;\r\n          bestbiaspos = i;\r\n        }\r\n  \r\n        betafreq = freq[i] >> betashift;\r\n        freq[i] -= betafreq;\r\n        bias[i] += betafreq << gammashift;\r\n      }\r\n  \r\n      freq[bestpos] += beta;\r\n      bias[bestpos] -= betagamma;\r\n      return bestbiaspos;\r\n    }\r\n  \r\n    NeuQuantConstructor.apply(this, arguments);\r\n\r\n    let exports = {};\r\n    exports.map = map;\r\n    exports.process = process;\r\n\r\n    return exports;\r\n  }\n// CONCATENATED MODULE: ./src/imageDataToRGB.ts\n/**\r\n * 将File（Blob）对象转变为一个dataURL字符串\r\n *\r\n * @param {ImageData} data\r\n * @returns {number[]]} []\r\n */\r\nfunction imageDataToRGB(data, width, height) {\r\n    let length = width * height * 4;\r\n    let i = 0;\r\n    let rgb = [];\r\n    while (i < length) {\r\n        rgb.push(data[i++]);\r\n        rgb.push(data[i++]);\r\n        rgb.push(data[i++]);\r\n        i++; // for the alpha channel which we don\'t care about\r\n    }\r\n    return rgb;\r\n}\r\n\n// CONCATENATED MODULE: ./src/processFrameWithQuantizer.ts\n\r\n\r\nfunction componentizedPaletteToArray(paletteRGB) {\r\n    paletteRGB = paletteRGB || [];\r\n    let paletteArray = [];\r\n    for (let i = 0; i < paletteRGB.length; i += 3) {\r\n        let r = paletteRGB[i];\r\n        let g = paletteRGB[i + 1];\r\n        let b = paletteRGB[i + 2];\r\n        paletteArray.push(r << 16 | g << 8 | b);\r\n    }\r\n    return paletteArray;\r\n}\r\n/**\r\n * 将File（Blob）对象转变为一个dataURL字符串\r\n * https://github.com/yahoo/gifshot/blob/master/src/gifshot.js\r\n *\r\n * @param {ImageData} imageData\r\n * @param {number} width\r\n * @param {number} height\r\n * @param {number} sampleInterval\r\n * @returns {Array} Promise含有一个dataURL字符串参数\r\n */\r\nfunction processFrameWithQuantizer(imageData, width, height, sampleInterval) {\r\n    let rgbComponents = imageDataToRGB(Array.prototype.slice.call(imageData.data), width, height);\r\n    let numberPixels = width * height;\r\n    let nq = NeuQuant(rgbComponents, rgbComponents.length, sampleInterval);\r\n    let paletteRGBnq = nq.process();\r\n    let paletteArray = [];\r\n    // Check line 1135, gifshot.js.\r\n    paletteArray = new Uint32Array(componentizedPaletteToArray(paletteRGBnq));\r\n    let indexedPixels = new Uint8Array(numberPixels);\r\n    let k = 0;\r\n    for (let i = 0; i < numberPixels; i++) {\r\n        let r = rgbComponents[k++];\r\n        let g = rgbComponents[k++];\r\n        let b = rgbComponents[k++];\r\n        indexedPixels[i] = nq.map(r, g, b);\r\n    }\r\n    return {\r\n        pixels: indexedPixels,\r\n        palette: paletteArray\r\n    };\r\n}\r\n\n// CONCATENATED MODULE: ./src/urltoBlob.ts\n/**\r\n * 通过一个图片的url加载所需要的File（Blob）对象\r\n *\r\n * @param {string} url - 图片URL\r\n * @returns {Promise(Blob)}\r\n *\r\n */\r\nfunction urltoBlob(url) {\r\n    return fetch(url).then(response => response.blob());\r\n}\r\n;\r\n\n// CONCATENATED MODULE: ./src/imagetoCanvas.ts\nvar imagetoCanvas_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\nfunction scaleImageData(image, scale_x, scale_y) {\r\n    let canvas = document.createElement(\'canvas\');\r\n    canvas.width = image.width;\r\n    canvas.height = image.height;\r\n    let context = canvas.getContext(\'2d\');\r\n    context.drawImage(image, 0, 0);\r\n    let tmpCanvas = document.createElement(\'canvas\');\r\n    tmpCanvas.width = image.width * scale_x;\r\n    tmpCanvas.height = image.height * scale_y;\r\n    let tmpCtx = tmpCanvas.getContext(\'2d\');\r\n    tmpCtx.scale(scale_x, scale_y);\r\n    tmpCtx.drawImage(canvas, 0, 0, canvas.width, canvas.height);\r\n    return tmpCtx.getImageData(0, 0, tmpCanvas.width, tmpCanvas.height);\r\n}\r\nfunction rotateCanvas(image, orientation) {\r\n    let canvas = document.createElement(\'canvas\');\r\n    canvas.width = image.width;\r\n    canvas.height = image.height;\r\n    let context = canvas.getContext(\'2d\');\r\n    return rotateCanvasInPlace(image, orientation, canvas, context);\r\n}\r\nfunction rotateCanvasInPlace(image, orientation, cvs, ctx) {\r\n    // 设置方向\r\n    switch (orientation) {\r\n        case 3:\r\n            ctx.rotate(180 * Math.PI / 180);\r\n            ctx.drawImage(image, -cvs.width, -cvs.height, cvs.width, cvs.height);\r\n            break;\r\n        case 6:\r\n            ctx.rotate(90 * Math.PI / 180);\r\n            ctx.drawImage(image, 0, -cvs.width, cvs.height, cvs.width);\r\n            break;\r\n        case 8:\r\n            ctx.rotate(270 * Math.PI / 180);\r\n            ctx.drawImage(image, -cvs.height, 0, cvs.height, cvs.width);\r\n            break;\r\n        case 2:\r\n            ctx.translate(cvs.width, 0);\r\n            ctx.scale(-1, 1);\r\n            ctx.drawImage(image, 0, 0, cvs.width, cvs.height);\r\n            break;\r\n        case 4:\r\n            ctx.translate(cvs.width, 0);\r\n            ctx.scale(-1, 1);\r\n            ctx.rotate(180 * Math.PI / 180);\r\n            ctx.drawImage(image, -cvs.width, -cvs.height, cvs.width, cvs.height);\r\n            break;\r\n        case 5:\r\n            ctx.translate(cvs.width, 0);\r\n            ctx.scale(-1, 1);\r\n            ctx.rotate(90 * Math.PI / 180);\r\n            ctx.drawImage(image, 0, -cvs.width, cvs.height, cvs.width);\r\n            break;\r\n        case 7:\r\n            ctx.translate(cvs.width, 0);\r\n            ctx.scale(-1, 1);\r\n            ctx.rotate(270 * Math.PI / 180);\r\n            ctx.drawImage(image, -cvs.height, 0, cvs.height, cvs.width);\r\n            break;\r\n        default:\r\n            ctx.drawImage(image, 0, 0, cvs.width, cvs.height);\r\n    }\r\n    return cvs;\r\n}\r\nfunction imageDataToCanvas(imageData, width, height) {\r\n    let canvas = document.createElement(\'canvas\');\r\n    canvas.width = width;\r\n    canvas.height = height;\r\n    let context = canvas.getContext(\'2d\');\r\n    context.putImageData(imageData, 0, 0);\r\n    return canvas;\r\n}\r\n/**\r\n * 将一个image对象转变为一个canvas对象\r\n *\r\n * @param {image} image\r\n *\r\n * @typedef {Object=} config - 转变为canvas时的一些参数配置\r\n * \t\t@param {number} width - canvas图像的宽度，默认为image的宽度\r\n * \t\t@param {number} height - canvas图像的高度，默认为image的高度\r\n * \t\t@param {number} scale - 相对于image的缩放比例，范围0-10，默认不缩放；\r\n * \t\t\t设置config.scale后会覆盖config.width和config.height的设置；\r\n * \t\t@param {number} orientation - 图片旋转参数，默认不旋转，参考如下：\r\n * \t\t\t参数\t 旋转方向\r\n * \t\t\t1\t\t0°\r\n * \t\t\t2\t\t水平翻转\r\n * \t\t\t3\t\t180°\r\n * \t\t\t4\t\t垂直翻转\r\n * \t\t\t5\t\t顺时针90°+水平翻转\r\n * \t\t\t6\t\t顺时针90°\r\n * \t\t\t7\t\t顺时针90°+垂直翻转\r\n * \t\t\t8\t\t逆时针90°\r\n * @type {config}\r\n *\r\n * @returns {Promise(canvas)}\r\n */\r\nfunction imagetoCanvas(image, config = {}) {\r\n    return imagetoCanvas_awaiter(this, void 0, void 0, function* () {\r\n        const myConfig = Object.assign({}, config);\r\n        const cvs = document.createElement(\'canvas\');\r\n        const ctx = cvs.getContext(\'2d\');\r\n        let height;\r\n        let width;\r\n        for (const i in myConfig) {\r\n            if (Object.prototype.hasOwnProperty.call(myConfig, i)) {\r\n                myConfig[i] = Number(myConfig[i]);\r\n            }\r\n        }\r\n        // 设置宽高\r\n        if (!myConfig.scale) {\r\n            width = myConfig.width || myConfig.height * image.width / image.height || image.width;\r\n            height = myConfig.height || myConfig.width * image.height / image.width || image.height;\r\n        }\r\n        else {\r\n            // 缩放比例0-10，不在此范围则保持原来图像大小\r\n            const scale = myConfig.scale > 0 && myConfig.scale < 10 ? myConfig.scale : 1;\r\n            width = Math.floor(image.width * scale);\r\n            height = Math.floor(image.height * scale);\r\n        }\r\n        // 当顺时针或者逆时针旋转90时，需要交换canvas的宽高\r\n        if ([5, 6, 7, 8].some(i => i === myConfig.orientation)) {\r\n            cvs.height = width;\r\n            cvs.width = height;\r\n        }\r\n        else {\r\n            cvs.height = height;\r\n            cvs.width = width;\r\n        }\r\n        // GIF read/write.\r\n        let blob = yield urltoBlob(image.src);\r\n        if (blob.type == "image/gif") {\r\n            let buf = new Uint8Array(yield blob.arrayBuffer());\r\n            let reader = new omggif["GifReader"](buf);\r\n            let gifOptions = {\r\n                loop: reader.loopCount(),\r\n            };\r\n            let writtenBuf = new Uint8Array(width * height * reader.numFrames() * 5);\r\n            let writer = new omggif["GifWriter"](writtenBuf, width, height, gifOptions);\r\n            let imageDatas = new Array(reader.numFrames());\r\n            for (let k = 0; k < imageDatas.length; k++) {\r\n                let image = new ImageData(reader.width, reader.height);\r\n                let frameInfo = reader.frameInfo(k);\r\n                // https://github.com/CaptainCodeman/gif-player/blob/d45eecdb7458e08c565341b2eb2d68195329f247/components/gif-player/src/gif-player.js#L357\r\n                if (k > 0 && frameInfo.disposal < 2) {\r\n                    image.data.set(new Uint8ClampedArray(imageDatas[k - 1].data));\r\n                }\r\n                reader.decodeAndBlitFrameRGBA(k, image.data);\r\n                imageDatas[k] = image;\r\n            }\r\n            ;\r\n            // Write\r\n            imageDatas.map((image, k) => {\r\n                let frameInfo = reader.frameInfo(k);\r\n                let canvas = imageDataToCanvas(image, image.width, image.height);\r\n                canvas = rotateCanvas(canvas, myConfig.orientation);\r\n                // image = imageDataToCanvas(image, image.width, image.height).getContext(\'2d\').getImageData(0, 0, image.width, image.height);\r\n                image = scaleImageData(canvas, width / image.width, height / image.height);\r\n                let frameNq = processFrameWithQuantizer(image, width, height, 10);\r\n                let frameOptions = {\r\n                    palette: Array.prototype.slice.call(frameNq.palette),\r\n                    delay: frameInfo.delay,\r\n                    disposal: frameInfo.disposal,\r\n                };\r\n                writer.addFrame(0, 0, width, height, frameNq.pixels, frameOptions);\r\n            });\r\n            let base64Png = imageDatas.map((image, k) => {\r\n                let canvas = imageDataToCanvas(image, image.width, image.height);\r\n                canvas = rotateCanvas(canvas, myConfig.orientation);\r\n                return canvas.toDataURL("image/png");\r\n            });\r\n            console.log(base64Png);\r\n            writer.end();\r\n            let bufStr = bufferToString(writtenBuf);\r\n            let gif = `data:image/gif;base64,${btoa(bufStr)}`;\r\n            console.log(gif);\r\n        }\r\n        rotateCanvasInPlace(image, myConfig.orientation, cvs, ctx);\r\n        return cvs;\r\n    });\r\n}\r\n;\r\nlet byteMap = [];\r\nfor (let i = 0; i < 256; i++) {\r\n    byteMap[i] = String.fromCharCode(i);\r\n}\r\nfunction bufferToString(buffer) {\r\n    let numberValues = buffer.length;\r\n    let str = \'\';\r\n    let x = -1;\r\n    while (++x < numberValues) {\r\n        str += byteMap[buffer[x]];\r\n    }\r\n    return str;\r\n}\r\n\n// CONCATENATED MODULE: ./src/urltoImage.ts\n/**\r\n * 通过一个图片的url加载所需要的image对象\r\n *\r\n * @param {string} url - 图片URL\r\n * @returns {Promise(Image)}\r\n */\r\nfunction urltoImage(url) {\r\n    return new Promise((resolve, reject) => {\r\n        const img = new Image();\r\n        img.onload = () => resolve(img);\r\n        img.onerror = () => reject(new Error(\'urltoImage(): Image failed to load, please check the image URL\'));\r\n        img.src = url;\r\n    });\r\n}\r\n;\r\n\n// CONCATENATED MODULE: ./src/index.ts\nvar src_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * 压缩File（Blob）对象\r\n * @param {Blob} file - 一个File（Blob）对象\r\n * @param {(number|object)} config - 如果传入是number类型，传入范围 0-1，表示图片压缩质量,默认0.92；也可以传入object类型，以便更详细的配置\r\n * @example\r\n * \t\timageConversion.compress(file,0.8)\r\n *\r\n * \t\timageConversion.compress(file,{\r\n * \t\t\tquality: 0.8, //图片压缩质量\r\n * \t\t\ttype："image/png", //转换后的图片类型，选项有 "image/png", "image/jpeg", "image/gif"\r\n * \t\t\twidth: 300, //生成图片的宽度\r\n * \t\t\theight：200， //生产图片的高度\r\n * \t\t\tscale: 0.5， //相对于原始图片的缩放比率,设置config.scale后会覆盖config.width和config.height的设置；\r\n * \t\t\torientation:2, //图片旋转方向\r\n * \t\t})\r\n *\r\n * @returns {Promise(Blob)}\r\n */\r\nfunction compress(file, config = {}) {\r\n    return src_awaiter(this, void 0, void 0, function* () {\r\n        if (!(file instanceof Blob)) {\r\n            throw new Error(\'compress(): First arg must be a Blob object or a File object.\');\r\n        }\r\n        if (typeof config !== \'object\') {\r\n            config = Object.assign({\r\n                quality: config,\r\n            });\r\n        }\r\n        config.quality = Number(config.quality);\r\n        if (Number.isNaN(config.quality)) {\r\n            return file;\r\n        }\r\n        const dataURL = yield filetoDataURL(file);\r\n        let originalMime = dataURL.split(\',\')[0].match(/:(.*?);/)[1]; // 原始图像图片类型\r\n        let mime = EImageType.JPEG; // 默认压缩类型\r\n        if (checkImageType(config.type)) {\r\n            mime = config.type;\r\n            originalMime = config.type;\r\n        }\r\n        const image = yield dataURLtoImage(dataURL);\r\n        const canvas = yield imagetoCanvas(image, Object.assign({}, config));\r\n        const compressDataURL = yield canvastoDataURL(canvas, config.quality, mime);\r\n        const compressFile = yield dataURLtoFile(compressDataURL, originalMime);\r\n        if (compressFile.size > file.size) {\r\n            return file;\r\n        }\r\n        return compressFile;\r\n    });\r\n}\r\n;\r\n/**\r\n * 根据体积压缩File（Blob）对象\r\n *\r\n * @param {Blob} file - 一个File（Blob）对象\r\n * @param {(number|object)} config - 如果传入是number类型，则指定压缩图片的体积,单位Kb;也可以传入object类型，以便更详细的配置\r\n * \t\t@param {number} size - 指定压缩图片的体积,单位Kb\r\n * \t\t@param {number} accuracy - 相对于指定压缩体积的精确度，范围0.8-0.99，默认0.95；\r\n *        如果设置 图片体积1000Kb,精确度0.9，则压缩结果为900Kb-1100Kb的图片都算合格；\r\n * @example\r\n *  \timageConversion.compress(file,100) //压缩后图片大小为100kb\r\n *\r\n * \t\timageConversion.compress(file,{\r\n * \t\t\tsize: 100, //图片压缩体积，单位Kb\r\n * \t\t\taccuracy: 0.9, //图片压缩体积的精确度，默认0.95\r\n * \t\t\ttype："image/png", //转换后的图片类型，选项有 "image/png", "image/jpeg", "image/gif"\r\n * \t\t\twidth: 300, //生成图片的宽度\r\n * \t\t\theight: 200, //生产图片的高度\r\n * \t\t\tscale: 0.5, //相对于原始图片的缩放比率,设置config.scale后会覆盖config.width和config.height的设置；\r\n * \t\t\torientation:2, //图片旋转方向\r\n * \t\t})\r\n *\r\n * @returns {Promise(Blob)}\r\n */\r\nfunction compressAccurately(file, config = {}) {\r\n    return src_awaiter(this, void 0, void 0, function* () {\r\n        if (!(file instanceof Blob)) {\r\n            throw new Error(\'compressAccurately(): First arg must be a Blob object or a File object.\');\r\n        }\r\n        if (typeof config !== \'object\') {\r\n            config = Object.assign({\r\n                size: config,\r\n            });\r\n        }\r\n        // 如果指定体积不是数字或者数字字符串，则不做处理\r\n        config.size = Number(config.size);\r\n        if (Number.isNaN(config.size)) {\r\n            return file;\r\n        }\r\n        // 如果指定体积大于原文件体积，则不做处理；\r\n        if (config.size * 1024 > file.size) {\r\n            return file;\r\n        }\r\n        config.accuracy = Number(config.accuracy);\r\n        if (!config.accuracy\r\n            || config.accuracy < 0.8\r\n            || config.accuracy > 0.99) {\r\n            config.accuracy = 0.95; // 默认精度0.95\r\n        }\r\n        const resultSize = {\r\n            max: config.size * (2 - config.accuracy) * 1024,\r\n            accurate: config.size * 1024,\r\n            min: config.size * config.accuracy * 1024,\r\n        };\r\n        const dataURL = yield filetoDataURL(file);\r\n        let originalMime = dataURL.split(\',\')[0].match(/:(.*?);/)[1]; // 原始图像图片类型\r\n        let mime = EImageType.JPEG;\r\n        if (checkImageType(config.type)) {\r\n            mime = config.type;\r\n            originalMime = config.type;\r\n        }\r\n        const image = yield dataURLtoImage(dataURL);\r\n        const canvas = yield imagetoCanvas(image, Object.assign({}, config));\r\n        /**\r\n         * 经过测试发现，blob.size与dataURL.length的比值约等于0.75\r\n         * 这个比值可以同过dataURLtoFile这个方法来测试验证\r\n         * 这里为了提高性能，直接通过这个比值来计算出blob.size\r\n         */\r\n        const proportion = 0.75;\r\n        let imageQuality = 0.5;\r\n        let compressDataURL;\r\n        const tempDataURLs = [null, null];\r\n        /**\r\n         * HTMLCanvasElement.toBlob()以及HTMLCanvasElement.toDataURL()压缩参数\r\n         * 的最小细粒度为0.01，而2的7次方为128，即只要循环7次，则会覆盖所有可能性\r\n         */\r\n        for (let x = 1; x <= 7; x++) {\r\n            compressDataURL = yield canvastoDataURL(canvas, imageQuality, mime);\r\n            const CalculationSize = compressDataURL.length * proportion;\r\n            // 如果到循环第七次还没有达到精确度的值，那说明该图片不能达到到此精确度要求\r\n            // 这时候最后一次循环出来的dataURL可能不是最精确的，需要取其周边两个dataURL三者比较来选出最精确的；\r\n            if (x === 7) {\r\n                if (resultSize.max < CalculationSize || resultSize.min > CalculationSize) {\r\n                    compressDataURL = [compressDataURL, ...tempDataURLs]\r\n                        .filter(i => i) // 去除null\r\n                        .sort((a, b) => Math.abs(a.length * proportion - resultSize.accurate)\r\n                        - Math.abs(b.length * proportion - resultSize.accurate))[0];\r\n                }\r\n                break;\r\n            }\r\n            if (resultSize.max < CalculationSize) {\r\n                tempDataURLs[1] = compressDataURL;\r\n                imageQuality -= Math.pow(0.5, (x + 1));\r\n            }\r\n            else if (resultSize.min > CalculationSize) {\r\n                tempDataURLs[0] = compressDataURL;\r\n                imageQuality += Math.pow(0.5, (x + 1));\r\n            }\r\n            else {\r\n                break;\r\n            }\r\n        }\r\n        const compressFile = yield dataURLtoFile(compressDataURL, originalMime);\r\n        // 如果压缩后体积大于原文件体积，则返回源文件；\r\n        if (compressFile.size > file.size) {\r\n            return file;\r\n        }\r\n        return compressFile;\r\n    });\r\n}\r\n;\r\n\r\n\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pbWFnZUNvbnZlcnNpb24vLi9zcmMvbW9kZWxzL2luZGV4LnRzPzBkNTkiLCJ3ZWJwYWNrOi8vaW1hZ2VDb252ZXJzaW9uLy4vc3JjL3V0aWxzL2NoZWNrSW1hZ2VUeXBlLnRzPzhhYTYiLCJ3ZWJwYWNrOi8vaW1hZ2VDb252ZXJzaW9uLy4vc3JjL3V0aWxzL2luZGV4LnRzP2QyNTciLCJ3ZWJwYWNrOi8vaW1hZ2VDb252ZXJzaW9uLy4vc3JjL2NhbnZhc3RvRGF0YVVSTC50cz81ZjU0Iiwid2VicGFjazovL2ltYWdlQ29udmVyc2lvbi8uL3NyYy9jYW52YXN0b0ZpbGUudHM/OTA4OSIsIndlYnBhY2s6Ly9pbWFnZUNvbnZlcnNpb24vLi9zcmMvZGF0YVVSTHRvRmlsZS50cz84NTRkIiwid2VicGFjazovL2ltYWdlQ29udmVyc2lvbi8uL3NyYy9kYXRhVVJMdG9JbWFnZS50cz82MDJkIiwid2VicGFjazovL2ltYWdlQ29udmVyc2lvbi8uL3NyYy9kb3dubG9hZEZpbGUudHM/YTRlZSIsIndlYnBhY2s6Ly9pbWFnZUNvbnZlcnNpb24vLi9zcmMvZmlsZXRvRGF0YVVSTC50cz8xNGNhIiwid2VicGFjazovL2ltYWdlQ29udmVyc2lvbi8uL3NyYy9uZXVxdWFudC5qcz84MjBmIiwid2VicGFjazovL2ltYWdlQ29udmVyc2lvbi8uL3NyYy9pbWFnZURhdGFUb1JHQi50cz8xMmI2Iiwid2VicGFjazovL2ltYWdlQ29udmVyc2lvbi8uL3NyYy9wcm9jZXNzRnJhbWVXaXRoUXVhbnRpemVyLnRzPzdmZTIiLCJ3ZWJwYWNrOi8vaW1hZ2VDb252ZXJzaW9uLy4vc3JjL3VybHRvQmxvYi50cz8wYjg2Iiwid2VicGFjazovL2ltYWdlQ29udmVyc2lvbi8uL3NyYy9pbWFnZXRvQ2FudmFzLnRzPzhmMDciLCJ3ZWJwYWNrOi8vaW1hZ2VDb252ZXJzaW9uLy4vc3JjL3VybHRvSW1hZ2UudHM/MTZhYyIsIndlYnBhY2s6Ly9pbWFnZUNvbnZlcnNpb24vLi9z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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLGFBQWE7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUIsYUFBYTs7QUFFOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHOztBQzFoQkE7Ozs7O0dBS0c7QUFDWSxTQUFTLGNBQWMsQ0FBQyxJQUFRLEVBQUUsS0FBYSxFQUFFLE1BQWM7SUFDNUUsSUFBSSxNQUFNLEdBQUcsS0FBSyxHQUFHLE1BQU0sR0FBRyxDQUFDLENBQUM7SUFDaEMsSUFBSSxDQUFDLEdBQUcs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Q0FBQyxHQUFHLEdBQUcsSUFBSSxDQUFDLEVBQUUsR0FBRyxHQUFHLENBQUMsQ0FBQztZQUNoQyxHQUFHLENBQUMsU0FBUyxDQUFDLEtBQUssRUFBRSxDQUFDLEdBQUcsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxNQUFNLEVBQUUsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQzVELE1BQU07UUFDUixLQUFLLENBQUM7WUFDSixHQUFHLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFDNUIsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztZQUNqQixHQUFHLENBQUMsU0FBUyxDQUFDLEtBQUssRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxLQUFLLEVBQUUsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBQ2xELE1BQU07UUFDUixLQUFLLENBQUM7WUFDSixHQUFHLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFDNUIsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztZQUNqQixHQUFHLENBQUMsTUFBTSxDQUFDLEdBQUcsR0FBRyxJQUFJLENBQUMsRUFBRSxHQUFHLEdBQUcsQ0FBQyxDQUFDO1lBQ2hDLEdBQUcsQ0FBQyxTQUFTLENBQUMsS0FBSyxFQUFFLENBQUMsR0FBRyxDQUFDLEtBQUssRUFBRSxDQUFDLEdBQUcsQ0FBQyxNQUFNLEVBQUUsR0FBRyxDQUFDLEtBQUssRUFBRSxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUM7WUFDckUsTUFBTTtRQUNSLEtBQUssQ0FBQztZQUNKLEdBQUcsQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUMsQ0FBQztZQUM1QixHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1lBQ2pC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OzBCQUNqRSxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxNQUFNLEdBQUcsVUFBVSxHQUFHLFVBQVUsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO2lCQUNqRTtnQkFDRCxNQUFNO2FBQ1A7WUFDRCxJQUFJLFVBQVUsQ0FBQyxHQUFHLEdBQUcsZUFBZSxFQUFFO2dCQUNwQyxZQUFZLENBQUMsQ0FBQyxDQUFDLEdBQUcsZUFBZSxDQUFDO2dCQUNsQyxZQUFZLElBQUksWUFBRyxFQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFDO2FBQ2hDO2lCQUFNLElBQUksVUFBVSxDQUFDLEdBQUcsR0FBRyxlQUFlLEVBQUU7Z0JBQzNDLFlBQVksQ0FBQyxDQUFDLENBQUMsR0FBRyxlQUFlLENBQUM7Z0JBQ2xDLFlBQVksSUFBSSxZQUFHLEVBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQUM7YUFDaEM7aUJBQU07Z0JBQ0wsTUFBTTthQUNQO1NBQ0Y7UUFDRCxNQUFNLFlBQVksR0FBRyxNQUFNLGFBQWEsQ0FBQyxlQUFlLEVBQUUsWUFBWSxDQUFDLENBQUM7UUFDeEUseUJBQXlCO1FBQ3pCLElBQUksWUFBWSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsSUFBSSxFQUFFO1lBQ2pDLE9BQU8sSUFBSSxDQUFDO1NBQ2I7UUFDRCxPQUFPLFlBQVksQ0FBQztJQUN0QixDQUFDO0NBQUE7QUFBQSxDQUFDO0FBY0E7QUFJQSIsImZpbGUiOiIxLmpzIiwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGVudW0gRUltYWdlVHlwZSB7XHJcbiAgJ1BORycgPSAnaW1hZ2UvcG5nJyxcclxuICAnSlBFRycgPSAnaW1hZ2UvanBlZycsXHJcbiAgJ0dJRicgPSAnaW1hZ2UvZ2lmJ1xyXG59XHJcblxyXG5pbnRlcmZhY2UgSUJhc2VDb25maWcge1xyXG4gIFtrZXk6IHN0cmluZ106IGFueTtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBJbWFnZTJDYW52YXNDb25maWcgZXh0ZW5kcyBJQmFzZUNvbmZpZyB7XHJcbiAgd2lkdGg/OiBudW1iZXIsXHJcbiAgaGVpZ2h0PzogbnVtYmVyLFxyXG4gIHNjYWxlPzogbnVtYmVyLFxyXG4gIG9yaWVudGF0aW9uPzogbnVtYmVyLFxyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIElDb21wcmVzc0NvbmZpZyBleHRlbmRzIEltYWdlMkNhbnZhc0NvbmZpZyB7XHJcbiAgcXVhbGl0eT86IG51bWJlcixcclxuICB0eXBlPzogRUltYWdlVHlwZSxcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBjb21wcmVzc0FjY3VyYXRlbHlDb25maWcgZXh0ZW5kcyBJbWFnZTJDYW52YXNDb25maWcge1xyXG4gIHNpemU/OiBudW1iZXIsXHJcbiAgYWNjdXJhY3k/OiBudW1iZXIsXHJcbiAgdHlwZT86IEVJbWFnZVR5cGUsXHJcbn0iLCJpbXBvcnQgeyBFSW1hZ2VUeXBlIH0gZnJvbSAnQG1vZGVscyc7XHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNoZWNrSW1hZ2VUeXBlKHR5cGU6IEVJbWFnZVR5cGUpIHtcclxuICByZXR1cm4gWydpbWFnZS9wbmcnLCAnaW1hZ2UvanBlZycsICdpbWFnZS9naWYnXS5zb21lKGkgPT4gaSA9PT0gdHlwZSk7XHJcbn0iLCJpbXBvcnQgY2hlY2tJbWFnZVR5cGUgZnJvbSAnLi9jaGVja0ltYWdlVHlwZSc7XHJcblxyXG5leHBvcnQge1xyXG4gIGNoZWNrSW1hZ2VUeXBlXHJcbn07IiwiaW1wb3J0IHsgRUltYWdlVHlwZSB9IGZyb20gJ0Btb2RlbHMnO1xyXG5pbXBvcnQgeyBjaGVja0ltYWdlVHlwZSB9IGZyb20gJ0B1dGlscyc7XHJcblxyXG4vKipcclxuICog5bCG5LiA5LiqQ2FudmFz5a+56LGh6L2s5Y+Y5Li65LiA5LiqZGF0YVVSTOWtl+espuS4slxyXG4gKiDor6Xmlrnms5Xlj6/ku6XlgZrljovnvKnlpITnkIZcclxuICpcclxuICogQHBhcmFtIHtjYW52YXN9IGNhbnZhc1xyXG4gKiBAcGFyYW0ge251bWJlcj19IHF1YWxpdHkgLSDkvKDlhaXojIPlm7QgMC0x77yM6KGo56S65Zu+54mH5Y6L57yp6LSo6YeP77yM6buY6K6kMC45MlxyXG4gKiBAcGFyYW0ge3N0cmluZz19IHR5cGUgLSDnoa7lrprovazmjaLlkI7nmoTlm77niYfnsbvlnovvvIzpgInpobnmnIkgXCJpbWFnZS9wbmdcIiwgXCJpbWFnZS9qcGVnXCIsIFwiaW1hZ2UvZ2lmXCIs6buY6K6kXCJpbWFnZS9qcGVnXCJcclxuICogQHJldHVybnMge1Byb21pc2Uoc3RyaW5nKX0gUHJvbWlzZeWQq+acieS4gOS4qmRhdGFVUkzlrZfnrKbkuLLlj4LmlbBcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIGNhbnZhc3RvRGF0YVVSTChjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50LCBxdWFsaXR5OiBudW1iZXIgPSAwLjkyLCB0eXBlOiBFSW1hZ2VUeXBlID0gRUltYWdlVHlwZS5KUEVHKTogUHJvbWlzZTxzdHJpbmc+IHtcclxuICBpZiAoIWNoZWNrSW1hZ2VUeXBlKHR5cGUpKSB7XHJcbiAgICB0eXBlID0gRUltYWdlVHlwZS5KUEVHO1xyXG4gIH1cclxuICByZXR1cm4gY2FudmFzLnRvRGF0YVVSTCh0eXBlLCBxdWFsaXR5KTtcclxufTsiLCJpbXBvcnQgeyBFSW1hZ2VUeXBlIH0gZnJvbSAnQG1vZGVscyc7XHJcblxyXG4vKipcclxuICog5bCG5LiA5LiqY2FudmFz5a+56LGh6L2s5Y+Y5Li65LiA5LiqRmlsZe+8iEJsb2LvvInlr7nosaFcclxuICog6K+l5pa55rOV5Y+v5Lul5YGa5Y6L57yp5aSE55CGXHJcbiAqXHJcbiAqIEBwYXJhbSB7Y2FudmFzfSBjYW52YXNcclxuICogQHBhcmFtIHtudW1iZXI9fSBxdWFsaXR5IC0g5Lyg5YWl6IyD5Zu0IDAtMe+8jOihqOekuuWbvueJh+WOi+e8qei0qOmHj++8jOm7mOiupDAuOTJcclxuICogQHBhcmFtIHtzdHJpbmc9fSB0eXBlIC0g56Gu5a6a6L2s5o2i5ZCO55qE5Zu+54mH57G75Z6L77yM6YCJ6aG55pyJIFwiaW1hZ2UvcG5nXCIsIFwiaW1hZ2UvanBlZ1wiLCBcImltYWdlL2dpZlwiLOm7mOiupFwiaW1hZ2UvanBlZ1wiXHJcbiAqIEByZXR1cm5zIHtQcm9taXNlKEJsb2IpfVxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY2FudmFzdG9GaWxlKGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQsIHF1YWxpdHk6IG51bWJlciA9IDAuOTIsIHR5cGU6IEVJbWFnZVR5cGUgPSBFSW1hZ2VUeXBlLkpQRUcpOiBQcm9taXNlPEJsb2I+IHtcclxuICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiBjYW52YXMudG9CbG9iKGJsb2IgPT4gcmVzb2x2ZShibG9iKSwgdHlwZSwgcXVhbGl0eSkpO1xyXG59O1xyXG4iLCJpbXBvcnQgeyBFSW1hZ2VUeXBlIH0gZnJvbSAnQG1vZGVscyc7XHJcbmltcG9ydCB7IGNoZWNrSW1hZ2VUeXBlIH0gZnJvbSAnQHV0aWxzJztcclxuXHJcbi8qKlxyXG4gKiDlsIbkuIDkuKpkYXRhVVJM5a2X56ym5Liy6L2s5Y+Y5Li65LiA5LiqRmlsZe+8iEJsb2LvvInlr7nosaFcclxuICog6L2s5Y+Y5pe25Y+v5Lul56Gu5a6aRmlsZeWvueixoeeahOexu+Wei1xyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gZGF0YVVSTFxyXG4gKiBAcGFyYW0ge3N0cmluZz19IHR5cGUgLSDnoa7lrprovazmjaLlkI7nmoTlm77niYfnsbvlnovvvIzpgInpobnmnIkgXCJpbWFnZS9wbmdcIiwgXCJpbWFnZS9qcGVnXCIsIFwiaW1hZ2UvZ2lmXCJcclxuICogQHJldHVybnMge1Byb21pc2UoQmxvYil9XHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBkYXRhVVJMdG9GaWxlKGRhdGFVUkw6IHN0cmluZywgdHlwZTogRUltYWdlVHlwZSk6IFByb21pc2U8QmxvYj4ge1xyXG4gIGNvbnN0IGFyciA9IGRhdGFVUkwuc3BsaXQoJywnKTtcclxuICBsZXQgbWltZSA9IGFyclswXS5tYXRjaCgvOiguKj8pOy8pWzFdO1xyXG4gIGNvbnN0IGJzdHIgPSBhdG9iKGFyclsxXSk7XHJcbiAgbGV0IG4gPSBic3RyLmxlbmd0aDtcclxuICBjb25zdCB1OGFyciA9IG5ldyBVaW50OEFycmF5KG4pO1xyXG4gIHdoaWxlIChuLS0pIHtcclxuICAgIHU4YXJyW25dID0gYnN0ci5jaGFyQ29kZUF0KG4pO1xyXG4gIH1cclxuICBpZiAoY2hlY2tJbWFnZVR5cGUodHlwZSkpIHtcclxuICAgIG1pbWUgPSB0eXBlO1xyXG4gIH1cclxuICByZXR1cm4gbmV3IEJsb2IoW3U4YXJyXSwge1xyXG4gICAgdHlwZTogbWltZSxcclxuICB9KTtcclxufTsiLCIvKipcclxuICog5bCGZGF0YVVSTOWtl+espuS4sui9rOWPmOS4umltYWdl5a+56LGhXHJcbiAqXHJcbiAqIEBwYXJhbSB7c3J0aW5nfSBkYXRhVVJMIC0gZGF0YVVSTOWtl+espuS4slxyXG4gKiBAcmV0dXJucyB7UHJvbWlzZShJbWFnZSl9XHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBkYXRhVVJMdG9JbWFnZShkYXRhVVJMOiBzdHJpbmcpOiBQcm9taXNlPEhUTUxJbWFnZUVsZW1lbnQ+IHtcclxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgY29uc3QgaW1nID0gbmV3IEltYWdlKCk7XHJcbiAgICBpbWcub25sb2FkID0gKCkgPT4gcmVzb2x2ZShpbWcpO1xyXG4gICAgaW1nLm9uZXJyb3IgPSAoKSA9PiByZWplY3QobmV3IEVycm9yKCdkYXRhVVJMdG9JbWFnZSgpOiBkYXRhVVJMIGlzIGlsbGVnYWwnKSk7XHJcbiAgICBpbWcuc3JjID0gZGF0YVVSTDtcclxuICB9KTtcclxufTsiLCIvKipcclxuICog5bCG5Zu+54mH5LiL6L295Yiw5pys5ZywXHJcbiAqXHJcbiAqIEBwYXJhbSB7QmxvYn0gZmlsZSAtIOS4gOS4qkZpbGXvvIhCbG9i77yJ5a+56LGhXHJcbiAqIEBwYXJhbSB7c3RyaW5nPX0gZmlsZU5hbWUgLSDkuIvovb3lkI7nmoTmlofku7blkI3vvIjlj6/pgInlj4LmlbDvvIzkuI3kvKDku6Xml7bpl7TmiLPlkb3lkI3mlofku7bvvIlcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGRvd25sb2FkRmlsZShmaWxlOiBGaWxlLCBmaWxlTmFtZTogc3RyaW5nKTogdm9pZCB7XHJcbiAgY29uc3QgbGluayA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcclxuICBsaW5rLmhyZWYgPSB3aW5kb3cuVVJMLmNyZWF0ZU9iamVjdFVSTChmaWxlKTtcclxuICBsaW5rLmRvd25sb2FkID0gZmlsZU5hbWUgfHwgRGF0ZS5ub3coKS50b1N0cmluZygzNik7XHJcbiAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChsaW5rKTtcclxuICBjb25zdCBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnTW91c2VFdmVudHMnKTtcclxuICBldnQuaW5pdEV2ZW50KCdjbGljaycsIGZhbHNlLCBmYWxzZSk7XHJcbiAgbGluay5kaXNwYXRjaEV2ZW50KGV2dCk7XHJcbiAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChsaW5rKTtcclxufTtcclxuIiwiLyoqXHJcbiAqIOWwhkZpbGXvvIhCbG9i77yJ5a+56LGh6L2s5Y+Y5Li65LiA5LiqZGF0YVVSTOWtl+espuS4slxyXG4gKlxyXG4gKiBAcGFyYW0ge0Jsb2J9IGZpbGVcclxuICogQHJldHVybnMge1Byb21pc2Uoc3RyaW5nKX0gUHJvbWlzZeWQq+acieS4gOS4qmRhdGFVUkzlrZfnrKbkuLLlj4LmlbBcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGZpbGV0b0RhdGFVUkwoZmlsZTogQmxvYik6IFByb21pc2U8c3RyaW5nPiB7XHJcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XHJcbiAgICBjb25zdCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xyXG4gICAgcmVhZGVyLm9ubG9hZGVuZCA9IGUgPT4gcmVzb2x2ZShlLnRhcmdldC5yZXN1bHQgYXMgc3RyaW5nKTtcclxuICAgIHJlYWRlci5yZWFkQXNEYXRhVVJMKGZpbGUpO1xyXG4gIH0pO1xyXG59O1xyXG4iLCJleHBvcnQgZnVuY3Rpb24gTmV1UXVhbnQoKSB7XHJcbiAgICB2YXIgbmV0c2l6ZSA9IDI1NjsgLy8gbnVtYmVyIG9mIGNvbG91cnMgdXNlZFxyXG4gIFxyXG4gICAgLy8gZm91ciBwcmltZXMgbmVhciA1MDAgLSBhc3N1bWUgbm8gaW1hZ2UgaGFzIGEgbGVuZ3RoIHNvIGxhcmdlXHJcbiAgICAvLyB0aGF0IGl0IGlzIGRpdmlzaWJsZSBieSBhbGwgZm91ciBwcmltZXNcclxuICAgIHZhciBwcmltZTEgPSA0OTk7XHJcbiAgICB2YXIgcHJpbWUyID0gNDkxO1xyXG4gICAgdmFyIHByaW1lMyA9IDQ4NztcclxuICAgIHZhciBwcmltZTQgPSA1MDM7XHJcbiAgXHJcbiAgICAvLyBtaW5pbXVtIHNpemUgZm9yIGlucHV0IGltYWdlXHJcbiAgICB2YXIgbWlucGljdHVyZWJ5dGVzID0gMyAqIHByaW1lNDtcclxuICBcclxuICAgIC8vIE5ldHdvcmsgRGVmaW5pdGlvbnNcclxuICBcclxuICAgIHZhciBtYXhuZXRwb3MgPSBuZXRzaXplIC0gMTtcclxuICAgIHZhciBuZXRiaWFzc2hpZnQgPSA0OyAvLyBiaWFzIGZvciBjb2xvdXIgdmFsdWVzXHJcbiAgICB2YXIgbmN5Y2xlcyA9IDEwMDsgLy8gbm8uIG9mIGxlYXJuaW5nIGN5Y2xlc1xyXG4gIFxyXG4gICAgLy8gZGVmcyBmb3IgZnJlcSBhbmQgYmlhc1xyXG4gICAgdmFyIGludGJpYXNzaGlmdCA9IDE2OyAvLyBiaWFzIGZvciBmcmFjdGlvbnNcclxuICAgIHZhciBpbnRiaWFzID0gMSA8PCBpbnRiaWFzc2hpZnQ7XHJcbiAgICB2YXIgZ2FtbWFzaGlmdCA9IDEwOyAvLyBnYW1tYSA9IDEwMjRcclxuICAgIHZhciBnYW1tYSA9IDEgPDwgZ2FtbWFzaGlmdDtcclxuICAgIHZhciBiZXRhc2hpZnQgPSAxMDtcclxuICAgIHZhciBiZXRhID0gaW50YmlhcyA+PiBiZXRhc2hpZnQ7IC8vIGJldGEgPSAxLzEwMjRcclxuICAgIHZhciBiZXRhZ2FtbWEgPSBpbnRiaWFzIDw8IGdhbW1hc2hpZnQgLSBiZXRhc2hpZnQ7XHJcbiAgXHJcbiAgICAvLyBkZWZzIGZvciBkZWNyZWFzaW5nIHJhZGl1cyBmYWN0b3JcclxuICAgIC8vIEZvciAyNTYgY29sb3JzLCByYWRpdXMgc3RhcnRzIGF0IDMyLjAgYmlhc2VkIGJ5IDYgYml0c1xyXG4gICAgLy8gYW5kIGRlY3JlYXNlcyBieSBhIGZhY3RvciBvZiAxLzMwIGVhY2ggY3ljbGVcclxuICAgIHZhciBpbml0cmFkID0gbmV0c2l6ZSA+PiAzO1xyXG4gICAgdmFyIHJhZGl1c2JpYXNzaGlmdCA9IDY7XHJcbiAgICB2YXIgcmFkaXVzYmlhcyA9IDEgPDwgcmFkaXVzYmlhc3NoaWZ0O1xyXG4gICAgdmFyIGluaXRyYWRpdXMgPSBpbml0cmFkICogcmFkaXVzYmlhcztcclxuICAgIHZhciByYWRpdXNkZWMgPSAzMDtcclxuICBcclxuICAgIC8vIGRlZnMgZm9yIGRlY3JlYXNpbmcgYWxwaGEgZmFjdG9yXHJcbiAgICAvLyBBbHBoYSBzdGFydHMgYXQgMS4wIGJpYXNlZCBieSAxMCBiaXRzXHJcbiAgICB2YXIgYWxwaGFiaWFzc2hpZnQgPSAxMDtcclxuICAgIHZhciBpbml0YWxwaGEgPSAxIDw8IGFscGhhYmlhc3NoaWZ0O1xyXG4gICAgdmFyIGFscGhhZGVjO1xyXG4gIFxyXG4gICAgLy8gcmFkYmlhcyBhbmQgYWxwaGFyYWRiaWFzIHVzZWQgZm9yIHJhZHBvd2VyIGNhbGN1bGF0aW9uXHJcbiAgICB2YXIgcmFkYmlhc3NoaWZ0ID0gODtcclxuICAgIHZhciByYWRiaWFzID0gMSA8PCByYWRiaWFzc2hpZnQ7XHJcbiAgICB2YXIgYWxwaGFyYWRic2hpZnQgPSBhbHBoYWJpYXNzaGlmdCArIHJhZGJpYXNzaGlmdDtcclxuICAgIHZhciBhbHBoYXJhZGJpYXMgPSAxIDw8IGFscGhhcmFkYnNoaWZ0O1xyXG4gIFxyXG4gICAgLy8gSW5wdXQgaW1hZ2VcclxuICAgIHZhciB0aGVwaWN0dXJlO1xyXG4gICAgLy8gSGVpZ2h0ICogV2lkdGggKiAzXHJcbiAgICB2YXIgbGVuZ3RoY291bnQ7XHJcbiAgICAvLyBTYW1wbGluZyBmYWN0b3IgMS4uMzBcclxuICAgIHZhciBzYW1wbGVmYWM7XHJcbiAgXHJcbiAgICAvLyBUaGUgbmV0d29yayBpdHNlbGZcclxuICAgIHZhciBuZXR3b3JrO1xyXG4gICAgdmFyIG5ldGluZGV4ID0gW107XHJcbiAgXHJcbiAgICAvLyBmb3IgbmV0d29yayBsb29rdXAgLSByZWFsbHkgMjU2XHJcbiAgICB2YXIgYmlhcyA9IFtdO1xyXG4gIFxyXG4gICAgLy8gYmlhcyBhbmQgZnJlcSBhcnJheXMgZm9yIGxlYXJuaW5nXHJcbiAgICB2YXIgZnJlcSA9IFtdO1xyXG4gICAgdmFyIHJhZHBvd2VyID0gW107XHJcbiAgXHJcbiAgICBmdW5jdGlvbiBOZXVRdWFudENvbnN0cnVjdG9yKHRoZXBpYywgbGVuLCBzYW1wbGUpIHtcclxuICBcclxuICAgICAgdmFyIGk7XHJcbiAgICAgIHZhciBwO1xyXG4gIFxyXG4gICAgICB0aGVwaWN0dXJlID0gdGhlcGljO1xyXG4gICAgICBsZW5ndGhjb3VudCA9IGxlbjtcclxuICAgICAgc2FtcGxlZmFjID0gc2FtcGxlO1xyXG4gIFxyXG4gICAgICBuZXR3b3JrID0gbmV3IEFycmF5KG5ldHNpemUpO1xyXG4gIFxyXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbmV0c2l6ZTsgaSsrKSB7XHJcbiAgICAgICAgbmV0d29ya1tpXSA9IG5ldyBBcnJheSg0KTtcclxuICAgICAgICBwID0gbmV0d29ya1tpXTtcclxuICAgICAgICBwWzBdID0gcFsxXSA9IHBbMl0gPSAoaSA8PCBuZXRiaWFzc2hpZnQgKyA4KSAvIG5ldHNpemUgfCAwO1xyXG4gICAgICAgIGZyZXFbaV0gPSBpbnRiaWFzIC8gbmV0c2l6ZSB8IDA7IC8vIDEgLyBuZXRzaXplXHJcbiAgICAgICAgYmlhc1tpXSA9IDA7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICBcclxuICAgIGZ1bmN0aW9uIGNvbG9yTWFwKCkge1xyXG4gICAgICB2YXIgbWFwID0gW107XHJcbiAgICAgIHZhciBpbmRleCA9IG5ldyBBcnJheShuZXRzaXplKTtcclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXRzaXplOyBpKyspIHtcclxuICAgICAgICBpbmRleFtuZXR3b3JrW2ldWzNdXSA9IGk7XHJcbiAgICAgIH12YXIgayA9IDA7XHJcbiAgICAgIGZvciAodmFyIGwgPSAwOyBsIDwgbmV0c2l6ZTsgbCsrKSB7XHJcbiAgICAgICAgdmFyIGogPSBpbmRleFtsXTtcclxuICAgICAgICBtYXBbaysrXSA9IG5ldHdvcmtbal1bMF07XHJcbiAgICAgICAgbWFwW2srK10gPSBuZXR3b3JrW2pdWzFdO1xyXG4gICAgICAgIG1hcFtrKytdID0gbmV0d29ya1tqXVsyXTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gbWFwO1xyXG4gICAgfVxyXG4gIFxyXG4gICAgLy8gSW5zZXJ0aW9uIHNvcnQgb2YgbmV0d29yayBhbmQgYnVpbGRpbmcgb2YgbmV0aW5kZXhbMC4uMjU1XVxyXG4gICAgLy8gKHRvIGRvIGFmdGVyIHVuYmlhcylcclxuICAgIGZ1bmN0aW9uIGlueGJ1aWxkKCkge1xyXG4gICAgICB2YXIgaTtcclxuICAgICAgdmFyIGo7XHJcbiAgICAgIHZhciBzbWFsbHBvcztcclxuICAgICAgdmFyIHNtYWxsdmFsO1xyXG4gICAgICB2YXIgcDtcclxuICAgICAgdmFyIHE7XHJcbiAgICAgIHZhciBwcmV2aW91c2NvbDtcclxuICAgICAgdmFyIHN0YXJ0cG9zO1xyXG4gIFxyXG4gICAgICBwcmV2aW91c2NvbCA9IDA7XHJcbiAgICAgIHN0YXJ0cG9zID0gMDtcclxuICBcclxuICAgICAgZm9yIChpID0gMDsgaSA8IG5ldHNpemU7IGkrKykge1xyXG4gIFxyXG4gICAgICAgIHAgPSBuZXR3b3JrW2ldO1xyXG4gICAgICAgIHNtYWxscG9zID0gaTtcclxuICAgICAgICBzbWFsbHZhbCA9IHBbMV07IC8vIGluZGV4IG9uIGdcclxuICAgICAgICAvLyBmaW5kIHNtYWxsZXN0IGluIGkuLm5ldHNpemUtMVxyXG4gICAgICAgIGZvciAoaiA9IGkgKyAxOyBqIDwgbmV0c2l6ZTsgaisrKSB7XHJcbiAgXHJcbiAgICAgICAgICBxID0gbmV0d29ya1tqXTtcclxuICBcclxuICAgICAgICAgIGlmIChxWzFdIDwgc21hbGx2YWwpIHtcclxuICAgICAgICAgICAgLy8gaW5kZXggb24gZ1xyXG4gICAgICAgICAgICBzbWFsbHBvcyA9IGo7XHJcbiAgICAgICAgICAgIHNtYWxsdmFsID0gcVsxXTsgLy8gaW5kZXggb24gZ1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICBcclxuICAgICAgICBxID0gbmV0d29ya1tzbWFsbHBvc107XHJcbiAgXHJcbiAgICAgICAgLy8gc3dhcCBwIChpKSBhbmQgcSAoc21hbGxwb3MpIGVudHJpZXNcclxuICAgICAgICBpZiAoaSAhPSBzbWFsbHBvcykge1xyXG4gICAgICAgICAgaiA9IHFbMF07XHJcbiAgICAgICAgICBxWzBdID0gcFswXTtcclxuICAgICAgICAgIHBbMF0gPSBqO1xyXG4gICAgICAgICAgaiA9IHFbMV07XHJcbiAgICAgICAgICBxWzFdID0gcFsxXTtcclxuICAgICAgICAgIHBbMV0gPSBqO1xyXG4gICAgICAgICAgaiA9IHFbMl07XHJcbiAgICAgICAgICBxWzJdID0gcFsyXTtcclxuICAgICAgICAgIHBbMl0gPSBqO1xyXG4gICAgICAgICAgaiA9IHFbM107XHJcbiAgICAgICAgICBxWzNdID0gcFszXTtcclxuICAgICAgICAgIHBbM10gPSBqO1xyXG4gICAgICAgIH1cclxuICBcclxuICAgICAgICAvLyBzbWFsbHZhbCBlbnRyeSBpcyBub3cgaW4gcG9zaXRpb24gaVxyXG4gICAgICAgIGlmIChzbWFsbHZhbCAhPSBwcmV2aW91c2NvbCkge1xyXG4gIFxyXG4gICAgICAgICAgbmV0aW5kZXhbcHJldmlvdXNjb2xdID0gc3RhcnRwb3MgKyBpID4+IDE7XHJcbiAgXHJcbiAgICAgICAgICBmb3IgKGogPSBwcmV2aW91c2NvbCArIDE7IGogPCBzbWFsbHZhbDsgaisrKSB7XHJcbiAgICAgICAgICAgIG5ldGluZGV4W2pdID0gaTtcclxuICAgICAgICAgIH1cclxuICBcclxuICAgICAgICAgIHByZXZpb3VzY29sID0gc21hbGx2YWw7XHJcbiAgICAgICAgICBzdGFydHBvcyA9IGk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgXHJcbiAgICAgIG5ldGluZGV4W3ByZXZpb3VzY29sXSA9IHN0YXJ0cG9zICsgbWF4bmV0cG9zID4+IDE7XHJcbiAgICAgIGZvciAoaiA9IHByZXZpb3VzY29sICsgMTsgaiA8IDI1NjsgaisrKSB7XHJcbiAgICAgICAgbmV0aW5kZXhbal0gPSBtYXhuZXRwb3M7IC8vIHJlYWxseSAyNTZcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIFxyXG4gICAgLy8gTWFpbiBMZWFybmluZyBMb29wXHJcbiAgXHJcbiAgICBmdW5jdGlvbiBsZWFybigpIHtcclxuICAgICAgdmFyIGk7XHJcbiAgICAgIHZhciBqO1xyXG4gICAgICB2YXIgYjtcclxuICAgICAgdmFyIGc7XHJcbiAgICAgIHZhciByO1xyXG4gICAgICB2YXIgcmFkaXVzO1xyXG4gICAgICB2YXIgcmFkO1xyXG4gICAgICB2YXIgYWxwaGE7XHJcbiAgICAgIHZhciBzdGVwO1xyXG4gICAgICB2YXIgZGVsdGE7XHJcbiAgICAgIHZhciBzYW1wbGVwaXhlbHM7XHJcbiAgICAgIHZhciBwO1xyXG4gICAgICB2YXIgcGl4O1xyXG4gICAgICB2YXIgbGltO1xyXG4gIFxyXG4gICAgICBpZiAobGVuZ3RoY291bnQgPCBtaW5waWN0dXJlYnl0ZXMpIHtcclxuICAgICAgICBzYW1wbGVmYWMgPSAxO1xyXG4gICAgICB9XHJcbiAgXHJcbiAgICAgIGFscGhhZGVjID0gMzAgKyAoc2FtcGxlZmFjIC0gMSkgLyAzO1xyXG4gICAgICBwID0gdGhlcGljdHVyZTtcclxuICAgICAgcGl4ID0gMDtcclxuICAgICAgbGltID0gbGVuZ3RoY291bnQ7XHJcbiAgICAgIHNhbXBsZXBpeGVscyA9IGxlbmd0aGNvdW50IC8gKDMgKiBzYW1wbGVmYWMpO1xyXG4gICAgICBkZWx0YSA9IHNhbXBsZXBpeGVscyAvIG5jeWNsZXMgfCAwO1xyXG4gICAgICBhbHBoYSA9IGluaXRhbHBoYTtcclxuICAgICAgcmFkaXVzID0gaW5pdHJhZGl1cztcclxuICBcclxuICAgICAgcmFkID0gcmFkaXVzID4+IHJhZGl1c2JpYXNzaGlmdDtcclxuICAgICAgaWYgKHJhZCA8PSAxKSB7XHJcbiAgICAgICAgcmFkID0gMDtcclxuICAgICAgfVxyXG4gIFxyXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgcmFkOyBpKyspIHtcclxuICAgICAgICByYWRwb3dlcltpXSA9IGFscGhhICogKChyYWQgKiByYWQgLSBpICogaSkgKiByYWRiaWFzIC8gKHJhZCAqIHJhZCkpO1xyXG4gICAgICB9XHJcbiAgXHJcbiAgICAgIGlmIChsZW5ndGhjb3VudCA8IG1pbnBpY3R1cmVieXRlcykge1xyXG4gICAgICAgIHN0ZXAgPSAzO1xyXG4gICAgICB9IGVsc2UgaWYgKGxlbmd0aGNvdW50ICUgcHJpbWUxICE9PSAwKSB7XHJcbiAgICAgICAgc3RlcCA9IDMgKiBwcmltZTE7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgXHJcbiAgICAgICAgaWYgKGxlbmd0aGNvdW50ICUgcHJpbWUyICE9PSAwKSB7XHJcbiAgICAgICAgICBzdGVwID0gMyAqIHByaW1lMjtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgaWYgKGxlbmd0aGNvdW50ICUgcHJpbWUzICE9PSAwKSB7XHJcbiAgICAgICAgICAgIHN0ZXAgPSAzICogcHJpbWUzO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgc3RlcCA9IDMgKiBwcmltZTQ7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgXHJcbiAgICAgIGkgPSAwO1xyXG4gIFxyXG4gICAgICB3aGlsZSAoaSA8IHNhbXBsZXBpeGVscykge1xyXG4gIFxyXG4gICAgICAgIGIgPSAocFtwaXggKyAwXSAmIDB4ZmYpIDw8IG5ldGJpYXNzaGlmdDtcclxuICAgICAgICBnID0gKHBbcGl4ICsgMV0gJiAweGZmKSA8PCBuZXRiaWFzc2hpZnQ7XHJcbiAgICAgICAgciA9IChwW3BpeCArIDJdICYgMHhmZikgPDwgbmV0Ymlhc3NoaWZ0O1xyXG4gICAgICAgIGogPSBjb250ZXN0KGIsIGcsIHIpO1xyXG4gIFxyXG4gICAgICAgIGFsdGVyc2luZ2xlKGFscGhhLCBqLCBiLCBnLCByKTtcclxuICBcclxuICAgICAgICBpZiAocmFkICE9PSAwKSB7XHJcbiAgICAgICAgICAvLyBBbHRlciBuZWlnaGJvdXJzXHJcbiAgICAgICAgICBhbHRlcm5laWdoKHJhZCwgaiwgYiwgZywgcik7XHJcbiAgICAgICAgfVxyXG4gIFxyXG4gICAgICAgIHBpeCArPSBzdGVwO1xyXG4gIFxyXG4gICAgICAgIGlmIChwaXggPj0gbGltKSB7XHJcbiAgICAgICAgICBwaXggLT0gbGVuZ3RoY291bnQ7XHJcbiAgICAgICAgfVxyXG4gIFxyXG4gICAgICAgIGkrKztcclxuICBcclxuICAgICAgICBpZiAoZGVsdGEgPT09IDApIHtcclxuICAgICAgICAgIGRlbHRhID0gMTtcclxuICAgICAgICB9XHJcbiAgXHJcbiAgICAgICAgaWYgKGkgJSBkZWx0YSA9PT0gMCkge1xyXG4gICAgICAgICAgYWxwaGEgLT0gYWxwaGEgLyBhbHBoYWRlYztcclxuICAgICAgICAgIHJhZGl1cyAtPSByYWRpdXMgLyByYWRpdXNkZWM7XHJcbiAgICAgICAgICByYWQgPSByYWRpdXMgPj4gcmFkaXVzYmlhc3NoaWZ0O1xyXG4gIFxyXG4gICAgICAgICAgaWYgKHJhZCA8PSAxKSB7XHJcbiAgICAgICAgICAgIHJhZCA9IDA7XHJcbiAgICAgICAgICB9XHJcbiAgXHJcbiAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgcmFkOyBqKyspIHtcclxuICAgICAgICAgICAgcmFkcG93ZXJbal0gPSBhbHBoYSAqICgocmFkICogcmFkIC0gaiAqIGopICogcmFkYmlhcyAvIChyYWQgKiByYWQpKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICBcclxuICAgIC8vIFNlYXJjaCBmb3IgQkdSIHZhbHVlcyAwLi4yNTUgKGFmdGVyIG5ldCBpcyB1bmJpYXNlZCkgYW5kIHJldHVybiBjb2xvdXIgaW5kZXhcclxuICAgIGZ1bmN0aW9uIG1hcChiLCBnLCByKSB7XHJcbiAgICAgIHZhciBpO1xyXG4gICAgICB2YXIgajtcclxuICAgICAgdmFyIGRpc3Q7XHJcbiAgICAgIHZhciBhO1xyXG4gICAgICB2YXIgYmVzdGQ7XHJcbiAgICAgIHZhciBwO1xyXG4gICAgICB2YXIgYmVzdDtcclxuICBcclxuICAgICAgLy8gQmlnZ2VzdCBwb3NzaWJsZSBkaXN0YW5jZSBpcyAyNTYgKiAzXHJcbiAgICAgIGJlc3RkID0gMTAwMDtcclxuICAgICAgYmVzdCA9IC0xO1xyXG4gICAgICBpID0gbmV0aW5kZXhbZ107IC8vIGluZGV4IG9uIGdcclxuICAgICAgaiA9IGkgLSAxOyAvLyBzdGFydCBhdCBuZXRpbmRleFtnXSBhbmQgd29yayBvdXR3YXJkc1xyXG4gIFxyXG4gICAgICB3aGlsZSAoaSA8IG5ldHNpemUgfHwgaiA+PSAwKSB7XHJcbiAgXHJcbiAgICAgICAgaWYgKGkgPCBuZXRzaXplKSB7XHJcbiAgXHJcbiAgICAgICAgICBwID0gbmV0d29ya1tpXTtcclxuICBcclxuICAgICAgICAgIGRpc3QgPSBwWzFdIC0gZzsgLy8gaW54IGtleVxyXG4gIFxyXG4gICAgICAgICAgaWYgKGRpc3QgPj0gYmVzdGQpIHtcclxuICAgICAgICAgICAgaSA9IG5ldHNpemU7IC8vIHN0b3AgaXRlclxyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICBcclxuICAgICAgICAgICAgaSsrO1xyXG4gIFxyXG4gICAgICAgICAgICBpZiAoZGlzdCA8IDApIHtcclxuICAgICAgICAgICAgICBkaXN0ID0gLWRpc3Q7XHJcbiAgICAgICAgICAgIH1cclxuICBcclxuICAgICAgICAgICAgYSA9IHBbMF0gLSBiO1xyXG4gIFxyXG4gICAgICAgICAgICBpZiAoYSA8IDApIHtcclxuICAgICAgICAgICAgICBhID0gLWE7XHJcbiAgICAgICAgICAgIH1cclxuICBcclxuICAgICAgICAgICAgZGlzdCArPSBhO1xyXG4gIFxyXG4gICAgICAgICAgICBpZiAoZGlzdCA8IGJlc3RkKSB7XHJcbiAgICAgICAgICAgICAgYSA9IHBbMl0gLSByO1xyXG4gIFxyXG4gICAgICAgICAgICAgIGlmIChhIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgYSA9IC1hO1xyXG4gICAgICAgICAgICAgIH1cclxuICBcclxuICAgICAgICAgICAgICBkaXN0ICs9IGE7XHJcbiAgXHJcbiAgICAgICAgICAgICAgaWYgKGRpc3QgPCBiZXN0ZCkge1xyXG4gICAgICAgICAgICAgICAgYmVzdGQgPSBkaXN0O1xyXG4gICAgICAgICAgICAgICAgYmVzdCA9IHBbM107XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gIFxyXG4gICAgICAgIGlmIChqID49IDApIHtcclxuICBcclxuICAgICAgICAgIHAgPSBuZXR3b3JrW2pdO1xyXG4gIFxyXG4gICAgICAgICAgZGlzdCA9IGcgLSBwWzFdOyAvLyBpbngga2V5IC0gcmV2ZXJzZSBkaWZcclxuICBcclxuICAgICAgICAgIGlmIChkaXN0ID49IGJlc3RkKSB7XHJcbiAgICAgICAgICAgIGogPSAtMTsgLy8gc3RvcCBpdGVyXHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gIFxyXG4gICAgICAgICAgICBqLS07XHJcbiAgICAgICAgICAgIGlmIChkaXN0IDwgMCkge1xyXG4gICAgICAgICAgICAgIGRpc3QgPSAtZGlzdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBhID0gcFswXSAtIGI7XHJcbiAgICAgICAgICAgIGlmIChhIDwgMCkge1xyXG4gICAgICAgICAgICAgIGEgPSAtYTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBkaXN0ICs9IGE7XHJcbiAgXHJcbiAgICAgICAgICAgIGlmIChkaXN0IDwgYmVzdGQpIHtcclxuICAgICAgICAgICAgICBhID0gcFsyXSAtIHI7XHJcbiAgICAgICAgICAgICAgaWYgKGEgPCAwKSB7XHJcbiAgICAgICAgICAgICAgICBhID0gLWE7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIGRpc3QgKz0gYTtcclxuICAgICAgICAgICAgICBpZiAoZGlzdCA8IGJlc3RkKSB7XHJcbiAgICAgICAgICAgICAgICBiZXN0ZCA9IGRpc3Q7XHJcbiAgICAgICAgICAgICAgICBiZXN0ID0gcFszXTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICBcclxuICAgICAgcmV0dXJuIGJlc3Q7XHJcbiAgICB9XHJcbiAgXHJcbiAgICBmdW5jdGlvbiBwcm9jZXNzKCkge1xyXG4gICAgICBsZWFybigpO1xyXG4gICAgICB1bmJpYXNuZXQoKTtcclxuICAgICAgaW54YnVpbGQoKTtcclxuICAgICAgcmV0dXJuIGNvbG9yTWFwKCk7XHJcbiAgICB9XHJcbiAgXHJcbiAgICAvLyBVbmJpYXMgbmV0d29yayB0byBnaXZlIGJ5dGUgdmFsdWVzIDAuLjI1NSBhbmQgcmVjb3JkIHBvc2l0aW9uIGlcclxuICAgIC8vIHRvIHByZXBhcmUgZm9yIHNvcnRcclxuICAgIGZ1bmN0aW9uIHVuYmlhc25ldCgpIHtcclxuICAgICAgdmFyIGk7XHJcbiAgICAgIHZhciBqO1xyXG4gIFxyXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbmV0c2l6ZTsgaSsrKSB7XHJcbiAgICAgICAgbmV0d29ya1tpXVswXSA+Pj0gbmV0Ymlhc3NoaWZ0O1xyXG4gICAgICAgIG5ldHdvcmtbaV1bMV0gPj49IG5ldGJpYXNzaGlmdDtcclxuICAgICAgICBuZXR3b3JrW2ldWzJdID4+PSBuZXRiaWFzc2hpZnQ7XHJcbiAgICAgICAgbmV0d29ya1tpXVszXSA9IGk7IC8vIHJlY29yZCBjb2xvdXIgbm9cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIFxyXG4gICAgLy8gTW92ZSBhZGphY2VudCBuZXVyb25zIGJ5IHByZWNvbXB1dGVkIGFscGhhKigxLSgoaS1qKV4yL1tyXV4yKSlcclxuICAgIC8vIGluIHJhZHBvd2VyW3xpLWp8XVxyXG4gICAgZnVuY3Rpb24gYWx0ZXJuZWlnaChyYWQsIGksIGIsIGcsIHIpIHtcclxuICBcclxuICAgICAgdmFyIGo7XHJcbiAgICAgIHZhciBrO1xyXG4gICAgICB2YXIgbG87XHJcbiAgICAgIHZhciBoaTtcclxuICAgICAgdmFyIGE7XHJcbiAgICAgIHZhciBtO1xyXG4gIFxyXG4gICAgICB2YXIgcDtcclxuICBcclxuICAgICAgbG8gPSBpIC0gcmFkO1xyXG4gICAgICBpZiAobG8gPCAtMSkge1xyXG4gICAgICAgIGxvID0gLTE7XHJcbiAgICAgIH1cclxuICBcclxuICAgICAgaGkgPSBpICsgcmFkO1xyXG4gIFxyXG4gICAgICBpZiAoaGkgPiBuZXRzaXplKSB7XHJcbiAgICAgICAgaGkgPSBuZXRzaXplO1xyXG4gICAgICB9XHJcbiAgXHJcbiAgICAgIGogPSBpICsgMTtcclxuICAgICAgayA9IGkgLSAxO1xyXG4gICAgICBtID0gMTtcclxuICBcclxuICAgICAgd2hpbGUgKGogPCBoaSB8fCBrID4gbG8pIHtcclxuICBcclxuICAgICAgICBhID0gcmFkcG93ZXJbbSsrXTtcclxuICBcclxuICAgICAgICBpZiAoaiA8IGhpKSB7XHJcbiAgXHJcbiAgICAgICAgICBwID0gbmV0d29ya1tqKytdO1xyXG4gIFxyXG4gICAgICAgICAgdHJ5IHtcclxuICBcclxuICAgICAgICAgICAgcFswXSAtPSBhICogKHBbMF0gLSBiKSAvIGFscGhhcmFkYmlhcyB8IDA7XHJcbiAgICAgICAgICAgIHBbMV0gLT0gYSAqIChwWzFdIC0gZykgLyBhbHBoYXJhZGJpYXMgfCAwO1xyXG4gICAgICAgICAgICBwWzJdIC09IGEgKiAocFsyXSAtIHIpIC8gYWxwaGFyYWRiaWFzIHwgMDtcclxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XHJcbiAgICAgICAgfVxyXG4gIFxyXG4gICAgICAgIGlmIChrID4gbG8pIHtcclxuICBcclxuICAgICAgICAgIHAgPSBuZXR3b3JrW2stLV07XHJcbiAgXHJcbiAgICAgICAgICB0cnkge1xyXG4gIFxyXG4gICAgICAgICAgICBwWzBdIC09IGEgKiAocFswXSAtIGIpIC8gYWxwaGFyYWRiaWFzIHwgMDtcclxuICAgICAgICAgICAgcFsxXSAtPSBhICogKHBbMV0gLSBnKSAvIGFscGhhcmFkYmlhcyB8IDA7XHJcbiAgICAgICAgICAgIHBbMl0gLT0gYSAqIChwWzJdIC0gcikgLyBhbHBoYXJhZGJpYXMgfCAwO1xyXG4gICAgICAgICAgfSBjYXRjaCAoZSkge31cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICBcclxuICAgIC8vIE1vdmUgbmV1cm9uIGkgdG93YXJkcyBiaWFzZWQgKGIsZyxyKSBieSBmYWN0b3IgYWxwaGFcclxuICAgIGZ1bmN0aW9uIGFsdGVyc2luZ2xlKGFscGhhLCBpLCBiLCBnLCByKSB7XHJcbiAgXHJcbiAgICAgIC8vIGFsdGVyIGhpdCBuZXVyb25cclxuICAgICAgdmFyIG4gPSBuZXR3b3JrW2ldO1xyXG4gICAgICB2YXIgYWxwaGFNdWx0ID0gYWxwaGEgLyBpbml0YWxwaGE7XHJcbiAgICAgIG5bMF0gLT0gYWxwaGFNdWx0ICogKG5bMF0gLSBiKSB8IDA7XHJcbiAgICAgIG5bMV0gLT0gYWxwaGFNdWx0ICogKG5bMV0gLSBnKSB8IDA7XHJcbiAgICAgIG5bMl0gLT0gYWxwaGFNdWx0ICogKG5bMl0gLSByKSB8IDA7XHJcbiAgICB9XHJcbiAgXHJcbiAgICAvLyBTZWFyY2ggZm9yIGJpYXNlZCBCR1IgdmFsdWVzXHJcbiAgICBmdW5jdGlvbiBjb250ZXN0KGIsIGcsIHIpIHtcclxuICBcclxuICAgICAgLy8gZmluZHMgY2xvc2VzdCBuZXVyb24gKG1pbiBkaXN0KSBhbmQgdXBkYXRlcyBmcmVxXHJcbiAgICAgIC8vIGZpbmRzIGJlc3QgbmV1cm9uIChtaW4gZGlzdC1iaWFzKSBhbmQgcmV0dXJucyBwb3NpdGlvblxyXG4gICAgICAvLyBmb3IgZnJlcXVlbnRseSBjaG9zZW4gbmV1cm9ucywgZnJlcVtpXSBpcyBoaWdoIGFuZCBiaWFzW2ldIGlzIG5lZ2F0aXZlXHJcbiAgICAgIC8vIGJpYXNbaV0gPSBnYW1tYSooKDEvbmV0c2l6ZSktZnJlcVtpXSlcclxuICBcclxuICAgICAgdmFyIGk7XHJcbiAgICAgIHZhciBkaXN0O1xyXG4gICAgICB2YXIgYTtcclxuICAgICAgdmFyIGJpYXNkaXN0O1xyXG4gICAgICB2YXIgYmV0YWZyZXE7XHJcbiAgICAgIHZhciBiZXN0cG9zO1xyXG4gICAgICB2YXIgYmVzdGJpYXNwb3M7XHJcbiAgICAgIHZhciBiZXN0ZDtcclxuICAgICAgdmFyIGJlc3RiaWFzZDtcclxuICAgICAgdmFyIG47XHJcbiAgXHJcbiAgICAgIGJlc3RkID0gfigxIDw8IDMxKTtcclxuICAgICAgYmVzdGJpYXNkID0gYmVzdGQ7XHJcbiAgICAgIGJlc3Rwb3MgPSAtMTtcclxuICAgICAgYmVzdGJpYXNwb3MgPSBiZXN0cG9zO1xyXG4gIFxyXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbmV0c2l6ZTsgaSsrKSB7XHJcbiAgXHJcbiAgICAgICAgbiA9IG5ldHdvcmtbaV07XHJcbiAgICAgICAgZGlzdCA9IG5bMF0gLSBiO1xyXG4gIFxyXG4gICAgICAgIGlmIChkaXN0IDwgMCkge1xyXG4gICAgICAgICAgZGlzdCA9IC1kaXN0O1xyXG4gICAgICAgIH1cclxuICBcclxuICAgICAgICBhID0gblsxXSAtIGc7XHJcbiAgXHJcbiAgICAgICAgaWYgKGEgPCAwKSB7XHJcbiAgICAgICAgICBhID0gLWE7XHJcbiAgICAgICAgfVxyXG4gIFxyXG4gICAgICAgIGRpc3QgKz0gYTtcclxuICBcclxuICAgICAgICBhID0gblsyXSAtIHI7XHJcbiAgXHJcbiAgICAgICAgaWYgKGEgPCAwKSB7XHJcbiAgICAgICAgICBhID0gLWE7XHJcbiAgICAgICAgfVxyXG4gIFxyXG4gICAgICAgIGRpc3QgKz0gYTtcclxuICBcclxuICAgICAgICBpZiAoZGlzdCA8IGJlc3RkKSB7XHJcbiAgICAgICAgICBiZXN0ZCA9IGRpc3Q7XHJcbiAgICAgICAgICBiZXN0cG9zID0gaTtcclxuICAgICAgICB9XHJcbiAgXHJcbiAgICAgICAgYmlhc2Rpc3QgPSBkaXN0IC0gKGJpYXNbaV0gPj4gaW50Ymlhc3NoaWZ0IC0gbmV0Ymlhc3NoaWZ0KTtcclxuICBcclxuICAgICAgICBpZiAoYmlhc2Rpc3QgPCBiZXN0Ymlhc2QpIHtcclxuICAgICAgICAgIGJlc3RiaWFzZCA9IGJpYXNkaXN0O1xyXG4gICAgICAgICAgYmVzdGJpYXNwb3MgPSBpO1xyXG4gICAgICAgIH1cclxuICBcclxuICAgICAgICBiZXRhZnJlcSA9IGZyZXFbaV0gPj4gYmV0YXNoaWZ0O1xyXG4gICAgICAgIGZyZXFbaV0gLT0gYmV0YWZyZXE7XHJcbiAgICAgICAgYmlhc1tpXSArPSBiZXRhZnJlcSA8PCBnYW1tYXNoaWZ0O1xyXG4gICAgICB9XHJcbiAgXHJcbiAgICAgIGZyZXFbYmVzdHBvc10gKz0gYmV0YTtcclxuICAgICAgYmlhc1tiZXN0cG9zXSAtPSBiZXRhZ2FtbWE7XHJcbiAgICAgIHJldHVybiBiZXN0Ymlhc3BvcztcclxuICAgIH1cclxuICBcclxuICAgIE5ldVF1YW50Q29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuXHJcbiAgICBsZXQgZXhwb3J0cyA9IHt9O1xyXG4gICAgZXhwb3J0cy5tYXAgPSBtYXA7XHJcbiAgICBleHBvcnRzLnByb2Nlc3MgPSBwcm9jZXNzO1xyXG5cclxuICAgIHJldHVybiBleHBvcnRzO1xyXG4gIH0iLCIvKipcclxuICog5bCGRmlsZe+8iEJsb2LvvInlr7nosaHovazlj5jkuLrkuIDkuKpkYXRhVVJM5a2X56ym5LiyXHJcbiAqXHJcbiAqIEBwYXJhbSB7SW1hZ2VEYXRhfSBkYXRhXHJcbiAqIEByZXR1cm5zIHtudW1iZXJbXV19IFtdXHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpbWFnZURhdGFUb1JHQihkYXRhOiBbXSwgd2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIpOiBudW1iZXJbXSB7XHJcbiAgbGV0IGxlbmd0aCA9IHdpZHRoICogaGVpZ2h0ICogNDtcclxuICBsZXQgaSA9IDA7XHJcbiAgbGV0IHJnYjogbnVtYmVyW10gPSBbXTtcclxuXHJcbiAgd2hpbGUgKGkgPCBsZW5ndGgpIHtcclxuICAgICAgcmdiLnB1c2goZGF0YVtpKytdKTtcclxuICAgICAgcmdiLnB1c2goZGF0YVtpKytdKTtcclxuICAgICAgcmdiLnB1c2goZGF0YVtpKytdKTtcclxuICAgICAgaSsrOyAvLyBmb3IgdGhlIGFscGhhIGNoYW5uZWwgd2hpY2ggd2UgZG9uJ3QgY2FyZSBhYm91dFxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHJnYjtcclxufSIsImltcG9ydCB7IE5ldVF1YW50IH0gZnJvbSBcIi4vbmV1cXVhbnQuanNcIjtcclxuaW1wb3J0IGltYWdlRGF0YVRvUkdCIGZyb20gXCIuL2ltYWdlRGF0YVRvUkdCXCI7XHJcblxyXG5mdW5jdGlvbiBjb21wb25lbnRpemVkUGFsZXR0ZVRvQXJyYXkocGFsZXR0ZVJHQikge1xyXG4gIHBhbGV0dGVSR0IgPSBwYWxldHRlUkdCIHx8IFtdO1xyXG5cclxuICBsZXQgcGFsZXR0ZUFycmF5ID0gW107XHJcblxyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcGFsZXR0ZVJHQi5sZW5ndGg7IGkgKz0gMykge1xyXG4gICAgICBsZXQgciA9IHBhbGV0dGVSR0JbaV07XHJcbiAgICAgIGxldCBnID0gcGFsZXR0ZVJHQltpICsgMV07XHJcbiAgICAgIGxldCBiID0gcGFsZXR0ZVJHQltpICsgMl07XHJcblxyXG4gICAgICBwYWxldHRlQXJyYXkucHVzaChyIDw8IDE2IHwgZyA8PCA4IHwgYik7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gcGFsZXR0ZUFycmF5O1xyXG59XHJcblxyXG4vKipcclxuICog5bCGRmlsZe+8iEJsb2LvvInlr7nosaHovazlj5jkuLrkuIDkuKpkYXRhVVJM5a2X56ym5LiyXHJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS95YWhvby9naWZzaG90L2Jsb2IvbWFzdGVyL3NyYy9naWZzaG90LmpzXHJcbiAqXHJcbiAqIEBwYXJhbSB7SW1hZ2VEYXRhfSBpbWFnZURhdGFcclxuICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHRcclxuICogQHBhcmFtIHtudW1iZXJ9IHNhbXBsZUludGVydmFsXHJcbiAqIEByZXR1cm5zIHtBcnJheX0gUHJvbWlzZeWQq+acieS4gOS4qmRhdGFVUkzlrZfnrKbkuLLlj4LmlbBcclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHByb2Nlc3NGcmFtZVdpdGhRdWFudGl6ZXIoaW1hZ2VEYXRhOiBJbWFnZURhdGEsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyLCBzYW1wbGVJbnRlcnZhbDogbnVtYmVyKSB7XHJcbiAgbGV0IHJnYkNvbXBvbmVudHMgPSBpbWFnZURhdGFUb1JHQihBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChpbWFnZURhdGEuZGF0YSksIHdpZHRoLCBoZWlnaHQpO1xyXG4gIGxldCBudW1iZXJQaXhlbHM6IG51bWJlciA9IHdpZHRoICogaGVpZ2h0O1xyXG5cclxuICBsZXQgbnEgPSBOZXVRdWFudChyZ2JDb21wb25lbnRzLCByZ2JDb21wb25lbnRzLmxlbmd0aCwgc2FtcGxlSW50ZXJ2YWwpO1xyXG4gIFxyXG4gIGxldCBwYWxldHRlUkdCbnEgPSBucS5wcm9jZXNzKCk7XHJcbiAgbGV0IHBhbGV0dGVBcnJheTogYW55ID0gW107XHJcblxyXG4gIC8vIENoZWNrIGxpbmUgMTEzNSwgZ2lmc2hvdC5qcy5cclxuICBwYWxldHRlQXJyYXkgPSBuZXcgVWludDMyQXJyYXkoY29tcG9uZW50aXplZFBhbGV0dGVUb0FycmF5KHBhbGV0dGVSR0JucSkpO1xyXG4gIGxldCBpbmRleGVkUGl4ZWxzOiBhbnkgPSBuZXcgVWludDhBcnJheShudW1iZXJQaXhlbHMpO1xyXG4gIGxldCBrID0gMDtcclxuXHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1iZXJQaXhlbHM7IGkrKykge1xyXG4gICAgICBsZXQgcjogbnVtYmVyID0gcmdiQ29tcG9uZW50c1trKytdO1xyXG4gICAgICBsZXQgZzogbnVtYmVyID0gcmdiQ29tcG9uZW50c1trKytdO1xyXG4gICAgICBsZXQgYjogbnVtYmVyID0gcmdiQ29tcG9uZW50c1trKytdO1xyXG5cclxuICAgICAgaW5kZXhlZFBpeGVsc1tpXSA9IG5xLm1hcChyLCBnLCBiKTtcclxuICB9XHJcblxyXG4gIHJldHVybiB7XHJcbiAgICAgIHBpeGVsczogaW5kZXhlZFBpeGVscyxcclxuICAgICAgcGFsZXR0ZTogcGFsZXR0ZUFycmF5XHJcbiAgfTtcclxufSIsIi8qKlxyXG4gKiDpgJrov4fkuIDkuKrlm77niYfnmoR1cmzliqDovb3miYDpnIDopoHnmoRGaWxl77yIQmxvYu+8ieWvueixoVxyXG4gKlxyXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIC0g5Zu+54mHVVJMXHJcbiAqIEByZXR1cm5zIHtQcm9taXNlKEJsb2IpfVxyXG4gKlxyXG4gKi9cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdXJsdG9CbG9iKHVybDogc3RyaW5nKTogUHJvbWlzZTxCbG9iPiB7XHJcbiAgcmV0dXJuIGZldGNoKHVybCkudGhlbihyZXNwb25zZSA9PiByZXNwb25zZS5ibG9iKCkpO1xyXG59OyIsImltcG9ydCB7IEltYWdlMkNhbnZhc0NvbmZpZyB9IGZyb20gJ0Btb2RlbHMnO1xyXG5pbXBvcnQgeyBGcmFtZSwgRnJhbWVPcHRpb25zLCBHaWZPcHRpb25zLCBHaWZSZWFkZXIsIEdpZldyaXRlciB9IGZyb20gJ29tZ2dpZic7XHJcbmltcG9ydCBwcm9jZXNzRnJhbWVXaXRoUXVhbnRpemVyIGZyb20gJy4vcHJvY2Vzc0ZyYW1lV2l0aFF1YW50aXplcic7XHJcbmltcG9ydCB1cmx0b0Jsb2IgZnJvbSAnLi91cmx0b0Jsb2InO1xyXG5cclxuZnVuY3Rpb24gc2NhbGVJbWFnZURhdGEoaW1hZ2U6IENhbnZhc0ltYWdlU291cmNlLCBzY2FsZV94OiBudW1iZXIsIHNjYWxlX3k6IG51bWJlcik6IEltYWdlRGF0YSB7XHJcbiAgbGV0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG4gIGNhbnZhcy53aWR0aCA9IGltYWdlLndpZHRoIGFzIG51bWJlcjtcclxuICBjYW52YXMuaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0IGFzIG51bWJlcjtcclxuXHJcbiAgbGV0IGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcclxuICBjb250ZXh0LmRyYXdJbWFnZShpbWFnZSwgMCwgMClcclxuICBcclxuICBsZXQgdG1wQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcbiAgdG1wQ2FudmFzLndpZHRoID0gaW1hZ2Uud2lkdGggYXMgbnVtYmVyICogc2NhbGVfeDtcclxuICB0bXBDYW52YXMuaGVpZ2h0ID0gaW1hZ2UuaGVpZ2h0IGFzIG51bWJlciAqIHNjYWxlX3k7XHJcblxyXG4gIGxldCB0bXBDdHggPSB0bXBDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcclxuICB0bXBDdHguc2NhbGUoc2NhbGVfeCwgc2NhbGVfeSk7XHJcbiAgdG1wQ3R4LmRyYXdJbWFnZShjYW52YXMsIDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XHJcblxyXG4gIHJldHVybiB0bXBDdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIHRtcENhbnZhcy53aWR0aCwgdG1wQ2FudmFzLmhlaWdodCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJvdGF0ZUNhbnZhcyhpbWFnZTogQ2FudmFzSW1hZ2VTb3VyY2UsIG9yaWVudGF0aW9uOiBudW1iZXIpOiBIVE1MQ2FudmFzRWxlbWVudCB7XHJcbiAgbGV0IGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcclxuICBjYW52YXMud2lkdGggPSBpbWFnZS53aWR0aCBhcyBudW1iZXI7XHJcbiAgY2FudmFzLmhlaWdodCA9IGltYWdlLmhlaWdodCBhcyBudW1iZXI7XHJcblxyXG4gIGxldCBjb250ZXh0OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcclxuXHJcbiAgcmV0dXJuIHJvdGF0ZUNhbnZhc0luUGxhY2UoaW1hZ2UsIG9yaWVudGF0aW9uLCBjYW52YXMsIGNvbnRleHQpO1xyXG59XHJcblxyXG5mdW5jdGlvbiByb3RhdGVDYW52YXNJblBsYWNlKGltYWdlOiBDYW52YXNJbWFnZVNvdXJjZSwgb3JpZW50YXRpb246IG51bWJlciwgY3ZzOiBIVE1MQ2FudmFzRWxlbWVudCwgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpOiBIVE1MQ2FudmFzRWxlbWVudCB7XHJcbiAgXHJcbiAgLy8g6K6+572u5pa55ZCRXHJcbiAgc3dpdGNoIChvcmllbnRhdGlvbikge1xyXG4gICAgY2FzZSAzOlxyXG4gICAgICBjdHgucm90YXRlKDE4MCAqIE1hdGguUEkgLyAxODApO1xyXG4gICAgICBjdHguZHJhd0ltYWdlKGltYWdlLCAtY3ZzLndpZHRoLCAtY3ZzLmhlaWdodCwgY3ZzLndpZHRoLCBjdnMuaGVpZ2h0KTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIDY6XHJcbiAgICAgIGN0eC5yb3RhdGUoOTAgKiBNYXRoLlBJIC8gMTgwKTtcclxuICAgICAgY3R4LmRyYXdJbWFnZShpbWFnZSwgMCwgLWN2cy53aWR0aCwgY3ZzLmhlaWdodCwgY3ZzLndpZHRoKTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIDg6XHJcbiAgICAgIGN0eC5yb3RhdGUoMjcwICogTWF0aC5QSSAvIDE4MCk7XHJcbiAgICAgIGN0eC5kcmF3SW1hZ2UoaW1hZ2UsIC1jdnMuaGVpZ2h0LCAwLCBjdnMuaGVpZ2h0LCBjdnMud2lkdGgpO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgMjpcclxuICAgICAgY3R4LnRyYW5zbGF0ZShjdnMud2lkdGgsIDApO1xyXG4gICAgICBjdHguc2NhbGUoLTEsIDEpO1xyXG4gICAgICBjdHguZHJhd0ltYWdlKGltYWdlLCAwLCAwLCBjdnMud2lkdGgsIGN2cy5oZWlnaHQpO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgNDpcclxuICAgICAgY3R4LnRyYW5zbGF0ZShjdnMud2lkdGgsIDApO1xyXG4gICAgICBjdHguc2NhbGUoLTEsIDEpO1xyXG4gICAgICBjdHgucm90YXRlKDE4MCAqIE1hdGguUEkgLyAxODApO1xyXG4gICAgICBjdHguZHJhd0ltYWdlKGltYWdlLCAtY3ZzLndpZHRoLCAtY3ZzLmhlaWdodCwgY3ZzLndpZHRoLCBjdnMuaGVpZ2h0KTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBjYXNlIDU6XHJcbiAgICAgIGN0eC50cmFuc2xhdGUoY3ZzLndpZHRoLCAwKTtcclxuICAgICAgY3R4LnNjYWxlKC0xLCAxKTtcclxuICAgICAgY3R4LnJvdGF0ZSg5MCAqIE1hdGguUEkgLyAxODApO1xyXG4gICAgICBjdHguZHJhd0ltYWdlKGltYWdlLCAwLCAtY3ZzLndpZHRoLCBjdnMuaGVpZ2h0LCBjdnMud2lkdGgpO1xyXG4gICAgICBicmVhaztcclxuICAgIGNhc2UgNzpcclxuICAgICAgY3R4LnRyYW5zbGF0ZShjdnMud2lkdGgsIDApO1xyXG4gICAgICBjdHguc2NhbGUoLTEsIDEpO1xyXG4gICAgICBjdHgucm90YXRlKDI3MCAqIE1hdGguUEkgLyAxODApO1xyXG4gICAgICBjdHguZHJhd0ltYWdlKGltYWdlLCAtY3ZzLmhlaWdodCwgMCwgY3ZzLmhlaWdodCwgY3ZzLndpZHRoKTtcclxuICAgICAgYnJlYWs7XHJcbiAgICBkZWZhdWx0OlxyXG4gICAgICBjdHguZHJhd0ltYWdlKGltYWdlLCAwLCAwLCBjdnMud2lkdGgsIGN2cy5oZWlnaHQpO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGN2cztcclxufVxyXG5cclxuZnVuY3Rpb24gaW1hZ2VEYXRhVG9DYW52YXMoaW1hZ2VEYXRhOiBJbWFnZURhdGEsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyKTogSFRNTENhbnZhc0VsZW1lbnR7XHJcbiAgbGV0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG4gIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xyXG4gIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XHJcblxyXG4gIGxldCBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XHJcbiAgY29udGV4dC5wdXRJbWFnZURhdGEoaW1hZ2VEYXRhLCAwLCAwKTtcclxuXHJcbiAgcmV0dXJuIGNhbnZhcztcclxufVxyXG5cclxuLyoqXHJcbiAqIOWwhuS4gOS4qmltYWdl5a+56LGh6L2s5Y+Y5Li65LiA5LiqY2FudmFz5a+56LGhXHJcbiAqXHJcbiAqIEBwYXJhbSB7aW1hZ2V9IGltYWdlXHJcbiAqXHJcbiAqIEB0eXBlZGVmIHtPYmplY3Q9fSBjb25maWcgLSDovazlj5jkuLpjYW52YXPml7bnmoTkuIDkupvlj4LmlbDphY3nva5cclxuICogXHRcdEBwYXJhbSB7bnVtYmVyfSB3aWR0aCAtIGNhbnZhc+WbvuWDj+eahOWuveW6pu+8jOm7mOiupOS4umltYWdl55qE5a695bqmXHJcbiAqIFx0XHRAcGFyYW0ge251bWJlcn0gaGVpZ2h0IC0gY2FudmFz5Zu+5YOP55qE6auY5bqm77yM6buY6K6k5Li6aW1hZ2XnmoTpq5jluqZcclxuICogXHRcdEBwYXJhbSB7bnVtYmVyfSBzY2FsZSAtIOebuOWvueS6jmltYWdl55qE57yp5pS+5q+U5L6L77yM6IyD5Zu0MC0xMO+8jOm7mOiupOS4jee8qeaUvu+8m1xyXG4gKiBcdFx0XHTorr7nva5jb25maWcuc2NhbGXlkI7kvJropobnm5Zjb25maWcud2lkdGjlkoxjb25maWcuaGVpZ2h055qE6K6+572u77ybXHJcbiAqIFx0XHRAcGFyYW0ge251bWJlcn0gb3JpZW50YXRpb24gLSDlm77niYfml4vovazlj4LmlbDvvIzpu5jorqTkuI3ml4vovazvvIzlj4LogIPlpoLkuIvvvJpcclxuICogXHRcdFx05Y+C5pWwXHQg5peL6L2s5pa55ZCRXHJcbiAqIFx0XHRcdDFcdFx0MMKwXHJcbiAqIFx0XHRcdDJcdFx05rC05bmz57+76L2sXHJcbiAqIFx0XHRcdDNcdFx0MTgwwrBcclxuICogXHRcdFx0NFx0XHTlnoLnm7Tnv7vovaxcclxuICogXHRcdFx0NVx0XHTpobrml7bpkog5MMKwK+awtOW5s+e/u+i9rFxyXG4gKiBcdFx0XHQ2XHRcdOmhuuaXtumSiDkwwrBcclxuICogXHRcdFx0N1x0XHTpobrml7bpkog5MMKwK+WeguebtOe/u+i9rFxyXG4gKiBcdFx0XHQ4XHRcdOmAhuaXtumSiDkwwrBcclxuICogQHR5cGUge2NvbmZpZ31cclxuICpcclxuICogQHJldHVybnMge1Byb21pc2UoY2FudmFzKX1cclxuICovXHJcbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIGltYWdldG9DYW52YXMoaW1hZ2U6IEhUTUxJbWFnZUVsZW1lbnQsIGNvbmZpZzogSW1hZ2UyQ2FudmFzQ29uZmlnID0ge30pOiBQcm9taXNlPEhUTUxDYW52YXNFbGVtZW50PiB7XHJcbiAgY29uc3QgbXlDb25maWcgPSB7IC4uLmNvbmZpZyB9O1xyXG4gIGNvbnN0IGN2cyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xyXG4gIGNvbnN0IGN0eCA9IGN2cy5nZXRDb250ZXh0KCcyZCcpO1xyXG4gIGxldCBoZWlnaHQ6IG51bWJlcjtcclxuICBsZXQgd2lkdGg6IG51bWJlcjtcclxuXHJcbiAgZm9yIChjb25zdCBpIGluIG15Q29uZmlnKSB7XHJcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG15Q29uZmlnLCBpKSkge1xyXG4gICAgICBteUNvbmZpZ1tpXSA9IE51bWJlcihteUNvbmZpZ1tpXSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIC8vIOiuvue9ruWuvemrmFxyXG4gIGlmICghbXlDb25maWcuc2NhbGUpIHtcclxuICAgIHdpZHRoID0gbXlDb25maWcud2lkdGggfHwgbXlDb25maWcuaGVpZ2h0ICogaW1hZ2Uud2lkdGggLyBpbWFnZS5oZWlnaHQgfHwgaW1hZ2Uud2lkdGg7XHJcbiAgICBoZWlnaHQgPSBteUNvbmZpZy5oZWlnaHQgfHwgbXlDb25maWcud2lkdGggKiBpbWFnZS5oZWlnaHQgLyBpbWFnZS53aWR0aCB8fCBpbWFnZS5oZWlnaHQ7XHJcbiAgfSBlbHNlIHtcclxuICAgIC8vIOe8qeaUvuavlOS+izAtMTDvvIzkuI3lnKjmraTojIPlm7TliJnkv53mjIHljp/mnaXlm77lg4/lpKflsI9cclxuICAgIGNvbnN0IHNjYWxlID0gbXlDb25maWcuc2NhbGUgPiAwICYmIG15Q29uZmlnLnNjYWxlIDwgMTAgPyBteUNvbmZpZy5zY2FsZSA6IDE7XHJcbiAgICB3aWR0aCA9IE1hdGguZmxvb3IoaW1hZ2Uud2lkdGggKiBzY2FsZSk7XHJcbiAgICBoZWlnaHQgPSBNYXRoLmZsb29yKGltYWdlLmhlaWdodCAqIHNjYWxlKTtcclxuICB9XHJcblxyXG4gIC8vIOW9k+mhuuaXtumSiOaIluiAhemAhuaXtumSiOaXi+i9rDkw5pe277yM6ZyA6KaB5Lqk5o2iY2FudmFz55qE5a696auYXHJcbiAgaWYgKFs1LCA2LCA3LCA4XS5zb21lKGkgPT4gaSA9PT0gbXlDb25maWcub3JpZW50YXRpb24pKSB7XHJcbiAgICBjdnMuaGVpZ2h0ID0gd2lkdGg7XHJcbiAgICBjdnMud2lkdGggPSBoZWlnaHQ7XHJcbiAgfSBlbHNlIHtcclxuICAgIGN2cy5oZWlnaHQgPSBoZWlnaHQ7XHJcbiAgICBjdnMud2lkdGggPSB3aWR0aDtcclxuICB9XHJcblxyXG4gIC8vIEdJRiByZWFkL3dyaXRlLlxyXG4gIGxldCBibG9iID0gYXdhaXQgdXJsdG9CbG9iKGltYWdlLnNyYyk7XHJcbiAgaWYgKGJsb2IudHlwZSA9PSBcImltYWdlL2dpZlwiKXtcclxuICAgIGxldCBidWY6IFVpbnQ4QXJyYXkgPSBuZXcgVWludDhBcnJheShhd2FpdCBibG9iLmFycmF5QnVmZmVyKCkpO1xyXG4gICAgbGV0IHJlYWRlcjogR2lmUmVhZGVyID0gbmV3IEdpZlJlYWRlcihidWYgYXMgQnVmZmVyKTtcclxuXHJcbiAgICBsZXQgZ2lmT3B0aW9uczogR2lmT3B0aW9ucyA9IHtcclxuICAgICAgbG9vcDogcmVhZGVyLmxvb3BDb3VudCgpLFxyXG4gICAgICAvLyBiYWNrZ3JvdW5kOiAxXHJcbiAgICB9O1xyXG4gICAgbGV0IHdyaXR0ZW5CdWY6IFVpbnQ4QXJyYXkgPSBuZXcgVWludDhBcnJheSh3aWR0aCAqIGhlaWdodCAqIHJlYWRlci5udW1GcmFtZXMoKSAqIDUpO1xyXG4gICAgbGV0IHdyaXRlcjogR2lmV3JpdGVyID0gbmV3IEdpZldyaXRlcih3cml0dGVuQnVmIGFzIEJ1ZmZlciwgd2lkdGgsIGhlaWdodCwgZ2lmT3B0aW9ucyk7XHJcblxyXG4gICAgbGV0IGltYWdlRGF0YXM6IEltYWdlRGF0YVtdID0gbmV3IEFycmF5KHJlYWRlci5udW1GcmFtZXMoKSk7XHJcbiAgICBmb3IgKGxldCBrOiBudW1iZXIgPSAwOyBrIDwgaW1hZ2VEYXRhcy5sZW5ndGg7IGsrKyl7XHJcbiAgICAgIGxldCBpbWFnZSA9IG5ldyBJbWFnZURhdGEocmVhZGVyLndpZHRoLCByZWFkZXIuaGVpZ2h0KTtcclxuICAgICAgbGV0IGZyYW1lSW5mbzogRnJhbWUgPSByZWFkZXIuZnJhbWVJbmZvKGspO1xyXG5cclxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL0NhcHRhaW5Db2RlbWFuL2dpZi1wbGF5ZXIvYmxvYi9kNDVlZWNkYjc0NThlMDhjNTY1MzQxYjJlYjJkNjgxOTUzMjlmMjQ3L2NvbXBvbmVudHMvZ2lmLXBsYXllci9zcmMvZ2lmLXBsYXllci5qcyNMMzU3XHJcbiAgICAgIGlmIChrID4gMCAmJiBmcmFtZUluZm8uZGlzcG9zYWwgPCAyKSB7XHJcbiAgICAgICAgaW1hZ2UuZGF0YS5zZXQobmV3IFVpbnQ4Q2xhbXBlZEFycmF5KGltYWdlRGF0YXNbay0xXS5kYXRhKSk7XHJcbiAgICAgIH1cclxuICAgICAgcmVhZGVyLmRlY29kZUFuZEJsaXRGcmFtZVJHQkEoaywgaW1hZ2UuZGF0YSBhcyBVaW50OENsYW1wZWRBcnJheSk7XHJcblxyXG4gICAgICBpbWFnZURhdGFzW2tdID0gaW1hZ2U7XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIFdyaXRlXHJcbiAgICBpbWFnZURhdGFzLm1hcCgoaW1hZ2UsIGspID0+IHtcclxuICAgICAgbGV0IGZyYW1lSW5mbzogRnJhbWUgPSByZWFkZXIuZnJhbWVJbmZvKGspO1xyXG4gICAgICBsZXQgY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCA9IGltYWdlRGF0YVRvQ2FudmFzKGltYWdlLCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0KTtcclxuICAgICAgY2FudmFzID0gcm90YXRlQ2FudmFzKGNhbnZhcywgbXlDb25maWcub3JpZW50YXRpb24pO1xyXG4gICAgICAvLyBpbWFnZSA9IGltYWdlRGF0YVRvQ2FudmFzKGltYWdlLCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0KS5nZXRDb250ZXh0KCcyZCcpLmdldEltYWdlRGF0YSgwLCAwLCBpbWFnZS53aWR0aCwgaW1hZ2UuaGVpZ2h0KTtcclxuICAgICAgaW1hZ2UgPSBzY2FsZUltYWdlRGF0YShjYW52YXMsIHdpZHRoL2ltYWdlLndpZHRoLCBoZWlnaHQvaW1hZ2UuaGVpZ2h0KTtcclxuXHJcbiAgICAgIGxldCBmcmFtZU5xID0gcHJvY2Vzc0ZyYW1lV2l0aFF1YW50aXplcihpbWFnZSwgd2lkdGgsIGhlaWdodCwgMTApO1xyXG4gICAgICBsZXQgZnJhbWVPcHRpb25zOiBGcmFtZU9wdGlvbnMgPSB7XHJcbiAgICAgICAgcGFsZXR0ZTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJhbWVOcS5wYWxldHRlKSxcclxuICAgICAgICBkZWxheTogZnJhbWVJbmZvLmRlbGF5LFxyXG4gICAgICAgIGRpc3Bvc2FsOiBmcmFtZUluZm8uZGlzcG9zYWwsXHJcbiAgICAgICAgLy8gdHJhbnNwYXJlbnQ6IGZyYW1lSW5mby50cmFuc3BhcmVudF9pbmRleFxyXG4gICAgICB9O1xyXG4gICAgICB3cml0ZXIuYWRkRnJhbWUoMCwgMCwgd2lkdGgsIGhlaWdodCwgZnJhbWVOcS5waXhlbHMsIGZyYW1lT3B0aW9ucyk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBsZXQgYmFzZTY0UG5nID0gaW1hZ2VEYXRhcy5tYXAoKGltYWdlLCBrKSA9PiB7XHJcbiAgICAgIGxldCBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50ID0gaW1hZ2VEYXRhVG9DYW52YXMoaW1hZ2UsIGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQpO1xyXG4gICAgICBjYW52YXMgPSByb3RhdGVDYW52YXMoY2FudmFzLCBteUNvbmZpZy5vcmllbnRhdGlvbik7XHJcblxyXG4gICAgICByZXR1cm4gY2FudmFzLnRvRGF0YVVSTChcImltYWdlL3BuZ1wiKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnNvbGUubG9nKGJhc2U2NFBuZyk7XHJcblxyXG4gICAgd3JpdGVyLmVuZCgpO1xyXG5cclxuICAgIGxldCBidWZTdHIgPSBidWZmZXJUb1N0cmluZyh3cml0dGVuQnVmKTtcclxuICAgIGxldCBnaWYgPSBgZGF0YTppbWFnZS9naWY7YmFzZTY0LCR7YnRvYShidWZTdHIpfWA7XHJcblxyXG4gICAgY29uc29sZS5sb2coZ2lmKTtcclxuICB9XHJcblxyXG4gIHJvdGF0ZUNhbnZhc0luUGxhY2UoaW1hZ2UsIG15Q29uZmlnLm9yaWVudGF0aW9uLCBjdnMsIGN0eCk7XHJcblxyXG4gIHJldHVybiBjdnM7XHJcbn07XHJcblxyXG5sZXQgYnl0ZU1hcDogc3RyaW5nW10gPSBbXTtcclxuXHJcbmZvciAobGV0IGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcclxuICBieXRlTWFwW2ldID0gU3RyaW5nLmZyb21DaGFyQ29kZShpKTtcclxufVxyXG5cclxuZnVuY3Rpb24gYnVmZmVyVG9TdHJpbmcoYnVmZmVyOiBVaW50OEFycmF5KTogc3RyaW5nIHtcclxuICBsZXQgbnVtYmVyVmFsdWVzID0gYnVmZmVyLmxlbmd0aDtcclxuICBsZXQgc3RyID0gJyc7XHJcbiAgbGV0IHggPSAtMTtcclxuXHJcbiAgd2hpbGUgKCsreCA8IG51bWJlclZhbHVlcykge1xyXG4gICAgc3RyICs9IGJ5dGVNYXBbYnVmZmVyW3hdXTtcclxuICB9XHJcblxyXG4gIHJldHVybiBzdHI7XHJcbn0iLCIvKipcclxuICog6YCa6L+H5LiA5Liq5Zu+54mH55qEdXJs5Yqg6L295omA6ZyA6KaB55qEaW1hZ2Xlr7nosaFcclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IHVybCAtIOWbvueJh1VSTFxyXG4gKiBAcmV0dXJucyB7UHJvbWlzZShJbWFnZSl9XHJcbiAqL1xyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB1cmx0b0ltYWdlKHVybDogc3RyaW5nKTogUHJvbWlzZTxIVE1MSW1hZ2VFbGVtZW50PiB7XHJcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgIGNvbnN0IGltZyA9IG5ldyBJbWFnZSgpO1xyXG4gICAgaW1nLm9ubG9hZCA9ICgpID0+IHJlc29sdmUoaW1nKTtcclxuICAgIGltZy5vbmVycm9yID0gKCkgPT4gcmVqZWN0KG5ldyBFcnJvcigndXJsdG9JbWFnZSgpOiBJbWFnZSBmYWlsZWQgdG8gbG9hZCwgcGxlYXNlIGNoZWNrIHRoZSBpbWFnZSBVUkwnKSk7XHJcbiAgICBpbWcuc3JjID0gdXJsO1xyXG4gIH0pO1xyXG59OyIsImltcG9ydCBjYW52YXN0b0RhdGFVUkwgZnJvbSAnLi9jYW52YXN0b0RhdGFVUkwnO1xyXG5pbXBvcnQgY2FudmFzdG9GaWxlIGZyb20gJy4vY2FudmFzdG9GaWxlJztcclxuaW1wb3J0IGRhdGFVUkx0b0ZpbGUgZnJvbSAnLi9kYXRhVVJMdG9GaWxlJztcclxuaW1wb3J0IGRhdGFVUkx0b0ltYWdlIGZyb20gJy4vZGF0YVVSTHRvSW1hZ2UnO1xyXG5pbXBvcnQgZG93bmxvYWRGaWxlIGZyb20gJy4vZG93bmxvYWRGaWxlJztcclxuaW1wb3J0IGZpbGV0b0RhdGFVUkwgZnJvbSAnLi9maWxldG9EYXRhVVJMJztcclxuaW1wb3J0IGltYWdldG9DYW52YXMgZnJvbSAnLi9pbWFnZXRvQ2FudmFzJztcclxuaW1wb3J0IHVybHRvQmxvYiBmcm9tICcuL3VybHRvQmxvYic7XHJcbmltcG9ydCB1cmx0b0ltYWdlIGZyb20gJy4vdXJsdG9JbWFnZSc7XHJcbmltcG9ydCB7IGNoZWNrSW1hZ2VUeXBlIH0gZnJvbSAnQHV0aWxzJztcclxuaW1wb3J0IHsgRUltYWdlVHlwZSwgSUNvbXByZXNzQ29uZmlnLCBjb21wcmVzc0FjY3VyYXRlbHlDb25maWcgfSBmcm9tICdAbW9kZWxzJztcclxuXHJcbi8qKlxyXG4gKiDljovnvKlGaWxl77yIQmxvYu+8ieWvueixoVxyXG4gKiBAcGFyYW0ge0Jsb2J9IGZpbGUgLSDkuIDkuKpGaWxl77yIQmxvYu+8ieWvueixoVxyXG4gKiBAcGFyYW0geyhudW1iZXJ8b2JqZWN0KX0gY29uZmlnIC0g5aaC5p6c5Lyg5YWl5pivbnVtYmVy57G75Z6L77yM5Lyg5YWl6IyD5Zu0IDAtMe+8jOihqOekuuWbvueJh+WOi+e8qei0qOmHjyzpu5jorqQwLjky77yb5Lmf5Y+v5Lul5Lyg5YWlb2JqZWN057G75Z6L77yM5Lul5L6/5pu06K+m57uG55qE6YWN572uXHJcbiAqIEBleGFtcGxlXHJcbiAqIFx0XHRpbWFnZUNvbnZlcnNpb24uY29tcHJlc3MoZmlsZSwwLjgpXHJcbiAqXHJcbiAqIFx0XHRpbWFnZUNvbnZlcnNpb24uY29tcHJlc3MoZmlsZSx7XHJcbiAqIFx0XHRcdHF1YWxpdHk6IDAuOCwgLy/lm77niYfljovnvKnotKjph49cclxuICogXHRcdFx0dHlwZe+8mlwiaW1hZ2UvcG5nXCIsIC8v6L2s5o2i5ZCO55qE5Zu+54mH57G75Z6L77yM6YCJ6aG55pyJIFwiaW1hZ2UvcG5nXCIsIFwiaW1hZ2UvanBlZ1wiLCBcImltYWdlL2dpZlwiXHJcbiAqIFx0XHRcdHdpZHRoOiAzMDAsIC8v55Sf5oiQ5Zu+54mH55qE5a695bqmXHJcbiAqIFx0XHRcdGhlaWdodO+8mjIwMO+8jCAvL+eUn+S6p+WbvueJh+eahOmrmOW6plxyXG4gKiBcdFx0XHRzY2FsZTogMC4177yMIC8v55u45a+55LqO5Y6f5aeL5Zu+54mH55qE57yp5pS+5q+U546HLOiuvue9rmNvbmZpZy5zY2FsZeWQjuS8muimhueblmNvbmZpZy53aWR0aOWSjGNvbmZpZy5oZWlnaHTnmoTorr7nva7vvJtcclxuICogXHRcdFx0b3JpZW50YXRpb246MiwgLy/lm77niYfml4vovazmlrnlkJFcclxuICogXHRcdH0pXHJcbiAqXHJcbiAqIEByZXR1cm5zIHtQcm9taXNlKEJsb2IpfVxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gY29tcHJlc3MoZmlsZTogRmlsZSwgY29uZmlnOiBJQ29tcHJlc3NDb25maWcgPSB7fSk6IFByb21pc2U8QmxvYj4ge1xyXG4gIGlmICghKGZpbGUgaW5zdGFuY2VvZiBCbG9iKSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdjb21wcmVzcygpOiBGaXJzdCBhcmcgbXVzdCBiZSBhIEJsb2Igb2JqZWN0IG9yIGEgRmlsZSBvYmplY3QuJyk7XHJcbiAgfVxyXG4gIGlmICh0eXBlb2YgY29uZmlnICE9PSAnb2JqZWN0Jykge1xyXG4gICAgY29uZmlnID0gT2JqZWN0LmFzc2lnbih7XHJcbiAgICAgIHF1YWxpdHk6IGNvbmZpZyxcclxuICAgIH0pO1xyXG4gIH1cclxuICBjb25maWcucXVhbGl0eSA9IE51bWJlcihjb25maWcucXVhbGl0eSk7XHJcbiAgaWYgKE51bWJlci5pc05hTihjb25maWcucXVhbGl0eSkpIHtcclxuICAgIHJldHVybiBmaWxlO1xyXG4gIH1cclxuICBjb25zdCBkYXRhVVJMID0gYXdhaXQgZmlsZXRvRGF0YVVSTChmaWxlKTtcclxuICBsZXQgb3JpZ2luYWxNaW1lID0gZGF0YVVSTC5zcGxpdCgnLCcpWzBdLm1hdGNoKC86KC4qPyk7LylbMV0gYXMgRUltYWdlVHlwZTsgLy8g5Y6f5aeL5Zu+5YOP5Zu+54mH57G75Z6LXHJcbiAgbGV0IG1pbWUgPSBFSW1hZ2VUeXBlLkpQRUc7IC8vIOm7mOiupOWOi+e8qeexu+Wei1xyXG4gIGlmIChjaGVja0ltYWdlVHlwZShjb25maWcudHlwZSkpIHtcclxuICAgIG1pbWUgPSBjb25maWcudHlwZTtcclxuICAgIG9yaWdpbmFsTWltZSA9IGNvbmZpZy50eXBlO1xyXG4gIH1cclxuICBjb25zdCBpbWFnZSA9IGF3YWl0IGRhdGFVUkx0b0ltYWdlKGRhdGFVUkwpO1xyXG4gIGNvbnN0IGNhbnZhcyA9IGF3YWl0IGltYWdldG9DYW52YXMoaW1hZ2UsIE9iamVjdC5hc3NpZ24oe30sIGNvbmZpZykpO1xyXG4gIGNvbnN0IGNvbXByZXNzRGF0YVVSTCA9IGF3YWl0IGNhbnZhc3RvRGF0YVVSTChjYW52YXMsIGNvbmZpZy5xdWFsaXR5LCBtaW1lKTtcclxuICBjb25zdCBjb21wcmVzc0ZpbGUgPSBhd2FpdCBkYXRhVVJMdG9GaWxlKGNvbXByZXNzRGF0YVVSTCwgb3JpZ2luYWxNaW1lKTtcclxuICBpZiAoY29tcHJlc3NGaWxlLnNpemUgPiBmaWxlLnNpemUpIHtcclxuICAgIHJldHVybiBmaWxlO1xyXG4gIH1cclxuICByZXR1cm4gY29tcHJlc3NGaWxlO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIOagueaNruS9k+enr+WOi+e8qUZpbGXvvIhCbG9i77yJ5a+56LGhXHJcbiAqXHJcbiAqIEBwYXJhbSB7QmxvYn0gZmlsZSAtIOS4gOS4qkZpbGXvvIhCbG9i77yJ5a+56LGhXHJcbiAqIEBwYXJhbSB7KG51bWJlcnxvYmplY3QpfSBjb25maWcgLSDlpoLmnpzkvKDlhaXmmK9udW1iZXLnsbvlnovvvIzliJnmjIflrprljovnvKnlm77niYfnmoTkvZPnp68s5Y2V5L2NS2I75Lmf5Y+v5Lul5Lyg5YWlb2JqZWN057G75Z6L77yM5Lul5L6/5pu06K+m57uG55qE6YWN572uXHJcbiAqIFx0XHRAcGFyYW0ge251bWJlcn0gc2l6ZSAtIOaMh+WumuWOi+e8qeWbvueJh+eahOS9k+enryzljZXkvY1LYlxyXG4gKiBcdFx0QHBhcmFtIHtudW1iZXJ9IGFjY3VyYWN5IC0g55u45a+55LqO5oyH5a6a5Y6L57yp5L2T56ev55qE57K+56Gu5bqm77yM6IyD5Zu0MC44LTAuOTnvvIzpu5jorqQwLjk177ybXHJcbiAqICAgICAgICDlpoLmnpzorr7nva4g5Zu+54mH5L2T56evMTAwMEtiLOeyvuehruW6pjAuOe+8jOWImeWOi+e8qee7k+aenOS4ujkwMEtiLTExMDBLYueahOWbvueJh+mDveeul+WQiOagvO+8m1xyXG4gKiBAZXhhbXBsZVxyXG4gKiAgXHRpbWFnZUNvbnZlcnNpb24uY29tcHJlc3MoZmlsZSwxMDApIC8v5Y6L57yp5ZCO5Zu+54mH5aSn5bCP5Li6MTAwa2JcclxuICpcclxuICogXHRcdGltYWdlQ29udmVyc2lvbi5jb21wcmVzcyhmaWxlLHtcclxuICogXHRcdFx0c2l6ZTogMTAwLCAvL+WbvueJh+WOi+e8qeS9k+enr++8jOWNleS9jUtiXHJcbiAqIFx0XHRcdGFjY3VyYWN5OiAwLjksIC8v5Zu+54mH5Y6L57yp5L2T56ev55qE57K+56Gu5bqm77yM6buY6K6kMC45NVxyXG4gKiBcdFx0XHR0eXBl77yaXCJpbWFnZS9wbmdcIiwgLy/ovazmjaLlkI7nmoTlm77niYfnsbvlnovvvIzpgInpobnmnIkgXCJpbWFnZS9wbmdcIiwgXCJpbWFnZS9qcGVnXCIsIFwiaW1hZ2UvZ2lmXCJcclxuICogXHRcdFx0d2lkdGg6IDMwMCwgLy/nlJ/miJDlm77niYfnmoTlrr3luqZcclxuICogXHRcdFx0aGVpZ2h0OiAyMDAsIC8v55Sf5Lqn5Zu+54mH55qE6auY5bqmXHJcbiAqIFx0XHRcdHNjYWxlOiAwLjUsIC8v55u45a+55LqO5Y6f5aeL5Zu+54mH55qE57yp5pS+5q+U546HLOiuvue9rmNvbmZpZy5zY2FsZeWQjuS8muimhueblmNvbmZpZy53aWR0aOWSjGNvbmZpZy5oZWlnaHTnmoTorr7nva7vvJtcclxuICogXHRcdFx0b3JpZW50YXRpb246MiwgLy/lm77niYfml4vovazmlrnlkJFcclxuICogXHRcdH0pXHJcbiAqXHJcbiAqIEByZXR1cm5zIHtQcm9taXNlKEJsb2IpfVxyXG4gKi9cclxuYXN5bmMgZnVuY3Rpb24gY29tcHJlc3NBY2N1cmF0ZWx5KGZpbGU6IEJsb2IsIGNvbmZpZzogY29tcHJlc3NBY2N1cmF0ZWx5Q29uZmlnID0ge30pOiBQcm9taXNlPEJsb2I+IHtcclxuICBpZiAoIShmaWxlIGluc3RhbmNlb2YgQmxvYikpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignY29tcHJlc3NBY2N1cmF0ZWx5KCk6IEZpcnN0IGFyZyBtdXN0IGJlIGEgQmxvYiBvYmplY3Qgb3IgYSBGaWxlIG9iamVjdC4nKTtcclxuICB9XHJcbiAgaWYgKHR5cGVvZiBjb25maWcgIT09ICdvYmplY3QnKSB7XHJcbiAgICBjb25maWcgPSBPYmplY3QuYXNzaWduKHtcclxuICAgICAgc2l6ZTogY29uZmlnLFxyXG4gICAgfSk7XHJcbiAgfVxyXG4gIC8vIOWmguaenOaMh+WumuS9k+enr+S4jeaYr+aVsOWtl+aIluiAheaVsOWtl+Wtl+espuS4su+8jOWImeS4jeWBmuWkhOeQhlxyXG4gIGNvbmZpZy5zaXplID0gTnVtYmVyKGNvbmZpZy5zaXplKTtcclxuICBpZiAoTnVtYmVyLmlzTmFOKGNvbmZpZy5zaXplKSkge1xyXG4gICAgcmV0dXJuIGZpbGU7XHJcbiAgfVxyXG4gIC8vIOWmguaenOaMh+WumuS9k+enr+Wkp+S6juWOn+aWh+S7tuS9k+enr++8jOWImeS4jeWBmuWkhOeQhu+8m1xyXG4gIGlmIChjb25maWcuc2l6ZSAqIDEwMjQgPiBmaWxlLnNpemUpIHtcclxuICAgIHJldHVybiBmaWxlO1xyXG4gIH1cclxuICBjb25maWcuYWNjdXJhY3kgPSBOdW1iZXIoY29uZmlnLmFjY3VyYWN5KTtcclxuICBpZiAoIWNvbmZpZy5hY2N1cmFjeVxyXG4gICAgfHwgY29uZmlnLmFjY3VyYWN5IDwgMC44XHJcbiAgICB8fCBjb25maWcuYWNjdXJhY3kgPiAwLjk5KSB7XHJcbiAgICBjb25maWcuYWNjdXJhY3kgPSAwLjk1OyAvLyDpu5jorqTnsr7luqYwLjk1XHJcbiAgfVxyXG4gIGNvbnN0IHJlc3VsdFNpemUgPSB7XHJcbiAgICBtYXg6IGNvbmZpZy5zaXplICogKDIgLSBjb25maWcuYWNjdXJhY3kpICogMTAyNCxcclxuICAgIGFjY3VyYXRlOiBjb25maWcuc2l6ZSAqIDEwMjQsXHJcbiAgICBtaW46IGNvbmZpZy5zaXplICogY29uZmlnLmFjY3VyYWN5ICogMTAyNCxcclxuICB9O1xyXG4gIGNvbnN0IGRhdGFVUkwgPSBhd2FpdCBmaWxldG9EYXRhVVJMKGZpbGUpO1xyXG4gIGxldCBvcmlnaW5hbE1pbWUgPSBkYXRhVVJMLnNwbGl0KCcsJylbMF0ubWF0Y2goLzooLio/KTsvKVsxXSBhcyBFSW1hZ2VUeXBlOyAvLyDljp/lp4vlm77lg4/lm77niYfnsbvlnotcclxuICBsZXQgbWltZSA9IEVJbWFnZVR5cGUuSlBFRztcclxuICBpZiAoY2hlY2tJbWFnZVR5cGUoY29uZmlnLnR5cGUpKSB7XHJcbiAgICBtaW1lID0gY29uZmlnLnR5cGU7XHJcbiAgICBvcmlnaW5hbE1pbWUgPSBjb25maWcudHlwZTtcclxuICB9XHJcbiAgY29uc3QgaW1hZ2UgPSBhd2FpdCBkYXRhVVJMdG9JbWFnZShkYXRhVVJMKTtcclxuICBjb25zdCBjYW52YXMgPSBhd2FpdCBpbWFnZXRvQ2FudmFzKGltYWdlLCBPYmplY3QuYXNzaWduKHt9LCBjb25maWcpKTtcclxuICAvKipcclxuICAgKiDnu4/ov4fmtYvor5Xlj5HnjrDvvIxibG9iLnNpemXkuI5kYXRhVVJMLmxlbmd0aOeahOavlOWAvOe6puetieS6jjAuNzVcclxuICAgKiDov5nkuKrmr5TlgLzlj6/ku6XlkIzov4dkYXRhVVJMdG9GaWxl6L+Z5Liq5pa55rOV5p2l5rWL6K+V6aqM6K+BXHJcbiAgICog6L+Z6YeM5Li65LqG5o+Q6auY5oCn6IO977yM55u05o6l6YCa6L+H6L+Z5Liq5q+U5YC85p2l6K6h566X5Ye6YmxvYi5zaXplXHJcbiAgICovXHJcbiAgY29uc3QgcHJvcG9ydGlvbiA9IDAuNzU7XHJcbiAgbGV0IGltYWdlUXVhbGl0eSA9IDAuNTtcclxuICBsZXQgY29tcHJlc3NEYXRhVVJMO1xyXG4gIGNvbnN0IHRlbXBEYXRhVVJMczogc3RyaW5nW10gPSBbbnVsbCwgbnVsbF07XHJcbiAgLyoqXHJcbiAgICogSFRNTENhbnZhc0VsZW1lbnQudG9CbG9iKCnku6Xlj4pIVE1MQ2FudmFzRWxlbWVudC50b0RhdGFVUkwoKeWOi+e8qeWPguaVsFxyXG4gICAqIOeahOacgOWwj+e7hueykuW6puS4ujAuMDHvvIzogIwy55qEN+asoeaWueS4ujEyOO+8jOWNs+WPquimgeW+queOrzfmrKHvvIzliJnkvJropobnm5bmiYDmnInlj6/og73mgKdcclxuICAgKi9cclxuICBmb3IgKGxldCB4ID0gMTsgeCA8PSA3OyB4KyspIHtcclxuICAgIGNvbXByZXNzRGF0YVVSTCA9IGF3YWl0IGNhbnZhc3RvRGF0YVVSTChjYW52YXMsIGltYWdlUXVhbGl0eSwgbWltZSk7XHJcbiAgICBjb25zdCBDYWxjdWxhdGlvblNpemUgPSBjb21wcmVzc0RhdGFVUkwubGVuZ3RoICogcHJvcG9ydGlvbjtcclxuICAgIC8vIOWmguaenOWIsOW+queOr+esrOS4g+asoei/mOayoeaciei+vuWIsOeyvuehruW6pueahOWAvO+8jOmCo+ivtOaYjuivpeWbvueJh+S4jeiDvei+vuWIsOWIsOatpOeyvuehruW6puimgeaxglxyXG4gICAgLy8g6L+Z5pe25YCZ5pyA5ZCO5LiA5qyh5b6q546v5Ye65p2l55qEZGF0YVVSTOWPr+iDveS4jeaYr+acgOeyvuehrueahO+8jOmcgOimgeWPluWFtuWRqOi+ueS4pOS4qmRhdGFVUkzkuInogIXmr5TovoPmnaXpgInlh7rmnIDnsr7noa7nmoTvvJtcclxuICAgIGlmICh4ID09PSA3KSB7XHJcbiAgICAgIGlmIChyZXN1bHRTaXplLm1heCA8IENhbGN1bGF0aW9uU2l6ZSB8fCByZXN1bHRTaXplLm1pbiA+IENhbGN1bGF0aW9uU2l6ZSkge1xyXG4gICAgICAgIGNvbXByZXNzRGF0YVVSTCA9IFtjb21wcmVzc0RhdGFVUkwsIC4uLnRlbXBEYXRhVVJMc11cclxuICAgICAgICAgIC5maWx0ZXIoaSA9PiBpKSAvLyDljrvpmaRudWxsXHJcbiAgICAgICAgICAuc29ydCgoYSwgYikgPT4gTWF0aC5hYnMoYS5sZW5ndGggKiBwcm9wb3J0aW9uIC0gcmVzdWx0U2l6ZS5hY2N1cmF0ZSlcclxuICAgICAgICAgICAgLSBNYXRoLmFicyhiLmxlbmd0aCAqIHByb3BvcnRpb24gLSByZXN1bHRTaXplLmFjY3VyYXRlKSlbMF07XHJcbiAgICAgIH1cclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgICBpZiAocmVzdWx0U2l6ZS5tYXggPCBDYWxjdWxhdGlvblNpemUpIHtcclxuICAgICAgdGVtcERhdGFVUkxzWzFdID0gY29tcHJlc3NEYXRhVVJMO1xyXG4gICAgICBpbWFnZVF1YWxpdHkgLT0gMC41ICoqICh4ICsgMSk7XHJcbiAgICB9IGVsc2UgaWYgKHJlc3VsdFNpemUubWluID4gQ2FsY3VsYXRpb25TaXplKSB7XHJcbiAgICAgIHRlbXBEYXRhVVJMc1swXSA9IGNvbXByZXNzRGF0YVVSTDtcclxuICAgICAgaW1hZ2VRdWFsaXR5ICs9IDAuNSAqKiAoeCArIDEpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgfVxyXG4gIGNvbnN0IGNvbXByZXNzRmlsZSA9IGF3YWl0IGRhdGFVUkx0b0ZpbGUoY29tcHJlc3NEYXRhVVJMLCBvcmlnaW5hbE1pbWUpO1xyXG4gIC8vIOWmguaenOWOi+e8qeWQjuS9k+enr+Wkp+S6juWOn+aWh+S7tuS9k+enr++8jOWImei/lOWbnua6kOaWh+S7tu+8m1xyXG4gIGlmIChjb21wcmVzc0ZpbGUuc2l6ZSA+IGZpbGUuc2l6ZSkge1xyXG4gICAgcmV0dXJuIGZpbGU7XHJcbiAgfVxyXG4gIHJldHVybiBjb21wcmVzc0ZpbGU7XHJcbn07XHJcblxyXG5leHBvcnQge1xyXG4gIGNhbnZhc3RvRGF0YVVSTCxcclxuICBjYW52YXN0b0ZpbGUsXHJcbiAgZGF0YVVSTHRvRmlsZSxcclxuICBkYXRhVVJMdG9JbWFnZSxcclxuICBkb3dubG9hZEZpbGUsXHJcbiAgZmlsZXRvRGF0YVVSTCxcclxuICBpbWFnZXRvQ2FudmFzLFxyXG4gIHVybHRvQmxvYixcclxuICB1cmx0b0ltYWdlLFxyXG4gIGNvbXByZXNzLFxyXG4gIGNvbXByZXNzQWNjdXJhdGVseVxyXG59O1xyXG5cclxuZXhwb3J0IHtcclxuICBFSW1hZ2VUeXBlXHJcbn07Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1\n')}])}));